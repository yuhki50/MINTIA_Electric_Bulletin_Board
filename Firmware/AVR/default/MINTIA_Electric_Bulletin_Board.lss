
MINTIA_Electric_Bulletin_Board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001c2  00800100  00003794  00003828  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003794  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000122  008002c2  008002c2  000039ea  2**0
                  ALLOC
  3 .debug_aranges 000001e0  00000000  00000000  000039ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000382  00000000  00000000  00003bca  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004948  00000000  00000000  00003f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001912  00000000  00000000  00008894  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002b06  00000000  00000000  0000a1a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000420  00000000  00000000  0000ccac  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000cbf  00000000  00000000  0000d0cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002e16  00000000  00000000  0000dd8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002e8  00000000  00000000  00010ba1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	12 e0       	ldi	r17, 0x02	; 2
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 e9       	ldi	r30, 0x94	; 148
      7c:	f7 e3       	ldi	r31, 0x37	; 55
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	a2 3c       	cpi	r26, 0xC2	; 194
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a2 ec       	ldi	r26, 0xC2	; 194
      8e:	b2 e0       	ldi	r27, 0x02	; 2
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a4 3e       	cpi	r26, 0xE4	; 228
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 87 00 	call	0x10e	; 0x10e <main>
      9e:	0c 94 c8 1b 	jmp	0x3790	; 0x3790 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_16>:
	}
}


/* タイマー0割り込み (LEDマトリックス表示) */
ISR(TIMER0_OVF_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	2f 93       	push	r18
      b2:	3f 93       	push	r19
      b4:	4f 93       	push	r20
      b6:	5f 93       	push	r21
      b8:	6f 93       	push	r22
      ba:	7f 93       	push	r23
      bc:	8f 93       	push	r24
      be:	9f 93       	push	r25
      c0:	af 93       	push	r26
      c2:	bf 93       	push	r27
      c4:	ef 93       	push	r30
      c6:	ff 93       	push	r31
	static uint8_t rowCount = 0;

	ledMatrixCtrl_writeFrameAsync((uint16_t*)frame);
      c8:	8b e0       	ldi	r24, 0x0B	; 11
      ca:	91 e0       	ldi	r25, 0x01	; 1
      cc:	0e 94 34 0b 	call	0x1668	; 0x1668 <ledMatrixCtrl_writeFrameAsync>

	if(rowCount >= LMC_HEIGHT_COUNT - 1) {
      d0:	80 91 c2 02 	lds	r24, 0x02C2
      d4:	8d 30       	cpi	r24, 0x0D	; 13
      d6:	38 f0       	brcs	.+14     	; 0xe6 <__vector_16+0x40>
		rowCount = 0;
      d8:	10 92 c2 02 	sts	0x02C2, r1
		ledMatrixCtrl_disable();
      dc:	0e 94 1a 0b 	call	0x1634	; 0x1634 <ledMatrixCtrl_disable>
		ledMatrixCtrl_enable();
      e0:	0e 94 18 0b 	call	0x1630	; 0x1630 <ledMatrixCtrl_enable>
      e4:	03 c0       	rjmp	.+6      	; 0xec <__vector_16+0x46>
	} else {
		rowCount++;
      e6:	8f 5f       	subi	r24, 0xFF	; 255
      e8:	80 93 c2 02 	sts	0x02C2, r24
	}
}
      ec:	ff 91       	pop	r31
      ee:	ef 91       	pop	r30
      f0:	bf 91       	pop	r27
      f2:	af 91       	pop	r26
      f4:	9f 91       	pop	r25
      f6:	8f 91       	pop	r24
      f8:	7f 91       	pop	r23
      fa:	6f 91       	pop	r22
      fc:	5f 91       	pop	r21
      fe:	4f 91       	pop	r20
     100:	3f 91       	pop	r19
     102:	2f 91       	pop	r18
     104:	0f 90       	pop	r0
     106:	0f be       	out	0x3f, r0	; 63
     108:	0f 90       	pop	r0
     10a:	1f 90       	pop	r1
     10c:	18 95       	reti

0000010e <main>:
}


/* ポート初期化 */
static inline void port_init(void) {
	DDRB = INIT_DDRB;
     10e:	14 b8       	out	0x04, r1	; 4
	DDRC = INIT_DDRC;
     110:	17 b8       	out	0x07, r1	; 7
	DDRD = INIT_DDRD;
     112:	1a b8       	out	0x0a, r1	; 10
	PORTB = INIT_PORTB;
     114:	15 b8       	out	0x05, r1	; 5
	PORTC = INIT_PORTC;
     116:	18 b8       	out	0x08, r1	; 8
	PORTD = INIT_PORTD;
     118:	1b b8       	out	0x0b, r1	; 11
}


/* タイマー初期化 */
static inline void timer_init(void) {
	TCCR0A = INIT_TCCR0A;
     11a:	14 bc       	out	0x24, r1	; 36
	TCCR0B = INIT_TCCR0B;
     11c:	82 e0       	ldi	r24, 0x02	; 2
     11e:	85 bd       	out	0x25, r24	; 37
	TCNT0 = INIT_TCNT0;
     120:	16 bc       	out	0x26, r1	; 38
	TIMSK0 = INIT_TIMSK0;
     122:	81 e0       	ldi	r24, 0x01	; 1
     124:	80 93 6e 00 	sts	0x006E, r24
}


/* 内部モジュール初期化 */
static inline void module_init(void) {
	ACSR = INIT_ACSR;
     128:	80 e8       	ldi	r24, 0x80	; 128
     12a:	80 bf       	out	0x30, r24	; 48
	PRR = INIT_PRR;
     12c:	8b ec       	ldi	r24, 0xCB	; 203
     12e:	80 93 64 00 	sts	0x0064, r24
}


/* 内部オシレータ校正 */
static inline void osc_init(void) {
	uint8_t osc_cal = eeprom_read_byte(OSCCAL_EEPROM_ADDRESS);
     132:	8f ef       	ldi	r24, 0xFF	; 255
     134:	93 e0       	ldi	r25, 0x03	; 3
     136:	0e 94 9d 1b 	call	0x373a	; 0x373a <__eerd_byte_m328p>
     13a:	98 2f       	mov	r25, r24

	if(!(osc_cal == 0x00) && !(osc_cal == 0xFF)) {
     13c:	81 50       	subi	r24, 0x01	; 1
     13e:	8e 3f       	cpi	r24, 0xFE	; 254
     140:	10 f4       	brcc	.+4      	; 0x146 <main+0x38>
		OSCCAL = osc_cal;
     142:	90 93 66 00 	sts	0x0066, r25
     146:	88 ee       	ldi	r24, 0xE8	; 232
     148:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     14a:	28 ec       	ldi	r18, 0xC8	; 200
     14c:	30 e0       	ldi	r19, 0x00	; 0
     14e:	f9 01       	movw	r30, r18
     150:	31 97       	sbiw	r30, 0x01	; 1
     152:	f1 f7       	brne	.-4      	; 0x150 <main+0x42>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     154:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     156:	d9 f7       	brne	.-10     	; 0x14e <main+0x40>

	// SDカードが安定するまで待つ //
	_delay_ms(100);

	// 周辺デバイス初期化 //
	ledMatrixCtrl_init();
     158:	0e 94 14 0b 	call	0x1628	; 0x1628 <ledMatrixCtrl_init>
	ledMatrixCtrl_disable();
     15c:	0e 94 1a 0b 	call	0x1634	; 0x1634 <ledMatrixCtrl_disable>
	ledMatrixCtrl_enable();
     160:	0e 94 18 0b 	call	0x1630	; 0x1630 <ledMatrixCtrl_enable>

	// 割り込み許可 //
	sei();
     164:	78 94       	sei

	STATUS_PORT |= _BV(STATUS_LED0) | _BV(STATUS_LED1);
     166:	88 b1       	in	r24, 0x08	; 8
     168:	83 60       	ori	r24, 0x03	; 3
     16a:	88 b9       	out	0x08, r24	; 8

	// GIFファイル読み込み//
	while(1) {
		gif_open("mintia.gif");
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	91 e0       	ldi	r25, 0x01	; 1
     170:	0e 94 1e 14 	call	0x283c	; 0x283c <gif_open>
		convertImages();
     174:	0e 94 b7 11 	call	0x236e	; 0x236e <convertImages>
     178:	f9 cf       	rjmp	.-14     	; 0x16c <main+0x5e>

0000017a <dir_rewind>:

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
     17a:	cf 92       	push	r12
     17c:	df 92       	push	r13
     17e:	ef 92       	push	r14
     180:	ff 92       	push	r15
     182:	0f 93       	push	r16
     184:	1f 93       	push	r17
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	6c 01       	movw	r12, r24
	CLUST clst;
	FATFS *fs = FatFs;
     18c:	c0 91 c3 02 	lds	r28, 0x02C3
     190:	d0 91 c4 02 	lds	r29, 0x02C4


	dj->index = 0;
     194:	fc 01       	movw	r30, r24
     196:	11 82       	std	Z+1, r1	; 0x01
     198:	10 82       	st	Z, r1
	clst = dj->sclust;
     19a:	24 81       	ldd	r18, Z+4	; 0x04
     19c:	35 81       	ldd	r19, Z+5	; 0x05
     19e:	46 81       	ldd	r20, Z+6	; 0x06
     1a0:	57 81       	ldd	r21, Z+7	; 0x07
	if (clst == 1 || clst >= fs->max_clust)	/* Check start cluster range */
     1a2:	21 30       	cpi	r18, 0x01	; 1
     1a4:	31 05       	cpc	r19, r1
     1a6:	41 05       	cpc	r20, r1
     1a8:	51 05       	cpc	r21, r1
     1aa:	09 f4       	brne	.+2      	; 0x1ae <dir_rewind+0x34>
     1ac:	5b c0       	rjmp	.+182    	; 0x264 <dir_rewind+0xea>
     1ae:	88 85       	ldd	r24, Y+8	; 0x08
     1b0:	99 85       	ldd	r25, Y+9	; 0x09
     1b2:	aa 85       	ldd	r26, Y+10	; 0x0a
     1b4:	bb 85       	ldd	r27, Y+11	; 0x0b
     1b6:	28 17       	cp	r18, r24
     1b8:	39 07       	cpc	r19, r25
     1ba:	4a 07       	cpc	r20, r26
     1bc:	5b 07       	cpc	r21, r27
     1be:	08 f0       	brcs	.+2      	; 0x1c2 <dir_rewind+0x48>
     1c0:	51 c0       	rjmp	.+162    	; 0x264 <dir_rewind+0xea>
		return FR_DISK_ERR;
#if _FS_FAT32
	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
     1c2:	21 15       	cp	r18, r1
     1c4:	31 05       	cpc	r19, r1
     1c6:	41 05       	cpc	r20, r1
     1c8:	51 05       	cpc	r21, r1
     1ca:	39 f4       	brne	.+14     	; 0x1da <dir_rewind+0x60>
     1cc:	88 81       	ld	r24, Y
     1ce:	83 30       	cpi	r24, 0x03	; 3
     1d0:	21 f4       	brne	.+8      	; 0x1da <dir_rewind+0x60>
		clst = fs->dirbase;
     1d2:	28 89       	ldd	r18, Y+16	; 0x10
     1d4:	39 89       	ldd	r19, Y+17	; 0x11
     1d6:	4a 89       	ldd	r20, Y+18	; 0x12
     1d8:	5b 89       	ldd	r21, Y+19	; 0x13
#endif
	dj->clust = clst;						/* Current cluster */
     1da:	f6 01       	movw	r30, r12
     1dc:	20 87       	std	Z+8, r18	; 0x08
     1de:	31 87       	std	Z+9, r19	; 0x09
     1e0:	42 87       	std	Z+10, r20	; 0x0a
     1e2:	53 87       	std	Z+11, r21	; 0x0b
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	81 f1       	breq	.+96     	; 0x24e <dir_rewind+0xd4>
)
{
	FATFS *fs = FatFs;


	clst -= 2;
     1ee:	8e ef       	ldi	r24, 0xFE	; 254
     1f0:	e8 2e       	mov	r14, r24
     1f2:	8f ef       	ldi	r24, 0xFF	; 255
     1f4:	f8 2e       	mov	r15, r24
     1f6:	8f ef       	ldi	r24, 0xFF	; 255
     1f8:	08 2f       	mov	r16, r24
     1fa:	8f ef       	ldi	r24, 0xFF	; 255
     1fc:	18 2f       	mov	r17, r24
     1fe:	e2 0e       	add	r14, r18
     200:	f3 1e       	adc	r15, r19
     202:	04 1f       	adc	r16, r20
     204:	15 1f       	adc	r17, r21
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     206:	88 85       	ldd	r24, Y+8	; 0x08
     208:	99 85       	ldd	r25, Y+9	; 0x09
     20a:	aa 85       	ldd	r26, Y+10	; 0x0a
     20c:	bb 85       	ldd	r27, Y+11	; 0x0b
     20e:	02 97       	sbiw	r24, 0x02	; 2
     210:	a1 09       	sbc	r26, r1
     212:	b1 09       	sbc	r27, r1
     214:	e8 16       	cp	r14, r24
     216:	f9 06       	cpc	r15, r25
     218:	0a 07       	cpc	r16, r26
     21a:	1b 07       	cpc	r17, r27
     21c:	28 f0       	brcs	.+10     	; 0x228 <dir_rewind+0xae>
     21e:	20 e0       	ldi	r18, 0x00	; 0
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	40 e0       	ldi	r20, 0x00	; 0
     224:	50 e0       	ldi	r21, 0x00	; 0
     226:	17 c0       	rjmp	.+46     	; 0x256 <dir_rewind+0xdc>
	return (DWORD)clst * fs->csize + fs->database;
     228:	29 81       	ldd	r18, Y+1	; 0x01
     22a:	30 e0       	ldi	r19, 0x00	; 0
     22c:	40 e0       	ldi	r20, 0x00	; 0
     22e:	50 e0       	ldi	r21, 0x00	; 0
     230:	c8 01       	movw	r24, r16
     232:	b7 01       	movw	r22, r14
     234:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__mulsi3>
     238:	9b 01       	movw	r18, r22
     23a:	ac 01       	movw	r20, r24
     23c:	8c 89       	ldd	r24, Y+20	; 0x14
     23e:	9d 89       	ldd	r25, Y+21	; 0x15
     240:	ae 89       	ldd	r26, Y+22	; 0x16
     242:	bf 89       	ldd	r27, Y+23	; 0x17
     244:	28 0f       	add	r18, r24
     246:	39 1f       	adc	r19, r25
     248:	4a 1f       	adc	r20, r26
     24a:	5b 1f       	adc	r21, r27
     24c:	04 c0       	rjmp	.+8      	; 0x256 <dir_rewind+0xdc>
#if _FS_FAT32
	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = fs->dirbase;
#endif
	dj->clust = clst;						/* Current cluster */
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
     24e:	28 89       	ldd	r18, Y+16	; 0x10
     250:	39 89       	ldd	r19, Y+17	; 0x11
     252:	4a 89       	ldd	r20, Y+18	; 0x12
     254:	5b 89       	ldd	r21, Y+19	; 0x13
     256:	f6 01       	movw	r30, r12
     258:	24 87       	std	Z+12, r18	; 0x0c
     25a:	35 87       	std	Z+13, r19	; 0x0d
     25c:	46 87       	std	Z+14, r20	; 0x0e
     25e:	57 87       	std	Z+15, r21	; 0x0f
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	01 c0       	rjmp	.+2      	; 0x266 <dir_rewind+0xec>

	return FR_OK;	/* Seek succeeded */
     264:	81 e0       	ldi	r24, 0x01	; 1
}
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	1f 91       	pop	r17
     26c:	0f 91       	pop	r16
     26e:	ff 90       	pop	r15
     270:	ef 90       	pop	r14
     272:	df 90       	pop	r13
     274:	cf 90       	pop	r12
     276:	08 95       	ret

00000278 <get_fat>:

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
     278:	6f 92       	push	r6
     27a:	7f 92       	push	r7
     27c:	8f 92       	push	r8
     27e:	9f 92       	push	r9
     280:	af 92       	push	r10
     282:	bf 92       	push	r11
     284:	cf 92       	push	r12
     286:	df 92       	push	r13
     288:	ef 92       	push	r14
     28a:	ff 92       	push	r15
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	df 93       	push	r29
     292:	cf 93       	push	r28
     294:	00 d0       	rcall	.+0      	; 0x296 <get_fat+0x1e>
     296:	00 d0       	rcall	.+0      	; 0x298 <get_fat+0x20>
     298:	cd b7       	in	r28, 0x3d	; 61
     29a:	de b7       	in	r29, 0x3e	; 62
     29c:	4b 01       	movw	r8, r22
     29e:	5c 01       	movw	r10, r24
	WORD wc, bc, ofs;
	BYTE buf[4];
	FATFS *fs = FatFs;
     2a0:	60 90 c3 02 	lds	r6, 0x02C3
     2a4:	70 90 c4 02 	lds	r7, 0x02C4


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
     2a8:	82 e0       	ldi	r24, 0x02	; 2
     2aa:	88 16       	cp	r8, r24
     2ac:	91 04       	cpc	r9, r1
     2ae:	a1 04       	cpc	r10, r1
     2b0:	b1 04       	cpc	r11, r1
     2b2:	08 f4       	brcc	.+2      	; 0x2b6 <get_fat+0x3e>
     2b4:	b4 c0       	rjmp	.+360    	; 0x41e <get_fat+0x1a6>
     2b6:	f3 01       	movw	r30, r6
     2b8:	80 85       	ldd	r24, Z+8	; 0x08
     2ba:	91 85       	ldd	r25, Z+9	; 0x09
     2bc:	a2 85       	ldd	r26, Z+10	; 0x0a
     2be:	b3 85       	ldd	r27, Z+11	; 0x0b
     2c0:	88 16       	cp	r8, r24
     2c2:	99 06       	cpc	r9, r25
     2c4:	aa 06       	cpc	r10, r26
     2c6:	bb 06       	cpc	r11, r27
     2c8:	08 f0       	brcs	.+2      	; 0x2cc <get_fat+0x54>
     2ca:	a9 c0       	rjmp	.+338    	; 0x41e <get_fat+0x1a6>
		return 1;

	switch (fs->fs_type) {
     2cc:	80 81       	ld	r24, Z
     2ce:	82 30       	cpi	r24, 0x02	; 2
     2d0:	09 f4       	brne	.+2      	; 0x2d4 <get_fat+0x5c>
     2d2:	5f c0       	rjmp	.+190    	; 0x392 <get_fat+0x11a>
     2d4:	83 30       	cpi	r24, 0x03	; 3
     2d6:	09 f4       	brne	.+2      	; 0x2da <get_fat+0x62>
     2d8:	7b c0       	rjmp	.+246    	; 0x3d0 <get_fat+0x158>
     2da:	81 30       	cpi	r24, 0x01	; 1
     2dc:	09 f0       	breq	.+2      	; 0x2e0 <get_fat+0x68>
     2de:	9f c0       	rjmp	.+318    	; 0x41e <get_fat+0x1a6>
	case FS_FAT12 :
		bc = (WORD)clst; bc += bc / 2;
     2e0:	c4 01       	movw	r24, r8
     2e2:	96 95       	lsr	r25
     2e4:	87 95       	ror	r24
     2e6:	88 0d       	add	r24, r8
     2e8:	99 1d       	adc	r25, r9
		ofs = bc % 512; bc /= 512;
     2ea:	9c 01       	movw	r18, r24
     2ec:	31 70       	andi	r19, 0x01	; 1
     2ee:	89 2f       	mov	r24, r25
     2f0:	99 27       	eor	r25, r25
     2f2:	86 95       	lsr	r24
     2f4:	6c 01       	movw	r12, r24
     2f6:	ee 24       	eor	r14, r14
     2f8:	ff 24       	eor	r15, r15
     2fa:	f3 01       	movw	r30, r6
     2fc:	44 85       	ldd	r20, Z+12	; 0x0c
     2fe:	55 85       	ldd	r21, Z+13	; 0x0d
     300:	66 85       	ldd	r22, Z+14	; 0x0e
     302:	77 85       	ldd	r23, Z+15	; 0x0f
     304:	ce 01       	movw	r24, r28
     306:	01 96       	adiw	r24, 0x01	; 1
		if (ofs != 511) {
     308:	f1 e0       	ldi	r31, 0x01	; 1
     30a:	2f 3f       	cpi	r18, 0xFF	; 255
     30c:	3f 07       	cpc	r19, r31
     30e:	49 f0       	breq	.+18     	; 0x322 <get_fat+0xaa>
			if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
     310:	c4 0e       	add	r12, r20
     312:	d5 1e       	adc	r13, r21
     314:	e6 1e       	adc	r14, r22
     316:	f7 1e       	adc	r15, r23
     318:	b7 01       	movw	r22, r14
     31a:	a6 01       	movw	r20, r12
     31c:	02 e0       	ldi	r16, 0x02	; 2
     31e:	10 e0       	ldi	r17, 0x00	; 0
     320:	1e c0       	rjmp	.+60     	; 0x35e <get_fat+0xe6>
		} else {
			if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
     322:	4c 0d       	add	r20, r12
     324:	5d 1d       	adc	r21, r13
     326:	6e 1d       	adc	r22, r14
     328:	7f 1d       	adc	r23, r15
     32a:	2f ef       	ldi	r18, 0xFF	; 255
     32c:	31 e0       	ldi	r19, 0x01	; 1
     32e:	01 e0       	ldi	r16, 0x01	; 1
     330:	10 e0       	ldi	r17, 0x00	; 0
     332:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
     336:	88 23       	and	r24, r24
     338:	09 f0       	breq	.+2      	; 0x33c <get_fat+0xc4>
     33a:	71 c0       	rjmp	.+226    	; 0x41e <get_fat+0x1a6>
			if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
     33c:	f3 01       	movw	r30, r6
     33e:	44 85       	ldd	r20, Z+12	; 0x0c
     340:	55 85       	ldd	r21, Z+13	; 0x0d
     342:	66 85       	ldd	r22, Z+14	; 0x0e
     344:	77 85       	ldd	r23, Z+15	; 0x0f
     346:	4f 5f       	subi	r20, 0xFF	; 255
     348:	5f 4f       	sbci	r21, 0xFF	; 255
     34a:	6f 4f       	sbci	r22, 0xFF	; 255
     34c:	7f 4f       	sbci	r23, 0xFF	; 255
     34e:	4c 0d       	add	r20, r12
     350:	5d 1d       	adc	r21, r13
     352:	6e 1d       	adc	r22, r14
     354:	7f 1d       	adc	r23, r15
     356:	ce 01       	movw	r24, r28
     358:	02 96       	adiw	r24, 0x02	; 2
     35a:	20 e0       	ldi	r18, 0x00	; 0
     35c:	30 e0       	ldi	r19, 0x00	; 0
     35e:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
     362:	88 23       	and	r24, r24
     364:	09 f0       	breq	.+2      	; 0x368 <get_fat+0xf0>
     366:	5b c0       	rjmp	.+182    	; 0x41e <get_fat+0x1a6>
		}
		wc = LD_WORD(buf);
     368:	69 81       	ldd	r22, Y+1	; 0x01
     36a:	7a 81       	ldd	r23, Y+2	; 0x02
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
     36c:	c4 01       	movw	r24, r8
     36e:	81 70       	andi	r24, 0x01	; 1
     370:	90 70       	andi	r25, 0x00	; 0
     372:	89 2b       	or	r24, r25
     374:	39 f0       	breq	.+14     	; 0x384 <get_fat+0x10c>
     376:	a4 e0       	ldi	r26, 0x04	; 4
     378:	76 95       	lsr	r23
     37a:	67 95       	ror	r22
     37c:	aa 95       	dec	r26
     37e:	e1 f7       	brne	.-8      	; 0x378 <get_fat+0x100>
     380:	9b 01       	movw	r18, r22
     382:	23 c0       	rjmp	.+70     	; 0x3ca <get_fat+0x152>
     384:	9b 01       	movw	r18, r22
     386:	40 e0       	ldi	r20, 0x00	; 0
     388:	50 e0       	ldi	r21, 0x00	; 0
     38a:	3f 70       	andi	r19, 0x0F	; 15
     38c:	40 70       	andi	r20, 0x00	; 0
     38e:	50 70       	andi	r21, 0x00	; 0
     390:	4a c0       	rjmp	.+148    	; 0x426 <get_fat+0x1ae>

	case FS_FAT16 :
		if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
     392:	77 27       	eor	r23, r23
     394:	6b 2d       	mov	r22, r11
     396:	5a 2d       	mov	r21, r10
     398:	49 2d       	mov	r20, r9
     39a:	f3 01       	movw	r30, r6
     39c:	84 85       	ldd	r24, Z+12	; 0x0c
     39e:	95 85       	ldd	r25, Z+13	; 0x0d
     3a0:	a6 85       	ldd	r26, Z+14	; 0x0e
     3a2:	b7 85       	ldd	r27, Z+15	; 0x0f
     3a4:	48 0f       	add	r20, r24
     3a6:	59 1f       	adc	r21, r25
     3a8:	6a 1f       	adc	r22, r26
     3aa:	7b 1f       	adc	r23, r27
     3ac:	94 01       	movw	r18, r8
     3ae:	30 70       	andi	r19, 0x00	; 0
     3b0:	22 0f       	add	r18, r18
     3b2:	33 1f       	adc	r19, r19
     3b4:	ce 01       	movw	r24, r28
     3b6:	01 96       	adiw	r24, 0x01	; 1
     3b8:	02 e0       	ldi	r16, 0x02	; 2
     3ba:	10 e0       	ldi	r17, 0x00	; 0
     3bc:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
     3c0:	88 23       	and	r24, r24
     3c2:	69 f5       	brne	.+90     	; 0x41e <get_fat+0x1a6>
		return LD_WORD(buf);
     3c4:	89 81       	ldd	r24, Y+1	; 0x01
     3c6:	9a 81       	ldd	r25, Y+2	; 0x02
     3c8:	9c 01       	movw	r18, r24
     3ca:	40 e0       	ldi	r20, 0x00	; 0
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	2b c0       	rjmp	.+86     	; 0x426 <get_fat+0x1ae>
#if _FS_FAT32
	case FS_FAT32 :
		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
     3d0:	b5 01       	movw	r22, r10
     3d2:	a4 01       	movw	r20, r8
     3d4:	27 e0       	ldi	r18, 0x07	; 7
     3d6:	76 95       	lsr	r23
     3d8:	67 95       	ror	r22
     3da:	57 95       	ror	r21
     3dc:	47 95       	ror	r20
     3de:	2a 95       	dec	r18
     3e0:	d1 f7       	brne	.-12     	; 0x3d6 <get_fat+0x15e>
     3e2:	f3 01       	movw	r30, r6
     3e4:	84 85       	ldd	r24, Z+12	; 0x0c
     3e6:	95 85       	ldd	r25, Z+13	; 0x0d
     3e8:	a6 85       	ldd	r26, Z+14	; 0x0e
     3ea:	b7 85       	ldd	r27, Z+15	; 0x0f
     3ec:	48 0f       	add	r20, r24
     3ee:	59 1f       	adc	r21, r25
     3f0:	6a 1f       	adc	r22, r26
     3f2:	7b 1f       	adc	r23, r27
     3f4:	94 01       	movw	r18, r8
     3f6:	2f 77       	andi	r18, 0x7F	; 127
     3f8:	30 70       	andi	r19, 0x00	; 0
     3fa:	22 0f       	add	r18, r18
     3fc:	33 1f       	adc	r19, r19
     3fe:	22 0f       	add	r18, r18
     400:	33 1f       	adc	r19, r19
     402:	ce 01       	movw	r24, r28
     404:	01 96       	adiw	r24, 0x01	; 1
     406:	04 e0       	ldi	r16, 0x04	; 4
     408:	10 e0       	ldi	r17, 0x00	; 0
     40a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
     40e:	88 23       	and	r24, r24
     410:	31 f4       	brne	.+12     	; 0x41e <get_fat+0x1a6>
		return LD_DWORD(buf) & 0x0FFFFFFF;
     412:	29 81       	ldd	r18, Y+1	; 0x01
     414:	3a 81       	ldd	r19, Y+2	; 0x02
     416:	4b 81       	ldd	r20, Y+3	; 0x03
     418:	5c 81       	ldd	r21, Y+4	; 0x04
     41a:	5f 70       	andi	r21, 0x0F	; 15
     41c:	04 c0       	rjmp	.+8      	; 0x426 <get_fat+0x1ae>
     41e:	21 e0       	ldi	r18, 0x01	; 1
     420:	30 e0       	ldi	r19, 0x00	; 0
     422:	40 e0       	ldi	r20, 0x00	; 0
     424:	50 e0       	ldi	r21, 0x00	; 0
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
}
     426:	b9 01       	movw	r22, r18
     428:	ca 01       	movw	r24, r20
     42a:	0f 90       	pop	r0
     42c:	0f 90       	pop	r0
     42e:	0f 90       	pop	r0
     430:	0f 90       	pop	r0
     432:	cf 91       	pop	r28
     434:	df 91       	pop	r29
     436:	1f 91       	pop	r17
     438:	0f 91       	pop	r16
     43a:	ff 90       	pop	r15
     43c:	ef 90       	pop	r14
     43e:	df 90       	pop	r13
     440:	cf 90       	pop	r12
     442:	bf 90       	pop	r11
     444:	af 90       	pop	r10
     446:	9f 90       	pop	r9
     448:	8f 90       	pop	r8
     44a:	7f 90       	pop	r7
     44c:	6f 90       	pop	r6
     44e:	08 95       	ret

00000450 <dir_next>:

static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
	DIR *dj			/* Pointer to directory object */
)
{
     450:	af 92       	push	r10
     452:	bf 92       	push	r11
     454:	cf 92       	push	r12
     456:	df 92       	push	r13
     458:	ef 92       	push	r14
     45a:	ff 92       	push	r15
     45c:	0f 93       	push	r16
     45e:	1f 93       	push	r17
     460:	cf 93       	push	r28
     462:	df 93       	push	r29
     464:	5c 01       	movw	r10, r24
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;
     466:	c0 91 c3 02 	lds	r28, 0x02C3
     46a:	d0 91 c4 02 	lds	r29, 0x02C4


	i = dj->index + 1;
     46e:	fc 01       	movw	r30, r24
     470:	c0 80       	ld	r12, Z
     472:	d1 80       	ldd	r13, Z+1	; 0x01
     474:	08 94       	sec
     476:	c1 1c       	adc	r12, r1
     478:	d1 1c       	adc	r13, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
     47a:	c1 14       	cp	r12, r1
     47c:	d1 04       	cpc	r13, r1
     47e:	09 f4       	brne	.+2      	; 0x482 <dir_next+0x32>
     480:	8f c0       	rjmp	.+286    	; 0x5a0 <dir_next+0x150>
     482:	24 85       	ldd	r18, Z+12	; 0x0c
     484:	35 85       	ldd	r19, Z+13	; 0x0d
     486:	46 85       	ldd	r20, Z+14	; 0x0e
     488:	57 85       	ldd	r21, Z+15	; 0x0f
     48a:	21 15       	cp	r18, r1
     48c:	31 05       	cpc	r19, r1
     48e:	41 05       	cpc	r20, r1
     490:	51 05       	cpc	r21, r1
     492:	09 f4       	brne	.+2      	; 0x496 <dir_next+0x46>
     494:	85 c0       	rjmp	.+266    	; 0x5a0 <dir_next+0x150>
		return FR_NO_FILE;

	if (!(i & (16-1))) {	/* Sector changed? */
     496:	c6 01       	movw	r24, r12
     498:	8f 70       	andi	r24, 0x0F	; 15
     49a:	90 70       	andi	r25, 0x00	; 0
     49c:	89 2b       	or	r24, r25
     49e:	09 f0       	breq	.+2      	; 0x4a2 <dir_next+0x52>
     4a0:	7a c0       	rjmp	.+244    	; 0x596 <dir_next+0x146>
		dj->sect++;			/* Next sector */
     4a2:	2f 5f       	subi	r18, 0xFF	; 255
     4a4:	3f 4f       	sbci	r19, 0xFF	; 255
     4a6:	4f 4f       	sbci	r20, 0xFF	; 255
     4a8:	5f 4f       	sbci	r21, 0xFF	; 255
     4aa:	24 87       	std	Z+12, r18	; 0x0c
     4ac:	35 87       	std	Z+13, r19	; 0x0d
     4ae:	46 87       	std	Z+14, r20	; 0x0e
     4b0:	57 87       	std	Z+15, r21	; 0x0f

		if (dj->clust == 0) {	/* Static table */
     4b2:	40 85       	ldd	r20, Z+8	; 0x08
     4b4:	51 85       	ldd	r21, Z+9	; 0x09
     4b6:	62 85       	ldd	r22, Z+10	; 0x0a
     4b8:	73 85       	ldd	r23, Z+11	; 0x0b
     4ba:	41 15       	cp	r20, r1
     4bc:	51 05       	cpc	r21, r1
     4be:	61 05       	cpc	r22, r1
     4c0:	71 05       	cpc	r23, r1
     4c2:	39 f4       	brne	.+14     	; 0x4d2 <dir_next+0x82>
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
     4c4:	8c 81       	ldd	r24, Y+4	; 0x04
     4c6:	9d 81       	ldd	r25, Y+5	; 0x05
     4c8:	c8 16       	cp	r12, r24
     4ca:	d9 06       	cpc	r13, r25
     4cc:	08 f4       	brcc	.+2      	; 0x4d0 <dir_next+0x80>
     4ce:	63 c0       	rjmp	.+198    	; 0x596 <dir_next+0x146>
     4d0:	67 c0       	rjmp	.+206    	; 0x5a0 <dir_next+0x150>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	01 97       	sbiw	r24, 0x01	; 1
     4d8:	96 01       	movw	r18, r12
     4da:	e4 e0       	ldi	r30, 0x04	; 4
     4dc:	36 95       	lsr	r19
     4de:	27 95       	ror	r18
     4e0:	ea 95       	dec	r30
     4e2:	e1 f7       	brne	.-8      	; 0x4dc <dir_next+0x8c>
     4e4:	82 23       	and	r24, r18
     4e6:	93 23       	and	r25, r19
     4e8:	89 2b       	or	r24, r25
     4ea:	09 f0       	breq	.+2      	; 0x4ee <dir_next+0x9e>
     4ec:	54 c0       	rjmp	.+168    	; 0x596 <dir_next+0x146>
				clst = get_fat(dj->clust);		/* Get next cluster */
     4ee:	cb 01       	movw	r24, r22
     4f0:	ba 01       	movw	r22, r20
     4f2:	0e 94 3c 01 	call	0x278	; 0x278 <get_fat>
     4f6:	9b 01       	movw	r18, r22
     4f8:	ac 01       	movw	r20, r24
				if (clst <= 1) return FR_DISK_ERR;
     4fa:	62 30       	cpi	r22, 0x02	; 2
     4fc:	71 05       	cpc	r23, r1
     4fe:	81 05       	cpc	r24, r1
     500:	91 05       	cpc	r25, r1
     502:	10 f4       	brcc	.+4      	; 0x508 <dir_next+0xb8>
     504:	81 e0       	ldi	r24, 0x01	; 1
     506:	4d c0       	rjmp	.+154    	; 0x5a2 <dir_next+0x152>
				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
     508:	88 85       	ldd	r24, Y+8	; 0x08
     50a:	99 85       	ldd	r25, Y+9	; 0x09
     50c:	aa 85       	ldd	r26, Y+10	; 0x0a
     50e:	bb 85       	ldd	r27, Y+11	; 0x0b
     510:	28 17       	cp	r18, r24
     512:	39 07       	cpc	r19, r25
     514:	4a 07       	cpc	r20, r26
     516:	5b 07       	cpc	r21, r27
     518:	08 f0       	brcs	.+2      	; 0x51c <dir_next+0xcc>
     51a:	42 c0       	rjmp	.+132    	; 0x5a0 <dir_next+0x150>
					return FR_NO_FILE;			/* Report EOT */
				dj->clust = clst;				/* Initialize data for new cluster */
     51c:	f5 01       	movw	r30, r10
     51e:	20 87       	std	Z+8, r18	; 0x08
     520:	31 87       	std	Z+9, r19	; 0x09
     522:	42 87       	std	Z+10, r20	; 0x0a
     524:	53 87       	std	Z+11, r21	; 0x0b
static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
	FATFS *fs = FatFs;
     526:	c0 91 c3 02 	lds	r28, 0x02C3
     52a:	d0 91 c4 02 	lds	r29, 0x02C4


	clst -= 2;
     52e:	8e ef       	ldi	r24, 0xFE	; 254
     530:	e8 2e       	mov	r14, r24
     532:	8f ef       	ldi	r24, 0xFF	; 255
     534:	f8 2e       	mov	r15, r24
     536:	8f ef       	ldi	r24, 0xFF	; 255
     538:	08 2f       	mov	r16, r24
     53a:	8f ef       	ldi	r24, 0xFF	; 255
     53c:	18 2f       	mov	r17, r24
     53e:	e2 0e       	add	r14, r18
     540:	f3 1e       	adc	r15, r19
     542:	04 1f       	adc	r16, r20
     544:	15 1f       	adc	r17, r21
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     546:	88 85       	ldd	r24, Y+8	; 0x08
     548:	99 85       	ldd	r25, Y+9	; 0x09
     54a:	aa 85       	ldd	r26, Y+10	; 0x0a
     54c:	bb 85       	ldd	r27, Y+11	; 0x0b
     54e:	02 97       	sbiw	r24, 0x02	; 2
     550:	a1 09       	sbc	r26, r1
     552:	b1 09       	sbc	r27, r1
     554:	e8 16       	cp	r14, r24
     556:	f9 06       	cpc	r15, r25
     558:	0a 07       	cpc	r16, r26
     55a:	1b 07       	cpc	r17, r27
     55c:	28 f0       	brcs	.+10     	; 0x568 <dir_next+0x118>
     55e:	20 e0       	ldi	r18, 0x00	; 0
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	40 e0       	ldi	r20, 0x00	; 0
     564:	50 e0       	ldi	r21, 0x00	; 0
     566:	12 c0       	rjmp	.+36     	; 0x58c <dir_next+0x13c>
	return (DWORD)clst * fs->csize + fs->database;
     568:	29 81       	ldd	r18, Y+1	; 0x01
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	50 e0       	ldi	r21, 0x00	; 0
     570:	c8 01       	movw	r24, r16
     572:	b7 01       	movw	r22, r14
     574:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__mulsi3>
     578:	9b 01       	movw	r18, r22
     57a:	ac 01       	movw	r20, r24
     57c:	8c 89       	ldd	r24, Y+20	; 0x14
     57e:	9d 89       	ldd	r25, Y+21	; 0x15
     580:	ae 89       	ldd	r26, Y+22	; 0x16
     582:	bf 89       	ldd	r27, Y+23	; 0x17
     584:	28 0f       	add	r18, r24
     586:	39 1f       	adc	r19, r25
     588:	4a 1f       	adc	r20, r26
     58a:	5b 1f       	adc	r21, r27
				clst = get_fat(dj->clust);		/* Get next cluster */
				if (clst <= 1) return FR_DISK_ERR;
				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
					return FR_NO_FILE;			/* Report EOT */
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(clst);
     58c:	f5 01       	movw	r30, r10
     58e:	24 87       	std	Z+12, r18	; 0x0c
     590:	35 87       	std	Z+13, r19	; 0x0d
     592:	46 87       	std	Z+14, r20	; 0x0e
     594:	57 87       	std	Z+15, r21	; 0x0f
			}
		}
	}

	dj->index = i;
     596:	f5 01       	movw	r30, r10
     598:	d1 82       	std	Z+1, r13	; 0x01
     59a:	c0 82       	st	Z, r12
     59c:	80 e0       	ldi	r24, 0x00	; 0
     59e:	01 c0       	rjmp	.+2      	; 0x5a2 <dir_next+0x152>

	return FR_OK;
     5a0:	83 e0       	ldi	r24, 0x03	; 3
}
     5a2:	df 91       	pop	r29
     5a4:	cf 91       	pop	r28
     5a6:	1f 91       	pop	r17
     5a8:	0f 91       	pop	r16
     5aa:	ff 90       	pop	r15
     5ac:	ef 90       	pop	r14
     5ae:	df 90       	pop	r13
     5b0:	cf 90       	pop	r12
     5b2:	bf 90       	pop	r11
     5b4:	af 90       	pop	r10
     5b6:	08 95       	ret

000005b8 <pf_lseek>:
#if _USE_LSEEK

FRESULT pf_lseek (
	DWORD ofs		/* File pointer from top of file */
)
{
     5b8:	2f 92       	push	r2
     5ba:	3f 92       	push	r3
     5bc:	4f 92       	push	r4
     5be:	5f 92       	push	r5
     5c0:	6f 92       	push	r6
     5c2:	7f 92       	push	r7
     5c4:	8f 92       	push	r8
     5c6:	9f 92       	push	r9
     5c8:	af 92       	push	r10
     5ca:	bf 92       	push	r11
     5cc:	cf 92       	push	r12
     5ce:	df 92       	push	r13
     5d0:	ef 92       	push	r14
     5d2:	ff 92       	push	r15
     5d4:	0f 93       	push	r16
     5d6:	1f 93       	push	r17
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	e8 2f       	mov	r30, r24
	CLUST clst;
	DWORD bcs, sect, ifptr;
	FATFS *fs = FatFs;
     5de:	c0 91 c3 02 	lds	r28, 0x02C3
     5e2:	d0 91 c4 02 	lds	r29, 0x02C4


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
     5e6:	20 97       	sbiw	r28, 0x00	; 0
     5e8:	11 f4       	brne	.+4      	; 0x5ee <pf_lseek+0x36>
     5ea:	86 e0       	ldi	r24, 0x06	; 6
     5ec:	0d c1       	rjmp	.+538    	; 0x808 <pf_lseek+0x250>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
     5ee:	8a 81       	ldd	r24, Y+2	; 0x02
     5f0:	80 fd       	sbrc	r24, 0
     5f2:	02 c0       	rjmp	.+4      	; 0x5f8 <pf_lseek+0x40>
     5f4:	85 e0       	ldi	r24, 0x05	; 5
     5f6:	08 c1       	rjmp	.+528    	; 0x808 <pf_lseek+0x250>
     5f8:	ac 8c       	ldd	r10, Y+28	; 0x1c
     5fa:	bd 8c       	ldd	r11, Y+29	; 0x1d
     5fc:	ce 8c       	ldd	r12, Y+30	; 0x1e
     5fe:	df 8c       	ldd	r13, Y+31	; 0x1f
     600:	4e 2f       	mov	r20, r30
     602:	59 2f       	mov	r21, r25
     604:	cb 01       	movw	r24, r22
     606:	da 01       	movw	r26, r20
     608:	3c 01       	movw	r6, r24
     60a:	4d 01       	movw	r8, r26
     60c:	a6 14       	cp	r10, r6
     60e:	b7 04       	cpc	r11, r7
     610:	c8 04       	cpc	r12, r8
     612:	d9 04       	cpc	r13, r9
     614:	10 f4       	brcc	.+4      	; 0x61a <pf_lseek+0x62>
     616:	35 01       	movw	r6, r10
     618:	46 01       	movw	r8, r12
			return FR_NOT_OPENED;

	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
	ifptr = fs->fptr;
     61a:	28 8d       	ldd	r18, Y+24	; 0x18
     61c:	39 8d       	ldd	r19, Y+25	; 0x19
     61e:	4a 8d       	ldd	r20, Y+26	; 0x1a
     620:	5b 8d       	ldd	r21, Y+27	; 0x1b
	fs->fptr = 0;
     622:	18 8e       	std	Y+24, r1	; 0x18
     624:	19 8e       	std	Y+25, r1	; 0x19
     626:	1a 8e       	std	Y+26, r1	; 0x1a
     628:	1b 8e       	std	Y+27, r1	; 0x1b
	if (ofs > 0) {
     62a:	61 14       	cp	r6, r1
     62c:	71 04       	cpc	r7, r1
     62e:	81 04       	cpc	r8, r1
     630:	91 04       	cpc	r9, r1
     632:	09 f4       	brne	.+2      	; 0x636 <pf_lseek+0x7e>
     634:	e8 c0       	rjmp	.+464    	; 0x806 <pf_lseek+0x24e>
		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
     636:	89 81       	ldd	r24, Y+1	; 0x01
     638:	a8 2e       	mov	r10, r24
     63a:	bb 24       	eor	r11, r11
     63c:	cc 24       	eor	r12, r12
     63e:	dd 24       	eor	r13, r13
     640:	99 e0       	ldi	r25, 0x09	; 9
     642:	aa 0c       	add	r10, r10
     644:	bb 1c       	adc	r11, r11
     646:	cc 1c       	adc	r12, r12
     648:	dd 1c       	adc	r13, r13
     64a:	9a 95       	dec	r25
     64c:	d1 f7       	brne	.-12     	; 0x642 <pf_lseek+0x8a>
		if (ifptr > 0 &&
     64e:	21 15       	cp	r18, r1
     650:	31 05       	cpc	r19, r1
     652:	41 05       	cpc	r20, r1
     654:	51 05       	cpc	r21, r1
     656:	b1 f1       	breq	.+108    	; 0x6c4 <pf_lseek+0x10c>
     658:	19 01       	movw	r2, r18
     65a:	2a 01       	movw	r4, r20
     65c:	08 94       	sec
     65e:	21 08       	sbc	r2, r1
     660:	31 08       	sbc	r3, r1
     662:	41 08       	sbc	r4, r1
     664:	51 08       	sbc	r5, r1
     666:	c4 01       	movw	r24, r8
     668:	b3 01       	movw	r22, r6
     66a:	61 50       	subi	r22, 0x01	; 1
     66c:	70 40       	sbci	r23, 0x00	; 0
     66e:	80 40       	sbci	r24, 0x00	; 0
     670:	90 40       	sbci	r25, 0x00	; 0
     672:	a6 01       	movw	r20, r12
     674:	95 01       	movw	r18, r10
     676:	0e 94 98 19 	call	0x3330	; 0x3330 <__udivmodsi4>
     67a:	79 01       	movw	r14, r18
     67c:	8a 01       	movw	r16, r20
     67e:	c2 01       	movw	r24, r4
     680:	b1 01       	movw	r22, r2
     682:	a6 01       	movw	r20, r12
     684:	95 01       	movw	r18, r10
     686:	0e 94 98 19 	call	0x3330	; 0x3330 <__udivmodsi4>
     68a:	e2 16       	cp	r14, r18
     68c:	f3 06       	cpc	r15, r19
     68e:	04 07       	cpc	r16, r20
     690:	15 07       	cpc	r17, r21
     692:	c0 f0       	brcs	.+48     	; 0x6c4 <pf_lseek+0x10c>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
     694:	88 27       	eor	r24, r24
     696:	99 27       	eor	r25, r25
     698:	dc 01       	movw	r26, r24
     69a:	8a 19       	sub	r24, r10
     69c:	9b 09       	sbc	r25, r11
     69e:	ac 09       	sbc	r26, r12
     6a0:	bd 09       	sbc	r27, r13
     6a2:	82 21       	and	r24, r2
     6a4:	93 21       	and	r25, r3
     6a6:	a4 21       	and	r26, r4
     6a8:	b5 21       	and	r27, r5
     6aa:	88 8f       	std	Y+24, r24	; 0x18
     6ac:	99 8f       	std	Y+25, r25	; 0x19
     6ae:	aa 8f       	std	Y+26, r26	; 0x1a
     6b0:	bb 8f       	std	Y+27, r27	; 0x1b
			ofs -= fs->fptr;
     6b2:	68 1a       	sub	r6, r24
     6b4:	79 0a       	sbc	r7, r25
     6b6:	8a 0a       	sbc	r8, r26
     6b8:	9b 0a       	sbc	r9, r27
			clst = fs->curr_clust;
     6ba:	2c a1       	ldd	r18, Y+36	; 0x24
     6bc:	3d a1       	ldd	r19, Y+37	; 0x25
     6be:	4e a1       	ldd	r20, Y+38	; 0x26
     6c0:	5f a1       	ldd	r21, Y+39	; 0x27
     6c2:	33 c0       	rjmp	.+102    	; 0x72a <pf_lseek+0x172>
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
     6c4:	28 a1       	ldd	r18, Y+32	; 0x20
     6c6:	39 a1       	ldd	r19, Y+33	; 0x21
     6c8:	4a a1       	ldd	r20, Y+34	; 0x22
     6ca:	5b a1       	ldd	r21, Y+35	; 0x23
			fs->curr_clust = clst;
     6cc:	2c a3       	std	Y+36, r18	; 0x24
     6ce:	3d a3       	std	Y+37, r19	; 0x25
     6d0:	4e a3       	std	Y+38, r20	; 0x26
     6d2:	5f a3       	std	Y+39, r21	; 0x27
     6d4:	2a c0       	rjmp	.+84     	; 0x72a <pf_lseek+0x172>
		}
		while (ofs > bcs) {				/* Cluster following loop */
			clst = get_fat(clst);		/* Follow cluster chain */
     6d6:	ca 01       	movw	r24, r20
     6d8:	b9 01       	movw	r22, r18
     6da:	0e 94 3c 01 	call	0x278	; 0x278 <get_fat>
     6de:	9b 01       	movw	r18, r22
     6e0:	ac 01       	movw	r20, r24
			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
     6e2:	62 30       	cpi	r22, 0x02	; 2
     6e4:	71 05       	cpc	r23, r1
     6e6:	81 05       	cpc	r24, r1
     6e8:	91 05       	cpc	r25, r1
     6ea:	08 f4       	brcc	.+2      	; 0x6ee <pf_lseek+0x136>
     6ec:	89 c0       	rjmp	.+274    	; 0x800 <pf_lseek+0x248>
     6ee:	88 85       	ldd	r24, Y+8	; 0x08
     6f0:	99 85       	ldd	r25, Y+9	; 0x09
     6f2:	aa 85       	ldd	r26, Y+10	; 0x0a
     6f4:	bb 85       	ldd	r27, Y+11	; 0x0b
     6f6:	28 17       	cp	r18, r24
     6f8:	39 07       	cpc	r19, r25
     6fa:	4a 07       	cpc	r20, r26
     6fc:	5b 07       	cpc	r21, r27
     6fe:	08 f0       	brcs	.+2      	; 0x702 <pf_lseek+0x14a>
     700:	7f c0       	rjmp	.+254    	; 0x800 <pf_lseek+0x248>
			fs->curr_clust = clst;
     702:	2c a3       	std	Y+36, r18	; 0x24
     704:	3d a3       	std	Y+37, r19	; 0x25
     706:	4e a3       	std	Y+38, r20	; 0x26
     708:	5f a3       	std	Y+39, r21	; 0x27
			fs->fptr += bcs;
     70a:	88 8d       	ldd	r24, Y+24	; 0x18
     70c:	99 8d       	ldd	r25, Y+25	; 0x19
     70e:	aa 8d       	ldd	r26, Y+26	; 0x1a
     710:	bb 8d       	ldd	r27, Y+27	; 0x1b
     712:	8a 0d       	add	r24, r10
     714:	9b 1d       	adc	r25, r11
     716:	ac 1d       	adc	r26, r12
     718:	bd 1d       	adc	r27, r13
     71a:	88 8f       	std	Y+24, r24	; 0x18
     71c:	99 8f       	std	Y+25, r25	; 0x19
     71e:	aa 8f       	std	Y+26, r26	; 0x1a
     720:	bb 8f       	std	Y+27, r27	; 0x1b
			ofs -= bcs;
     722:	6a 18       	sub	r6, r10
     724:	7b 08       	sbc	r7, r11
     726:	8c 08       	sbc	r8, r12
     728:	9d 08       	sbc	r9, r13
			clst = fs->curr_clust;
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {				/* Cluster following loop */
     72a:	a6 14       	cp	r10, r6
     72c:	b7 04       	cpc	r11, r7
     72e:	c8 04       	cpc	r12, r8
     730:	d9 04       	cpc	r13, r9
     732:	88 f2       	brcs	.-94     	; 0x6d6 <pf_lseek+0x11e>
			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
     734:	88 8d       	ldd	r24, Y+24	; 0x18
     736:	99 8d       	ldd	r25, Y+25	; 0x19
     738:	aa 8d       	ldd	r26, Y+26	; 0x1a
     73a:	bb 8d       	ldd	r27, Y+27	; 0x1b
     73c:	86 0d       	add	r24, r6
     73e:	97 1d       	adc	r25, r7
     740:	a8 1d       	adc	r26, r8
     742:	b9 1d       	adc	r27, r9
     744:	88 8f       	std	Y+24, r24	; 0x18
     746:	99 8f       	std	Y+25, r25	; 0x19
     748:	aa 8f       	std	Y+26, r26	; 0x1a
     74a:	bb 8f       	std	Y+27, r27	; 0x1b
static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
	FATFS *fs = FatFs;
     74c:	00 91 c3 02 	lds	r16, 0x02C3
     750:	10 91 c4 02 	lds	r17, 0x02C4


	clst -= 2;
     754:	8e ef       	ldi	r24, 0xFE	; 254
     756:	a8 2e       	mov	r10, r24
     758:	8f ef       	ldi	r24, 0xFF	; 255
     75a:	b8 2e       	mov	r11, r24
     75c:	8f ef       	ldi	r24, 0xFF	; 255
     75e:	c8 2e       	mov	r12, r24
     760:	8f ef       	ldi	r24, 0xFF	; 255
     762:	d8 2e       	mov	r13, r24
     764:	a2 0e       	add	r10, r18
     766:	b3 1e       	adc	r11, r19
     768:	c4 1e       	adc	r12, r20
     76a:	d5 1e       	adc	r13, r21
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     76c:	f8 01       	movw	r30, r16
     76e:	80 85       	ldd	r24, Z+8	; 0x08
     770:	91 85       	ldd	r25, Z+9	; 0x09
     772:	a2 85       	ldd	r26, Z+10	; 0x0a
     774:	b3 85       	ldd	r27, Z+11	; 0x0b
     776:	02 97       	sbiw	r24, 0x02	; 2
     778:	a1 09       	sbc	r26, r1
     77a:	b1 09       	sbc	r27, r1
     77c:	a8 16       	cp	r10, r24
     77e:	b9 06       	cpc	r11, r25
     780:	ca 06       	cpc	r12, r26
     782:	db 06       	cpc	r13, r27
     784:	e8 f5       	brcc	.+122    	; 0x800 <pf_lseek+0x248>
	return (DWORD)clst * fs->csize + fs->database;
     786:	21 81       	ldd	r18, Z+1	; 0x01
     788:	30 e0       	ldi	r19, 0x00	; 0
     78a:	40 e0       	ldi	r20, 0x00	; 0
     78c:	50 e0       	ldi	r21, 0x00	; 0
     78e:	c6 01       	movw	r24, r12
     790:	b5 01       	movw	r22, r10
     792:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__mulsi3>
     796:	9b 01       	movw	r18, r22
     798:	ac 01       	movw	r20, r24
     79a:	f8 01       	movw	r30, r16
     79c:	84 89       	ldd	r24, Z+20	; 0x14
     79e:	95 89       	ldd	r25, Z+21	; 0x15
     7a0:	a6 89       	ldd	r26, Z+22	; 0x16
     7a2:	b7 89       	ldd	r27, Z+23	; 0x17
     7a4:	28 0f       	add	r18, r24
     7a6:	39 1f       	adc	r19, r25
     7a8:	4a 1f       	adc	r20, r26
     7aa:	5b 1f       	adc	r21, r27
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
		sect = clust2sect(clst);		/* Current sector */
		if (!sect) goto fe_abort;
     7ac:	21 15       	cp	r18, r1
     7ae:	31 05       	cpc	r19, r1
     7b0:	41 05       	cpc	r20, r1
     7b2:	51 05       	cpc	r21, r1
     7b4:	29 f1       	breq	.+74     	; 0x800 <pf_lseek+0x248>
		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
     7b6:	d4 01       	movw	r26, r8
     7b8:	c3 01       	movw	r24, r6
     7ba:	19 e0       	ldi	r17, 0x09	; 9
     7bc:	b6 95       	lsr	r27
     7be:	a7 95       	ror	r26
     7c0:	97 95       	ror	r25
     7c2:	87 95       	ror	r24
     7c4:	1a 95       	dec	r17
     7c6:	d1 f7       	brne	.-12     	; 0x7bc <pf_lseek+0x204>
     7c8:	98 2f       	mov	r25, r24
     7ca:	8b 83       	std	Y+3, r24	; 0x03
		if (ofs % 512)
     7cc:	ff ef       	ldi	r31, 0xFF	; 255
     7ce:	ef 2e       	mov	r14, r31
     7d0:	f1 e0       	ldi	r31, 0x01	; 1
     7d2:	ff 2e       	mov	r15, r31
     7d4:	01 2d       	mov	r16, r1
     7d6:	11 2d       	mov	r17, r1
     7d8:	6e 20       	and	r6, r14
     7da:	7f 20       	and	r7, r15
     7dc:	80 22       	and	r8, r16
     7de:	91 22       	and	r9, r17
     7e0:	61 14       	cp	r6, r1
     7e2:	71 04       	cpc	r7, r1
     7e4:	81 04       	cpc	r8, r1
     7e6:	91 04       	cpc	r9, r1
     7e8:	71 f0       	breq	.+28     	; 0x806 <pf_lseek+0x24e>
			fs->dsect = sect + fs->csect++;
     7ea:	28 0f       	add	r18, r24
     7ec:	31 1d       	adc	r19, r1
     7ee:	41 1d       	adc	r20, r1
     7f0:	51 1d       	adc	r21, r1
     7f2:	28 a7       	std	Y+40, r18	; 0x28
     7f4:	39 a7       	std	Y+41, r19	; 0x29
     7f6:	4a a7       	std	Y+42, r20	; 0x2a
     7f8:	5b a7       	std	Y+43, r21	; 0x2b
     7fa:	9f 5f       	subi	r25, 0xFF	; 255
     7fc:	9b 83       	std	Y+3, r25	; 0x03
     7fe:	03 c0       	rjmp	.+6      	; 0x806 <pf_lseek+0x24e>
	}

	return FR_OK;

fe_abort:
	fs->flag = 0;
     800:	1a 82       	std	Y+2, r1	; 0x02
     802:	81 e0       	ldi	r24, 0x01	; 1
     804:	01 c0       	rjmp	.+2      	; 0x808 <pf_lseek+0x250>
	return FR_DISK_ERR;
     806:	80 e0       	ldi	r24, 0x00	; 0
}
     808:	df 91       	pop	r29
     80a:	cf 91       	pop	r28
     80c:	1f 91       	pop	r17
     80e:	0f 91       	pop	r16
     810:	ff 90       	pop	r15
     812:	ef 90       	pop	r14
     814:	df 90       	pop	r13
     816:	cf 90       	pop	r12
     818:	bf 90       	pop	r11
     81a:	af 90       	pop	r10
     81c:	9f 90       	pop	r9
     81e:	8f 90       	pop	r8
     820:	7f 90       	pop	r7
     822:	6f 90       	pop	r6
     824:	5f 90       	pop	r5
     826:	4f 90       	pop	r4
     828:	3f 90       	pop	r3
     82a:	2f 90       	pop	r2
     82c:	08 95       	ret

0000082e <pf_readdir>:

FRESULT pf_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
     82e:	af 92       	push	r10
     830:	bf 92       	push	r11
     832:	cf 92       	push	r12
     834:	df 92       	push	r13
     836:	ef 92       	push	r14
     838:	ff 92       	push	r15
     83a:	0f 93       	push	r16
     83c:	1f 93       	push	r17
     83e:	df 93       	push	r29
     840:	cf 93       	push	r28
     842:	cd b7       	in	r28, 0x3d	; 61
     844:	de b7       	in	r29, 0x3e	; 62
     846:	ac 97       	sbiw	r28, 0x2c	; 44
     848:	0f b6       	in	r0, 0x3f	; 63
     84a:	f8 94       	cli
     84c:	de bf       	out	0x3e, r29	; 62
     84e:	0f be       	out	0x3f, r0	; 63
     850:	cd bf       	out	0x3d, r28	; 61
     852:	7c 01       	movw	r14, r24
     854:	5b 01       	movw	r10, r22
	FRESULT res;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
     856:	e0 91 c3 02 	lds	r30, 0x02C3
     85a:	f0 91 c4 02 	lds	r31, 0x02C4


	if (!fs) {				/* Check file system */
     85e:	30 97       	sbiw	r30, 0x00	; 0
     860:	11 f4       	brne	.+4      	; 0x866 <pf_readdir+0x38>
     862:	86 e0       	ldi	r24, 0x06	; 6
     864:	c6 c0       	rjmp	.+396    	; 0x9f2 <__stack+0xf3>
		res = FR_NOT_ENABLED;
	} else {
		fs->buf = dir;
     866:	ce 01       	movw	r24, r28
     868:	0d 96       	adiw	r24, 0x0d	; 13
     86a:	97 83       	std	Z+7, r25	; 0x07
     86c:	86 83       	std	Z+6, r24	; 0x06
		dj->fn = sp;
     86e:	ce 01       	movw	r24, r28
     870:	01 96       	adiw	r24, 0x01	; 1
     872:	d7 01       	movw	r26, r14
     874:	13 96       	adiw	r26, 0x03	; 3
     876:	9c 93       	st	X, r25
     878:	8e 93       	st	-X, r24
     87a:	12 97       	sbiw	r26, 0x02	; 2
		if (!fno) {
     87c:	61 15       	cp	r22, r1
     87e:	71 05       	cpc	r23, r1
     880:	21 f4       	brne	.+8      	; 0x88a <pf_readdir+0x5c>
			res = dir_rewind(dj);
     882:	c7 01       	movw	r24, r14
     884:	0e 94 bd 00 	call	0x17a	; 0x17a <dir_rewind>
     888:	b4 c0       	rjmp	.+360    	; 0x9f2 <__stack+0xf3>
	FRESULT res;
	BYTE a, c, *dir;


	res = FR_NO_FILE;
	dir = FatFs->buf;
     88a:	c6 80       	ldd	r12, Z+6	; 0x06
     88c:	d7 80       	ldd	r13, Z+7	; 0x07
     88e:	83 e0       	ldi	r24, 0x03	; 3
     890:	26 c0       	rjmp	.+76     	; 0x8de <pf_readdir+0xb0>
	while (dj->sect) {
		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
     892:	f7 01       	movw	r30, r14
     894:	20 81       	ld	r18, Z
     896:	31 81       	ldd	r19, Z+1	; 0x01
     898:	2f 70       	andi	r18, 0x0F	; 15
     89a:	30 70       	andi	r19, 0x00	; 0
     89c:	e5 e0       	ldi	r30, 0x05	; 5
     89e:	22 0f       	add	r18, r18
     8a0:	33 1f       	adc	r19, r19
     8a2:	ea 95       	dec	r30
     8a4:	e1 f7       	brne	.-8      	; 0x89e <pf_readdir+0x70>
     8a6:	c6 01       	movw	r24, r12
     8a8:	00 e2       	ldi	r16, 0x20	; 32
     8aa:	10 e0       	ldi	r17, 0x00	; 0
     8ac:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
			? FR_DISK_ERR : FR_OK;
		if (res != FR_OK) break;
     8b0:	88 23       	and	r24, r24
     8b2:	11 f0       	breq	.+4      	; 0x8b8 <pf_readdir+0x8a>
     8b4:	81 e0       	ldi	r24, 0x01	; 1
     8b6:	1f c0       	rjmp	.+62     	; 0x8f6 <pf_readdir+0xc8>
		c = dir[DIR_Name];
     8b8:	d6 01       	movw	r26, r12
     8ba:	9c 91       	ld	r25, X
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
     8bc:	99 23       	and	r25, r25
     8be:	09 f4       	brne	.+2      	; 0x8c2 <pf_readdir+0x94>
     8c0:	a9 c0       	rjmp	.+338    	; 0xa14 <__stack+0x115>
		a = dir[DIR_Attr] & AM_MASK;
     8c2:	1b 96       	adiw	r26, 0x0b	; 11
     8c4:	8c 91       	ld	r24, X
		if (c != 0xE5 && c != '.' && !(a & AM_VOL))	/* Is it a valid entry? */
     8c6:	95 3e       	cpi	r25, 0xE5	; 229
     8c8:	29 f0       	breq	.+10     	; 0x8d4 <pf_readdir+0xa6>
     8ca:	9e 32       	cpi	r25, 0x2E	; 46
     8cc:	19 f0       	breq	.+6      	; 0x8d4 <pf_readdir+0xa6>
     8ce:	8f 73       	andi	r24, 0x3F	; 63
     8d0:	83 ff       	sbrs	r24, 3
     8d2:	1d c0       	rjmp	.+58     	; 0x90e <__stack+0xf>
			break;
		res = dir_next(dj);				/* Next entry */
     8d4:	c7 01       	movw	r24, r14
     8d6:	0e 94 28 02 	call	0x450	; 0x450 <dir_next>
		if (res != FR_OK) break;
     8da:	88 23       	and	r24, r24
     8dc:	61 f4       	brne	.+24     	; 0x8f6 <pf_readdir+0xc8>
	BYTE a, c, *dir;


	res = FR_NO_FILE;
	dir = FatFs->buf;
	while (dj->sect) {
     8de:	f7 01       	movw	r30, r14
     8e0:	44 85       	ldd	r20, Z+12	; 0x0c
     8e2:	55 85       	ldd	r21, Z+13	; 0x0d
     8e4:	66 85       	ldd	r22, Z+14	; 0x0e
     8e6:	77 85       	ldd	r23, Z+15	; 0x0f
     8e8:	41 15       	cp	r20, r1
     8ea:	51 05       	cpc	r21, r1
     8ec:	61 05       	cpc	r22, r1
     8ee:	71 05       	cpc	r23, r1
     8f0:	81 f6       	brne	.-96     	; 0x892 <pf_readdir+0x64>
			break;
		res = dir_next(dj);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
     8f2:	88 23       	and	r24, r24
     8f4:	61 f0       	breq	.+24     	; 0x90e <__stack+0xf>
     8f6:	d7 01       	movw	r26, r14
     8f8:	1c 96       	adiw	r26, 0x0c	; 12
     8fa:	1d 92       	st	X+, r1
     8fc:	1d 92       	st	X+, r1
     8fe:	1d 92       	st	X+, r1
     900:	1c 92       	st	X, r1
     902:	1f 97       	sbiw	r26, 0x0f	; 15
		dj->fn = sp;
		if (!fno) {
			res = dir_rewind(dj);
		} else {
			res = dir_read(dj);
			if (res == FR_NO_FILE) {
     904:	83 30       	cpi	r24, 0x03	; 3
     906:	19 f0       	breq	.+6      	; 0x90e <__stack+0xf>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
     908:	88 23       	and	r24, r24
     90a:	09 f0       	breq	.+2      	; 0x90e <__stack+0xf>
     90c:	72 c0       	rjmp	.+228    	; 0x9f2 <__stack+0xf3>
{
	BYTE i, c, *dir;
	char *p;


	p = fno->fname;
     90e:	95 01       	movw	r18, r10
     910:	27 5f       	subi	r18, 0xF7	; 247
     912:	3f 4f       	sbci	r19, 0xFF	; 255
	if (dj->sect) {
     914:	f7 01       	movw	r30, r14
     916:	84 85       	ldd	r24, Z+12	; 0x0c
     918:	95 85       	ldd	r25, Z+13	; 0x0d
     91a:	a6 85       	ldd	r26, Z+14	; 0x0e
     91c:	b7 85       	ldd	r27, Z+15	; 0x0f
     91e:	00 97       	sbiw	r24, 0x00	; 0
     920:	a1 05       	cpc	r26, r1
     922:	b1 05       	cpc	r27, r1
     924:	09 f4       	brne	.+2      	; 0x928 <__stack+0x29>
     926:	56 c0       	rjmp	.+172    	; 0x9d4 <__stack+0xd5>
		dir = FatFs->buf;
     928:	e0 91 c3 02 	lds	r30, 0x02C3
     92c:	f0 91 c4 02 	lds	r31, 0x02C4
     930:	46 81       	ldd	r20, Z+6	; 0x06
     932:	57 81       	ldd	r21, Z+7	; 0x07
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	90 e0       	ldi	r25, 0x00	; 0
		for (i = 0; i < 8; i++) {	/* Copy file name body */
			c = dir[i];
     938:	fa 01       	movw	r30, r20
     93a:	e8 0f       	add	r30, r24
     93c:	f9 1f       	adc	r31, r25
     93e:	e0 81       	ld	r30, Z
			if (c == ' ') break;
     940:	e0 32       	cpi	r30, 0x20	; 32
     942:	51 f0       	breq	.+20     	; 0x958 <__stack+0x59>
			if (c == 0x05) c = 0xE5;
     944:	e5 30       	cpi	r30, 0x05	; 5
     946:	09 f4       	brne	.+2      	; 0x94a <__stack+0x4b>
     948:	e5 ee       	ldi	r30, 0xE5	; 229
			*p++ = c;
     94a:	d9 01       	movw	r26, r18
     94c:	ed 93       	st	X+, r30
     94e:	9d 01       	movw	r18, r26
     950:	01 96       	adiw	r24, 0x01	; 1


	p = fno->fname;
	if (dj->sect) {
		dir = FatFs->buf;
		for (i = 0; i < 8; i++) {	/* Copy file name body */
     952:	88 30       	cpi	r24, 0x08	; 8
     954:	91 05       	cpc	r25, r1
     956:	81 f7       	brne	.-32     	; 0x938 <__stack+0x39>
			c = dir[i];
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy file name extension */
     958:	fa 01       	movw	r30, r20
     95a:	80 85       	ldd	r24, Z+8	; 0x08
     95c:	80 32       	cpi	r24, 0x20	; 32
     95e:	11 f4       	brne	.+4      	; 0x964 <__stack+0x65>
     960:	f9 01       	movw	r30, r18
     962:	10 c0       	rjmp	.+32     	; 0x984 <__stack+0x85>
			*p++ = '.';
     964:	f9 01       	movw	r30, r18
     966:	8e e2       	ldi	r24, 0x2E	; 46
     968:	81 93       	st	Z+, r24
     96a:	da 01       	movw	r26, r20
			for (i = 8; i < 11; i++) {
     96c:	2c 5f       	subi	r18, 0xFC	; 252
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
				c = dir[i];
     970:	18 96       	adiw	r26, 0x08	; 8
     972:	8c 91       	ld	r24, X
     974:	18 97       	sbiw	r26, 0x08	; 8
				if (c == ' ') break;
     976:	80 32       	cpi	r24, 0x20	; 32
     978:	29 f0       	breq	.+10     	; 0x984 <__stack+0x85>
				*p++ = c;
     97a:	81 93       	st	Z+, r24
     97c:	11 96       	adiw	r26, 0x01	; 1
			if (c == 0x05) c = 0xE5;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy file name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
     97e:	e2 17       	cp	r30, r18
     980:	f3 07       	cpc	r31, r19
     982:	b1 f7       	brne	.-20     	; 0x970 <__stack+0x71>
				c = dir[i];
				if (c == ' ') break;
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
     984:	da 01       	movw	r26, r20
     986:	1b 96       	adiw	r26, 0x0b	; 11
     988:	8c 91       	ld	r24, X
     98a:	d5 01       	movw	r26, r10
     98c:	18 96       	adiw	r26, 0x08	; 8
     98e:	8c 93       	st	X, r24
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
     990:	da 01       	movw	r26, r20
     992:	5c 96       	adiw	r26, 0x1c	; 28
     994:	0d 91       	ld	r16, X+
     996:	1d 91       	ld	r17, X+
     998:	2d 91       	ld	r18, X+
     99a:	3c 91       	ld	r19, X
     99c:	5f 97       	sbiw	r26, 0x1f	; 31
     99e:	d5 01       	movw	r26, r10
     9a0:	0d 93       	st	X+, r16
     9a2:	1d 93       	st	X+, r17
     9a4:	2d 93       	st	X+, r18
     9a6:	3c 93       	st	X, r19
     9a8:	13 97       	sbiw	r26, 0x03	; 3
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
     9aa:	da 01       	movw	r26, r20
     9ac:	58 96       	adiw	r26, 0x18	; 24
     9ae:	8d 91       	ld	r24, X+
     9b0:	9c 91       	ld	r25, X
     9b2:	59 97       	sbiw	r26, 0x19	; 25
     9b4:	d5 01       	movw	r26, r10
     9b6:	15 96       	adiw	r26, 0x05	; 5
     9b8:	9c 93       	st	X, r25
     9ba:	8e 93       	st	-X, r24
     9bc:	14 97       	sbiw	r26, 0x04	; 4
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
     9be:	da 01       	movw	r26, r20
     9c0:	56 96       	adiw	r26, 0x16	; 22
     9c2:	8d 91       	ld	r24, X+
     9c4:	9c 91       	ld	r25, X
     9c6:	57 97       	sbiw	r26, 0x17	; 23
     9c8:	d5 01       	movw	r26, r10
     9ca:	17 96       	adiw	r26, 0x07	; 7
     9cc:	9c 93       	st	X, r25
     9ce:	8e 93       	st	-X, r24
     9d0:	16 97       	sbiw	r26, 0x06	; 6
     9d2:	9f 01       	movw	r18, r30
	}
	*p = 0;
     9d4:	f9 01       	movw	r30, r18
     9d6:	10 82       	st	Z, r1
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj);			/* Increment index for next */
     9d8:	c7 01       	movw	r24, r14
     9da:	0e 94 28 02 	call	0x450	; 0x450 <dir_next>
				if (res == FR_NO_FILE) {
     9de:	83 30       	cpi	r24, 0x03	; 3
     9e0:	41 f4       	brne	.+16     	; 0x9f2 <__stack+0xf3>
					dj->sect = 0;
     9e2:	d7 01       	movw	r26, r14
     9e4:	1c 96       	adiw	r26, 0x0c	; 12
     9e6:	1d 92       	st	X+, r1
     9e8:	1d 92       	st	X+, r1
     9ea:	1d 92       	st	X+, r1
     9ec:	1c 92       	st	X, r1
     9ee:	1f 97       	sbiw	r26, 0x0f	; 15
     9f0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
	}

	return res;
}
     9f2:	ac 96       	adiw	r28, 0x2c	; 44
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	de bf       	out	0x3e, r29	; 62
     9fa:	0f be       	out	0x3f, r0	; 63
     9fc:	cd bf       	out	0x3d, r28	; 61
     9fe:	cf 91       	pop	r28
     a00:	df 91       	pop	r29
     a02:	1f 91       	pop	r17
     a04:	0f 91       	pop	r16
     a06:	ff 90       	pop	r15
     a08:	ef 90       	pop	r14
     a0a:	df 90       	pop	r13
     a0c:	cf 90       	pop	r12
     a0e:	bf 90       	pop	r11
     a10:	af 90       	pop	r10
     a12:	08 95       	ret
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj);			/* Increment index for next */
				if (res == FR_NO_FILE) {
					dj->sect = 0;
     a14:	83 e0       	ldi	r24, 0x03	; 3
     a16:	6f cf       	rjmp	.-290    	; 0x8f6 <pf_readdir+0xc8>

00000a18 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const char *path	/* Full-path string to find a file or directory */
)
{
     a18:	8f 92       	push	r8
     a1a:	9f 92       	push	r9
     a1c:	af 92       	push	r10
     a1e:	bf 92       	push	r11
     a20:	cf 92       	push	r12
     a22:	df 92       	push	r13
     a24:	ef 92       	push	r14
     a26:	ff 92       	push	r15
     a28:	0f 93       	push	r16
     a2a:	1f 93       	push	r17
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	ec 01       	movw	r28, r24
     a32:	6b 01       	movw	r12, r22
     a34:	03 c0       	rjmp	.+6      	; 0xa3c <follow_path+0x24>
	FRESULT res;
	BYTE *dir;


	while (*path == ' ') path++;		/* Skip leading spaces */
     a36:	08 94       	sec
     a38:	c1 1c       	adc	r12, r1
     a3a:	d1 1c       	adc	r13, r1
     a3c:	f6 01       	movw	r30, r12
     a3e:	80 81       	ld	r24, Z
     a40:	80 32       	cpi	r24, 0x20	; 32
     a42:	c9 f3       	breq	.-14     	; 0xa36 <follow_path+0x1e>
	if (*path == '/') path++;			/* Strip heading separator */
     a44:	8f 32       	cpi	r24, 0x2F	; 47
     a46:	19 f4       	brne	.+6      	; 0xa4e <follow_path+0x36>
     a48:	08 94       	sec
     a4a:	c1 1c       	adc	r12, r1
     a4c:	d1 1c       	adc	r13, r1
	dj->sclust = 0;						/* Set start directory (always root dir) */
     a4e:	1c 82       	std	Y+4, r1	; 0x04
     a50:	1d 82       	std	Y+5, r1	; 0x05
     a52:	1e 82       	std	Y+6, r1	; 0x06
     a54:	1f 82       	std	Y+7, r1	; 0x07

	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
     a56:	f6 01       	movw	r30, r12
     a58:	80 81       	ld	r24, Z
     a5a:	81 32       	cpi	r24, 0x21	; 33
     a5c:	68 f4       	brcc	.+26     	; 0xa78 <follow_path+0x60>
		res = dir_rewind(dj);
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 bd 00 	call	0x17a	; 0x17a <dir_rewind>
     a64:	b8 2e       	mov	r11, r24
		FatFs->buf[0] = 0;
     a66:	e0 91 c3 02 	lds	r30, 0x02C3
     a6a:	f0 91 c4 02 	lds	r31, 0x02C4
     a6e:	06 80       	ldd	r0, Z+6	; 0x06
     a70:	f7 81       	ldd	r31, Z+7	; 0x07
     a72:	e0 2d       	mov	r30, r0
     a74:	10 82       	st	Z, r1
     a76:	c8 c0       	rjmp	.+400    	; 0xc08 <follow_path+0x1f0>

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
     a78:	80 e2       	ldi	r24, 0x20	; 32
     a7a:	88 2e       	mov	r8, r24
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
     a7c:	99 24       	eor	r9, r9
     a7e:	93 94       	inc	r9
{
	BYTE c, d, ni, si, i, *sfn;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
     a80:	4a 81       	ldd	r20, Y+2	; 0x02
     a82:	5b 81       	ldd	r21, Y+3	; 0x03
     a84:	fa 01       	movw	r30, r20
     a86:	8b e0       	ldi	r24, 0x0B	; 11
     a88:	90 e0       	ldi	r25, 0x00	; 0
     a8a:	01 c0       	rjmp	.+2      	; 0xa8e <follow_path+0x76>

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
     a8c:	81 92       	st	Z+, r8
     a8e:	01 97       	sbiw	r24, 0x01	; 1
     a90:	2f ef       	ldi	r18, 0xFF	; 255
     a92:	8f 3f       	cpi	r24, 0xFF	; 255
     a94:	92 07       	cpc	r25, r18
     a96:	d1 f7       	brne	.-12     	; 0xa8c <follow_path+0x74>
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	aa 24       	eor	r10, r10
     a9c:	68 e0       	ldi	r22, 0x08	; 8
     a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <follow_path+0x8c>
     aa0:	38 e0       	ldi	r19, 0x08	; 8
     aa2:	6b e0       	ldi	r22, 0x0B	; 11
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
     aa4:	f6 01       	movw	r30, r12
     aa6:	ea 0d       	add	r30, r10
     aa8:	f1 1d       	adc	r31, r1
     aaa:	20 81       	ld	r18, Z
     aac:	a3 94       	inc	r10
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
     aae:	21 32       	cpi	r18, 0x21	; 33
     ab0:	a8 f1       	brcs	.+106    	; 0xb1c <follow_path+0x104>
     ab2:	2f 32       	cpi	r18, 0x2F	; 47
     ab4:	99 f1       	breq	.+102    	; 0xb1c <follow_path+0x104>
		if (c == '.' || i >= ni) {
     ab6:	2e 32       	cpi	r18, 0x2E	; 46
     ab8:	11 f0       	breq	.+4      	; 0xabe <follow_path+0xa6>
     aba:	36 17       	cp	r19, r22
     abc:	28 f0       	brcs	.+10     	; 0xac8 <follow_path+0xb0>
			if (ni != 8 || c != '.') break;
     abe:	68 30       	cpi	r22, 0x08	; 8
     ac0:	69 f5       	brne	.+90     	; 0xb1c <follow_path+0x104>
     ac2:	2e 32       	cpi	r18, 0x2E	; 46
     ac4:	69 f3       	breq	.-38     	; 0xaa0 <follow_path+0x88>
     ac6:	2a c0       	rjmp	.+84     	; 0xb1c <follow_path+0x104>
		}
#ifdef _EXCVT
		if (c >= 0x80)					/* To upper extended char (SBCS) */
			c = cvt[c - 0x80];
#endif
		if (IsDBCS1(c) && i < ni - 1) {	/* DBC 1st byte? */
     ac8:	82 2f       	mov	r24, r18
     aca:	81 58       	subi	r24, 0x81	; 129
     acc:	8f 31       	cpi	r24, 0x1F	; 31
     ace:	18 f0       	brcs	.+6      	; 0xad6 <follow_path+0xbe>
     ad0:	8f 55       	subi	r24, 0x5F	; 95
     ad2:	8d 31       	cpi	r24, 0x1D	; 29
     ad4:	c0 f4       	brcc	.+48     	; 0xb06 <follow_path+0xee>
     ad6:	a3 2f       	mov	r26, r19
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	86 2f       	mov	r24, r22
     adc:	90 e0       	ldi	r25, 0x00	; 0
     ade:	01 97       	sbiw	r24, 0x01	; 1
     ae0:	a8 17       	cp	r26, r24
     ae2:	b9 07       	cpc	r27, r25
     ae4:	84 f4       	brge	.+32     	; 0xb06 <follow_path+0xee>
			d = p[si++];					/* Get 2nd byte */
     ae6:	f6 01       	movw	r30, r12
     ae8:	ea 0d       	add	r30, r10
     aea:	f1 1d       	adc	r31, r1
     aec:	90 81       	ld	r25, Z
     aee:	a3 94       	inc	r10
			sfn[i++] = c;
     af0:	a4 0f       	add	r26, r20
     af2:	b5 1f       	adc	r27, r21
     af4:	2c 93       	st	X, r18
     af6:	83 2f       	mov	r24, r19
     af8:	8f 5f       	subi	r24, 0xFF	; 255
			sfn[i++] = d;
     afa:	fa 01       	movw	r30, r20
     afc:	e8 0f       	add	r30, r24
     afe:	f1 1d       	adc	r31, r1
     b00:	90 83       	st	Z, r25
     b02:	3e 5f       	subi	r19, 0xFE	; 254
     b04:	cf cf       	rjmp	.-98     	; 0xaa4 <follow_path+0x8c>
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
     b06:	82 2f       	mov	r24, r18
     b08:	81 56       	subi	r24, 0x61	; 97
     b0a:	8a 31       	cpi	r24, 0x1A	; 26
     b0c:	08 f4       	brcc	.+2      	; 0xb10 <follow_path+0xf8>
     b0e:	20 52       	subi	r18, 0x20	; 32
			sfn[i++] = c;
     b10:	fa 01       	movw	r30, r20
     b12:	e3 0f       	add	r30, r19
     b14:	f1 1d       	adc	r31, r1
     b16:	20 83       	st	Z, r18
     b18:	3f 5f       	subi	r19, 0xFF	; 255
     b1a:	c4 cf       	rjmp	.-120    	; 0xaa4 <follow_path+0x8c>
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
     b1c:	fa 01       	movw	r30, r20
     b1e:	13 86       	std	Z+11, r1	; 0x0b
     b20:	21 32       	cpi	r18, 0x21	; 33
     b22:	08 f4       	brcc	.+2      	; 0xb26 <follow_path+0x10e>
     b24:	93 86       	std	Z+11, r9	; 0x0b
{
	FRESULT res;
	BYTE c, *dir;


	res = dir_rewind(dj);			/* Rewind directory object */
     b26:	ce 01       	movw	r24, r28
     b28:	0e 94 bd 00 	call	0x17a	; 0x17a <dir_rewind>
     b2c:	b8 2e       	mov	r11, r24
	if (res != FR_OK) return res;
     b2e:	88 23       	and	r24, r24
     b30:	09 f0       	breq	.+2      	; 0xb34 <follow_path+0x11c>
     b32:	3f c0       	rjmp	.+126    	; 0xbb2 <follow_path+0x19a>

	dir = FatFs->buf;
     b34:	e0 91 c3 02 	lds	r30, 0x02C3
     b38:	f0 91 c4 02 	lds	r31, 0x02C4
     b3c:	e6 80       	ldd	r14, Z+6	; 0x06
     b3e:	f7 80       	ldd	r15, Z+7	; 0x07
	do {
		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
     b40:	4c 85       	ldd	r20, Y+12	; 0x0c
     b42:	5d 85       	ldd	r21, Y+13	; 0x0d
     b44:	6e 85       	ldd	r22, Y+14	; 0x0e
     b46:	7f 85       	ldd	r23, Y+15	; 0x0f
     b48:	28 81       	ld	r18, Y
     b4a:	39 81       	ldd	r19, Y+1	; 0x01
     b4c:	2f 70       	andi	r18, 0x0F	; 15
     b4e:	30 70       	andi	r19, 0x00	; 0
     b50:	05 e0       	ldi	r16, 0x05	; 5
     b52:	22 0f       	add	r18, r18
     b54:	33 1f       	adc	r19, r19
     b56:	0a 95       	dec	r16
     b58:	e1 f7       	brne	.-8      	; 0xb52 <follow_path+0x13a>
     b5a:	c7 01       	movw	r24, r14
     b5c:	00 e2       	ldi	r16, 0x20	; 32
     b5e:	10 e0       	ldi	r17, 0x00	; 0
     b60:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
			? FR_DISK_ERR : FR_OK;
		if (res != FR_OK) break;
     b64:	88 23       	and	r24, r24
     b66:	11 f0       	breq	.+4      	; 0xb6c <follow_path+0x154>
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	22 c0       	rjmp	.+68     	; 0xbb0 <follow_path+0x198>
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
     b6c:	f7 01       	movw	r30, r14
     b6e:	80 81       	ld	r24, Z
     b70:	88 23       	and	r24, r24
     b72:	09 f4       	brne	.+2      	; 0xb76 <follow_path+0x15e>
     b74:	57 c0       	rjmp	.+174    	; 0xc24 <follow_path+0x20c>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
     b76:	83 85       	ldd	r24, Z+11	; 0x0b
     b78:	83 fd       	sbrc	r24, 3
     b7a:	15 c0       	rjmp	.+42     	; 0xba6 <follow_path+0x18e>
     b7c:	d7 01       	movw	r26, r14
     b7e:	8a 81       	ldd	r24, Y+2	; 0x02
     b80:	9b 81       	ldd	r25, Y+3	; 0x03
     b82:	9c 01       	movw	r18, r24
     b84:	f9 01       	movw	r30, r18
     b86:	2b e0       	ldi	r18, 0x0B	; 11
     b88:	30 e0       	ldi	r19, 0x00	; 0
/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
     b8a:	21 50       	subi	r18, 0x01	; 1
     b8c:	30 40       	sbci	r19, 0x00	; 0
     b8e:	8f ef       	ldi	r24, 0xFF	; 255
     b90:	2f 3f       	cpi	r18, 0xFF	; 255
     b92:	38 07       	cpc	r19, r24
     b94:	09 f4       	brne	.+2      	; 0xb98 <follow_path+0x180>
     b96:	49 c0       	rjmp	.+146    	; 0xc2a <follow_path+0x212>
     b98:	9c 91       	ld	r25, X
     b9a:	80 81       	ld	r24, Z
     b9c:	98 17       	cp	r25, r24
     b9e:	19 f4       	brne	.+6      	; 0xba6 <follow_path+0x18e>
     ba0:	11 96       	adiw	r26, 0x01	; 1
     ba2:	31 96       	adiw	r30, 0x01	; 1
     ba4:	f2 cf       	rjmp	.-28     	; 0xb8a <follow_path+0x172>
		if (res != FR_OK) break;
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
		res = dir_next(dj);							/* Next entry */
     ba6:	ce 01       	movw	r24, r28
     ba8:	0e 94 28 02 	call	0x450	; 0x450 <dir_next>
	} while (res == FR_OK);
     bac:	88 23       	and	r24, r24
     bae:	41 f2       	breq	.-112    	; 0xb40 <follow_path+0x128>
     bb0:	b8 2e       	mov	r11, r24
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
     bb2:	e3 e0       	ldi	r30, 0x03	; 3
     bb4:	be 16       	cp	r11, r30
     bb6:	41 f5       	brne	.+80     	; 0xc08 <follow_path+0x1f0>
     bb8:	ea 81       	ldd	r30, Y+2	; 0x02
     bba:	fb 81       	ldd	r31, Y+3	; 0x03
     bbc:	83 85       	ldd	r24, Z+11	; 0x0b
     bbe:	88 23       	and	r24, r24
     bc0:	09 f1       	breq	.+66     	; 0xc04 <follow_path+0x1ec>
     bc2:	22 c0       	rjmp	.+68     	; 0xc08 <follow_path+0x1f0>
					res = FR_NO_PATH;
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
     bc4:	e0 91 c3 02 	lds	r30, 0x02C3
     bc8:	f0 91 c4 02 	lds	r31, 0x02C4
     bcc:	06 80       	ldd	r0, Z+6	; 0x06
     bce:	f7 81       	ldd	r31, Z+7	; 0x07
     bd0:	e0 2d       	mov	r30, r0
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
     bd2:	83 85       	ldd	r24, Z+11	; 0x0b
     bd4:	84 ff       	sbrs	r24, 4
     bd6:	16 c0       	rjmp	.+44     	; 0xc04 <follow_path+0x1ec>
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */
     bd8:	ca 0c       	add	r12, r10
     bda:	d1 1c       	adc	r13, r1
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust =
     bdc:	84 89       	ldd	r24, Z+20	; 0x14
     bde:	95 89       	ldd	r25, Z+21	; 0x15
     be0:	a0 e0       	ldi	r26, 0x00	; 0
     be2:	b0 e0       	ldi	r27, 0x00	; 0
     be4:	dc 01       	movw	r26, r24
     be6:	99 27       	eor	r25, r25
     be8:	88 27       	eor	r24, r24
     bea:	22 8d       	ldd	r18, Z+26	; 0x1a
     bec:	33 8d       	ldd	r19, Z+27	; 0x1b
     bee:	40 e0       	ldi	r20, 0x00	; 0
     bf0:	50 e0       	ldi	r21, 0x00	; 0
     bf2:	82 2b       	or	r24, r18
     bf4:	93 2b       	or	r25, r19
     bf6:	a4 2b       	or	r26, r20
     bf8:	b5 2b       	or	r27, r21
     bfa:	8c 83       	std	Y+4, r24	; 0x04
     bfc:	9d 83       	std	Y+5, r25	; 0x05
     bfe:	ae 83       	std	Y+6, r26	; 0x06
     c00:	bf 83       	std	Y+7, r27	; 0x07
     c02:	3e cf       	rjmp	.-388    	; 0xa80 <follow_path+0x68>
#if _FS_FAT32
				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | 
#endif
				LD_WORD(dir+DIR_FstClusLO);
		}
     c04:	a4 e0       	ldi	r26, 0x04	; 4
     c06:	ba 2e       	mov	r11, r26
	}

	return res;
}
     c08:	8b 2d       	mov	r24, r11
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	ff 90       	pop	r15
     c14:	ef 90       	pop	r14
     c16:	df 90       	pop	r13
     c18:	cf 90       	pop	r12
     c1a:	bf 90       	pop	r11
     c1c:	af 90       	pop	r10
     c1e:	9f 90       	pop	r9
     c20:	8f 90       	pop	r8
     c22:	08 95       	ret
			dj->sclust =
#if _FS_FAT32
				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | 
#endif
				LD_WORD(dir+DIR_FstClusLO);
		}
     c24:	f3 e0       	ldi	r31, 0x03	; 3
     c26:	bf 2e       	mov	r11, r31
     c28:	c7 cf       	rjmp	.-114    	; 0xbb8 <follow_path+0x1a0>
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
					res = FR_NO_PATH;
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
     c2a:	ea 81       	ldd	r30, Y+2	; 0x02
     c2c:	fb 81       	ldd	r31, Y+3	; 0x03
     c2e:	83 85       	ldd	r24, Z+11	; 0x0b
     c30:	88 23       	and	r24, r24
     c32:	41 f2       	breq	.-112    	; 0xbc4 <follow_path+0x1ac>
     c34:	e9 cf       	rjmp	.-46     	; 0xc08 <follow_path+0x1f0>

00000c36 <pf_opendir>:

FRESULT pf_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const char *path	/* Pointer to the directory path */
)
{
     c36:	ef 92       	push	r14
     c38:	ff 92       	push	r15
     c3a:	0f 93       	push	r16
     c3c:	1f 93       	push	r17
     c3e:	df 93       	push	r29
     c40:	cf 93       	push	r28
     c42:	cd b7       	in	r28, 0x3d	; 61
     c44:	de b7       	in	r29, 0x3e	; 62
     c46:	ac 97       	sbiw	r28, 0x2c	; 44
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	de bf       	out	0x3e, r29	; 62
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	cd bf       	out	0x3d, r28	; 61
     c52:	8c 01       	movw	r16, r24
	FRESULT res;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
     c54:	e0 91 c3 02 	lds	r30, 0x02C3
     c58:	f0 91 c4 02 	lds	r31, 0x02C4


	if (!fs) {				/* Check file system */
     c5c:	30 97       	sbiw	r30, 0x00	; 0
     c5e:	11 f4       	brne	.+4      	; 0xc64 <pf_opendir+0x2e>
     c60:	86 e0       	ldi	r24, 0x06	; 6
     c62:	32 c0       	rjmp	.+100    	; 0xcc8 <pf_opendir+0x92>
		res = FR_NOT_ENABLED;
	} else {
		fs->buf = dir;
     c64:	3d e0       	ldi	r19, 0x0D	; 13
     c66:	e3 2e       	mov	r14, r19
     c68:	f1 2c       	mov	r15, r1
     c6a:	ec 0e       	add	r14, r28
     c6c:	fd 1e       	adc	r15, r29
     c6e:	f7 82       	std	Z+7, r15	; 0x07
     c70:	e6 82       	std	Z+6, r14	; 0x06
		dj->fn = sp;
     c72:	ce 01       	movw	r24, r28
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	f8 01       	movw	r30, r16
     c78:	93 83       	std	Z+3, r25	; 0x03
     c7a:	82 83       	std	Z+2, r24	; 0x02
		res = follow_path(dj, path);			/* Follow the path to the directory */
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 0c 05 	call	0xa18	; 0xa18 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
     c82:	88 23       	and	r24, r24
     c84:	f1 f4       	brne	.+60     	; 0xcc2 <pf_opendir+0x8c>
			if (dir[0]) {						/* It is not the root dir */
     c86:	8d 85       	ldd	r24, Y+13	; 0x0d
     c88:	88 23       	and	r24, r24
     c8a:	c1 f0       	breq	.+48     	; 0xcbc <pf_opendir+0x86>
				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
     c8c:	88 8d       	ldd	r24, Y+24	; 0x18
     c8e:	84 ff       	sbrs	r24, 4
     c90:	1a c0       	rjmp	.+52     	; 0xcc6 <pf_opendir+0x90>
					dj->sclust =
     c92:	f7 01       	movw	r30, r14
     c94:	84 89       	ldd	r24, Z+20	; 0x14
     c96:	95 89       	ldd	r25, Z+21	; 0x15
     c98:	a0 e0       	ldi	r26, 0x00	; 0
     c9a:	b0 e0       	ldi	r27, 0x00	; 0
     c9c:	dc 01       	movw	r26, r24
     c9e:	99 27       	eor	r25, r25
     ca0:	88 27       	eor	r24, r24
     ca2:	22 8d       	ldd	r18, Z+26	; 0x1a
     ca4:	33 8d       	ldd	r19, Z+27	; 0x1b
     ca6:	40 e0       	ldi	r20, 0x00	; 0
     ca8:	50 e0       	ldi	r21, 0x00	; 0
     caa:	82 2b       	or	r24, r18
     cac:	93 2b       	or	r25, r19
     cae:	a4 2b       	or	r26, r20
     cb0:	b5 2b       	or	r27, r21
     cb2:	f8 01       	movw	r30, r16
     cb4:	84 83       	std	Z+4, r24	; 0x04
     cb6:	95 83       	std	Z+5, r25	; 0x05
     cb8:	a6 83       	std	Z+6, r26	; 0x06
     cba:	b7 83       	std	Z+7, r27	; 0x07
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK)
				res = dir_rewind(dj);			/* Rewind dir */
     cbc:	c8 01       	movw	r24, r16
     cbe:	0e 94 bd 00 	call	0x17a	; 0x17a <dir_rewind>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
     cc2:	83 30       	cpi	r24, 0x03	; 3
     cc4:	09 f4       	brne	.+2      	; 0xcc8 <pf_opendir+0x92>
     cc6:	84 e0       	ldi	r24, 0x04	; 4
	}

	return res;
}
     cc8:	ac 96       	adiw	r28, 0x2c	; 44
     cca:	0f b6       	in	r0, 0x3f	; 63
     ccc:	f8 94       	cli
     cce:	de bf       	out	0x3e, r29	; 62
     cd0:	0f be       	out	0x3f, r0	; 63
     cd2:	cd bf       	out	0x3d, r28	; 61
     cd4:	cf 91       	pop	r28
     cd6:	df 91       	pop	r29
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	ff 90       	pop	r15
     cde:	ef 90       	pop	r14
     ce0:	08 95       	ret

00000ce2 <pf_open>:
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
     ce2:	ef 92       	push	r14
     ce4:	ff 92       	push	r15
     ce6:	0f 93       	push	r16
     ce8:	1f 93       	push	r17
     cea:	df 93       	push	r29
     cec:	cf 93       	push	r28
     cee:	cd b7       	in	r28, 0x3d	; 61
     cf0:	de b7       	in	r29, 0x3e	; 62
     cf2:	ec 97       	sbiw	r28, 0x3c	; 60
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	de bf       	out	0x3e, r29	; 62
     cfa:	0f be       	out	0x3f, r0	; 63
     cfc:	cd bf       	out	0x3d, r28	; 61
     cfe:	bc 01       	movw	r22, r24
	FRESULT res;
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
     d00:	00 91 c3 02 	lds	r16, 0x02C3
     d04:	10 91 c4 02 	lds	r17, 0x02C4


	if (!fs)						/* Check file system */
     d08:	01 15       	cp	r16, r1
     d0a:	11 05       	cpc	r17, r1
     d0c:	11 f4       	brne	.+4      	; 0xd12 <pf_open+0x30>
     d0e:	66 e0       	ldi	r22, 0x06	; 6
     d10:	41 c0       	rjmp	.+130    	; 0xd94 <pf_open+0xb2>
		return FR_NOT_ENABLED;

	fs->flag = 0;
     d12:	f8 01       	movw	r30, r16
     d14:	12 82       	std	Z+2, r1	; 0x02
	fs->buf = dir;
     d16:	5d e1       	ldi	r21, 0x1D	; 29
     d18:	e5 2e       	mov	r14, r21
     d1a:	f1 2c       	mov	r15, r1
     d1c:	ec 0e       	add	r14, r28
     d1e:	fd 1e       	adc	r15, r29
     d20:	f7 82       	std	Z+7, r15	; 0x07
     d22:	e6 82       	std	Z+6, r14	; 0x06
	dj.fn = sp;
     d24:	ce 01       	movw	r24, r28
     d26:	01 96       	adiw	r24, 0x01	; 1
     d28:	98 8b       	std	Y+16, r25	; 0x10
     d2a:	8f 87       	std	Y+15, r24	; 0x0f
	res = follow_path(&dj, path);	/* Follow the file path */
     d2c:	ce 01       	movw	r24, r28
     d2e:	0d 96       	adiw	r24, 0x0d	; 13
     d30:	0e 94 0c 05 	call	0xa18	; 0xa18 <follow_path>
     d34:	68 2f       	mov	r22, r24
	if (res != FR_OK) return res;	/* Follow failed */
     d36:	88 23       	and	r24, r24
     d38:	69 f5       	brne	.+90     	; 0xd94 <pf_open+0xb2>
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
     d3a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d3c:	88 23       	and	r24, r24
     d3e:	49 f1       	breq	.+82     	; 0xd92 <pf_open+0xb0>
     d40:	88 a5       	ldd	r24, Y+40	; 0x28
     d42:	84 fd       	sbrc	r24, 4
     d44:	26 c0       	rjmp	.+76     	; 0xd92 <pf_open+0xb0>
		return FR_NO_FILE;

	fs->org_clust =						/* File start cluster */
     d46:	f7 01       	movw	r30, r14
     d48:	84 89       	ldd	r24, Z+20	; 0x14
     d4a:	95 89       	ldd	r25, Z+21	; 0x15
     d4c:	a0 e0       	ldi	r26, 0x00	; 0
     d4e:	b0 e0       	ldi	r27, 0x00	; 0
     d50:	dc 01       	movw	r26, r24
     d52:	99 27       	eor	r25, r25
     d54:	88 27       	eor	r24, r24
     d56:	22 8d       	ldd	r18, Z+26	; 0x1a
     d58:	33 8d       	ldd	r19, Z+27	; 0x1b
     d5a:	40 e0       	ldi	r20, 0x00	; 0
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	82 2b       	or	r24, r18
     d60:	93 2b       	or	r25, r19
     d62:	a4 2b       	or	r26, r20
     d64:	b5 2b       	or	r27, r21
     d66:	f8 01       	movw	r30, r16
     d68:	80 a3       	std	Z+32, r24	; 0x20
     d6a:	91 a3       	std	Z+33, r25	; 0x21
     d6c:	a2 a3       	std	Z+34, r26	; 0x22
     d6e:	b3 a3       	std	Z+35, r27	; 0x23
#if _FS_FAT32
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
#endif
		LD_WORD(dir+DIR_FstClusLO);
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
     d70:	f7 01       	movw	r30, r14
     d72:	84 8d       	ldd	r24, Z+28	; 0x1c
     d74:	95 8d       	ldd	r25, Z+29	; 0x1d
     d76:	a6 8d       	ldd	r26, Z+30	; 0x1e
     d78:	b7 8d       	ldd	r27, Z+31	; 0x1f
     d7a:	f8 01       	movw	r30, r16
     d7c:	84 8f       	std	Z+28, r24	; 0x1c
     d7e:	95 8f       	std	Z+29, r25	; 0x1d
     d80:	a6 8f       	std	Z+30, r26	; 0x1e
     d82:	b7 8f       	std	Z+31, r27	; 0x1f
	fs->fptr = 0;						/* File pointer */
     d84:	10 8e       	std	Z+24, r1	; 0x18
     d86:	11 8e       	std	Z+25, r1	; 0x19
     d88:	12 8e       	std	Z+26, r1	; 0x1a
     d8a:	13 8e       	std	Z+27, r1	; 0x1b
	fs->flag = FA_OPENED;
     d8c:	81 e0       	ldi	r24, 0x01	; 1
     d8e:	82 83       	std	Z+2, r24	; 0x02
     d90:	01 c0       	rjmp	.+2      	; 0xd94 <pf_open+0xb2>

	return FR_OK;
     d92:	63 e0       	ldi	r22, 0x03	; 3
}
     d94:	86 2f       	mov	r24, r22
     d96:	ec 96       	adiw	r28, 0x3c	; 60
     d98:	0f b6       	in	r0, 0x3f	; 63
     d9a:	f8 94       	cli
     d9c:	de bf       	out	0x3e, r29	; 62
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	cd bf       	out	0x3d, r28	; 61
     da2:	cf 91       	pop	r28
     da4:	df 91       	pop	r29
     da6:	1f 91       	pop	r17
     da8:	0f 91       	pop	r16
     daa:	ff 90       	pop	r15
     dac:	ef 90       	pop	r14
     dae:	08 95       	ret

00000db0 <pf_read>:
FRESULT pf_read (
	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
	WORD btr,		/* Number of bytes to read */
	WORD* br		/* Pointer to number of bytes read */
)
{
     db0:	4f 92       	push	r4
     db2:	5f 92       	push	r5
     db4:	6f 92       	push	r6
     db6:	7f 92       	push	r7
     db8:	8f 92       	push	r8
     dba:	9f 92       	push	r9
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	cf 92       	push	r12
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	3c 01       	movw	r6, r24
     dd2:	6b 01       	movw	r12, r22
     dd4:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	BYTE *rbuff = buff;
	WORD rcnt;
	FATFS *fs = FatFs;
     dd6:	c0 91 c3 02 	lds	r28, 0x02C3
     dda:	d0 91 c4 02 	lds	r29, 0x02C4


	*br = 0;
     dde:	fa 01       	movw	r30, r20
     de0:	11 82       	std	Z+1, r1	; 0x01
     de2:	10 82       	st	Z, r1
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
     de4:	20 97       	sbiw	r28, 0x00	; 0
     de6:	11 f4       	brne	.+4      	; 0xdec <pf_read+0x3c>
     de8:	86 e0       	ldi	r24, 0x06	; 6
     dea:	da c0       	rjmp	.+436    	; 0xfa0 <pf_read+0x1f0>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
     dec:	8a 81       	ldd	r24, Y+2	; 0x02
     dee:	80 fd       	sbrc	r24, 0
     df0:	02 c0       	rjmp	.+4      	; 0xdf6 <pf_read+0x46>
     df2:	85 e0       	ldi	r24, 0x05	; 5
     df4:	d5 c0       	rjmp	.+426    	; 0xfa0 <pf_read+0x1f0>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
     df6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     df8:	3d 8d       	ldd	r19, Y+29	; 0x1d
     dfa:	4e 8d       	ldd	r20, Y+30	; 0x1e
     dfc:	5f 8d       	ldd	r21, Y+31	; 0x1f
     dfe:	88 8d       	ldd	r24, Y+24	; 0x18
     e00:	99 8d       	ldd	r25, Y+25	; 0x19
     e02:	aa 8d       	ldd	r26, Y+26	; 0x1a
     e04:	bb 8d       	ldd	r27, Y+27	; 0x1b
     e06:	28 1b       	sub	r18, r24
     e08:	39 0b       	sbc	r19, r25
     e0a:	4a 0b       	sbc	r20, r26
     e0c:	5b 0b       	sbc	r21, r27
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
     e0e:	cb 01       	movw	r24, r22
     e10:	a0 e0       	ldi	r26, 0x00	; 0
     e12:	b0 e0       	ldi	r27, 0x00	; 0
     e14:	28 17       	cp	r18, r24
     e16:	39 07       	cpc	r19, r25
     e18:	4a 07       	cpc	r20, r26
     e1a:	5b 07       	cpc	r21, r27
     e1c:	08 f4       	brcc	.+2      	; 0xe20 <pf_read+0x70>
     e1e:	69 01       	movw	r12, r18
)
{
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	BYTE *rbuff = buff;
     e20:	53 01       	movw	r10, r6
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
			if (!sect) goto fr_abort;
			fs->dsect = sect + fs->csect++;
		}
		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
     e22:	41 2c       	mov	r4, r1
     e24:	f2 e0       	ldi	r31, 0x02	; 2
     e26:	5f 2e       	mov	r5, r31
     e28:	b3 c0       	rjmp	.+358    	; 0xf90 <pf_read+0x1e0>

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
     e2a:	e8 8c       	ldd	r14, Y+24	; 0x18
     e2c:	f9 8c       	ldd	r15, Y+25	; 0x19
     e2e:	0a 8d       	ldd	r16, Y+26	; 0x1a
     e30:	1b 8d       	ldd	r17, Y+27	; 0x1b
     e32:	d8 01       	movw	r26, r16
     e34:	c7 01       	movw	r24, r14
     e36:	91 70       	andi	r25, 0x01	; 1
     e38:	a0 70       	andi	r26, 0x00	; 0
     e3a:	b0 70       	andi	r27, 0x00	; 0
     e3c:	00 97       	sbiw	r24, 0x00	; 0
     e3e:	a1 05       	cpc	r26, r1
     e40:	b1 05       	cpc	r27, r1
     e42:	09 f0       	breq	.+2      	; 0xe46 <pf_read+0x96>
     e44:	6b c0       	rjmp	.+214    	; 0xf1c <pf_read+0x16c>
			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
     e46:	c8 01       	movw	r24, r16
     e48:	b7 01       	movw	r22, r14
     e4a:	e9 e0       	ldi	r30, 0x09	; 9
     e4c:	96 95       	lsr	r25
     e4e:	87 95       	ror	r24
     e50:	77 95       	ror	r23
     e52:	67 95       	ror	r22
     e54:	ea 95       	dec	r30
     e56:	d1 f7       	brne	.-12     	; 0xe4c <pf_read+0x9c>
     e58:	29 81       	ldd	r18, Y+1	; 0x01
     e5a:	30 e0       	ldi	r19, 0x00	; 0
     e5c:	40 e0       	ldi	r20, 0x00	; 0
     e5e:	50 e0       	ldi	r21, 0x00	; 0
     e60:	0e 94 98 19 	call	0x3330	; 0x3330 <__udivmodsi4>
     e64:	61 15       	cp	r22, r1
     e66:	71 05       	cpc	r23, r1
     e68:	81 05       	cpc	r24, r1
     e6a:	91 05       	cpc	r25, r1
     e6c:	d9 f4       	brne	.+54     	; 0xea4 <pf_read+0xf4>
				clst = (fs->fptr == 0) ?			/* On the top of the file? */
     e6e:	e1 14       	cp	r14, r1
     e70:	f1 04       	cpc	r15, r1
     e72:	01 05       	cpc	r16, r1
     e74:	11 05       	cpc	r17, r1
     e76:	29 f4       	brne	.+10     	; 0xe82 <pf_read+0xd2>
     e78:	68 a1       	ldd	r22, Y+32	; 0x20
     e7a:	79 a1       	ldd	r23, Y+33	; 0x21
     e7c:	8a a1       	ldd	r24, Y+34	; 0x22
     e7e:	9b a1       	ldd	r25, Y+35	; 0x23
     e80:	06 c0       	rjmp	.+12     	; 0xe8e <pf_read+0xde>
     e82:	6c a1       	ldd	r22, Y+36	; 0x24
     e84:	7d a1       	ldd	r23, Y+37	; 0x25
     e86:	8e a1       	ldd	r24, Y+38	; 0x26
     e88:	9f a1       	ldd	r25, Y+39	; 0x27
     e8a:	0e 94 3c 01 	call	0x278	; 0x278 <get_fat>
					fs->org_clust : get_fat(fs->curr_clust);
				if (clst <= 1) goto fr_abort;
     e8e:	62 30       	cpi	r22, 0x02	; 2
     e90:	71 05       	cpc	r23, r1
     e92:	81 05       	cpc	r24, r1
     e94:	91 05       	cpc	r25, r1
     e96:	08 f4       	brcc	.+2      	; 0xe9a <pf_read+0xea>
     e98:	81 c0       	rjmp	.+258    	; 0xf9c <pf_read+0x1ec>
				fs->curr_clust = clst;				/* Update current cluster */
     e9a:	6c a3       	std	Y+36, r22	; 0x24
     e9c:	7d a3       	std	Y+37, r23	; 0x25
     e9e:	8e a3       	std	Y+38, r24	; 0x26
     ea0:	9f a3       	std	Y+39, r25	; 0x27
				fs->csect = 0;						/* Reset sector offset in the cluster */
     ea2:	1b 82       	std	Y+3, r1	; 0x03
static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
	FATFS *fs = FatFs;
     ea4:	00 91 c3 02 	lds	r16, 0x02C3
     ea8:	10 91 c4 02 	lds	r17, 0x02C4


	clst -= 2;
     eac:	2c a1       	ldd	r18, Y+36	; 0x24
     eae:	3d a1       	ldd	r19, Y+37	; 0x25
     eb0:	4e a1       	ldd	r20, Y+38	; 0x26
     eb2:	5f a1       	ldd	r21, Y+39	; 0x27
     eb4:	22 50       	subi	r18, 0x02	; 2
     eb6:	30 40       	sbci	r19, 0x00	; 0
     eb8:	40 40       	sbci	r20, 0x00	; 0
     eba:	50 40       	sbci	r21, 0x00	; 0
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     ebc:	f8 01       	movw	r30, r16
     ebe:	80 85       	ldd	r24, Z+8	; 0x08
     ec0:	91 85       	ldd	r25, Z+9	; 0x09
     ec2:	a2 85       	ldd	r26, Z+10	; 0x0a
     ec4:	b3 85       	ldd	r27, Z+11	; 0x0b
     ec6:	02 97       	sbiw	r24, 0x02	; 2
     ec8:	a1 09       	sbc	r26, r1
     eca:	b1 09       	sbc	r27, r1
     ecc:	28 17       	cp	r18, r24
     ece:	39 07       	cpc	r19, r25
     ed0:	4a 07       	cpc	r20, r26
     ed2:	5b 07       	cpc	r21, r27
     ed4:	08 f0       	brcs	.+2      	; 0xed8 <pf_read+0x128>
     ed6:	62 c0       	rjmp	.+196    	; 0xf9c <pf_read+0x1ec>
	return (DWORD)clst * fs->csize + fs->database;
     ed8:	61 81       	ldd	r22, Z+1	; 0x01
     eda:	70 e0       	ldi	r23, 0x00	; 0
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__mulsi3>
     ee4:	9b 01       	movw	r18, r22
     ee6:	ac 01       	movw	r20, r24
     ee8:	f8 01       	movw	r30, r16
     eea:	84 89       	ldd	r24, Z+20	; 0x14
     eec:	95 89       	ldd	r25, Z+21	; 0x15
     eee:	a6 89       	ldd	r26, Z+22	; 0x16
     ef0:	b7 89       	ldd	r27, Z+23	; 0x17
     ef2:	28 0f       	add	r18, r24
     ef4:	39 1f       	adc	r19, r25
     ef6:	4a 1f       	adc	r20, r26
     ef8:	5b 1f       	adc	r21, r27
				if (clst <= 1) goto fr_abort;
				fs->curr_clust = clst;				/* Update current cluster */
				fs->csect = 0;						/* Reset sector offset in the cluster */
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
			if (!sect) goto fr_abort;
     efa:	21 15       	cp	r18, r1
     efc:	31 05       	cpc	r19, r1
     efe:	41 05       	cpc	r20, r1
     f00:	51 05       	cpc	r21, r1
     f02:	09 f4       	brne	.+2      	; 0xf06 <pf_read+0x156>
     f04:	4b c0       	rjmp	.+150    	; 0xf9c <pf_read+0x1ec>
			fs->dsect = sect + fs->csect++;
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	28 0f       	add	r18, r24
     f0a:	31 1d       	adc	r19, r1
     f0c:	41 1d       	adc	r20, r1
     f0e:	51 1d       	adc	r21, r1
     f10:	28 a7       	std	Y+40, r18	; 0x28
     f12:	39 a7       	std	Y+41, r19	; 0x29
     f14:	4a a7       	std	Y+42, r20	; 0x2a
     f16:	5b a7       	std	Y+43, r21	; 0x2b
     f18:	8f 5f       	subi	r24, 0xFF	; 255
     f1a:	8b 83       	std	Y+3, r24	; 0x03
		}
		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
     f1c:	08 8d       	ldd	r16, Y+24	; 0x18
     f1e:	19 8d       	ldd	r17, Y+25	; 0x19
     f20:	2a 8d       	ldd	r18, Y+26	; 0x1a
     f22:	3b 8d       	ldd	r19, Y+27	; 0x1b
     f24:	c8 01       	movw	r24, r16
     f26:	91 70       	andi	r25, 0x01	; 1
     f28:	a2 01       	movw	r20, r4
     f2a:	48 1b       	sub	r20, r24
     f2c:	59 0b       	sbc	r21, r25
     f2e:	76 01       	movw	r14, r12
     f30:	4c 15       	cp	r20, r12
     f32:	5d 05       	cpc	r21, r13
     f34:	08 f4       	brcc	.+2      	; 0xf38 <pf_read+0x188>
     f36:	7a 01       	movw	r14, r20
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
     f38:	61 14       	cp	r6, r1
     f3a:	71 04       	cpc	r7, r1
     f3c:	19 f4       	brne	.+6      	; 0xf44 <pf_read+0x194>
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	01 c0       	rjmp	.+2      	; 0xf46 <pf_read+0x196>
     f44:	c5 01       	movw	r24, r10
     f46:	48 a5       	ldd	r20, Y+40	; 0x28
     f48:	59 a5       	ldd	r21, Y+41	; 0x29
     f4a:	6a a5       	ldd	r22, Y+42	; 0x2a
     f4c:	7b a5       	ldd	r23, Y+43	; 0x2b
     f4e:	98 01       	movw	r18, r16
     f50:	31 70       	andi	r19, 0x01	; 1
     f52:	87 01       	movw	r16, r14
     f54:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
		if (dr) goto fr_abort;
     f58:	88 23       	and	r24, r24
     f5a:	01 f5       	brne	.+64     	; 0xf9c <pf_read+0x1ec>
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
     f5c:	c7 01       	movw	r24, r14
     f5e:	a0 e0       	ldi	r26, 0x00	; 0
     f60:	b0 e0       	ldi	r27, 0x00	; 0
     f62:	28 8d       	ldd	r18, Y+24	; 0x18
     f64:	39 8d       	ldd	r19, Y+25	; 0x19
     f66:	4a 8d       	ldd	r20, Y+26	; 0x1a
     f68:	5b 8d       	ldd	r21, Y+27	; 0x1b
     f6a:	28 0f       	add	r18, r24
     f6c:	39 1f       	adc	r19, r25
     f6e:	4a 1f       	adc	r20, r26
     f70:	5b 1f       	adc	r21, r27
     f72:	28 8f       	std	Y+24, r18	; 0x18
     f74:	39 8f       	std	Y+25, r19	; 0x19
     f76:	4a 8f       	std	Y+26, r20	; 0x1a
     f78:	5b 8f       	std	Y+27, r21	; 0x1b
     f7a:	ae 0c       	add	r10, r14
     f7c:	bf 1c       	adc	r11, r15
		btr -= rcnt; *br += rcnt;
     f7e:	ce 18       	sub	r12, r14
     f80:	df 08       	sbc	r13, r15
     f82:	f4 01       	movw	r30, r8
     f84:	80 81       	ld	r24, Z
     f86:	91 81       	ldd	r25, Z+1	; 0x01
     f88:	8e 0d       	add	r24, r14
     f8a:	9f 1d       	adc	r25, r15
     f8c:	91 83       	std	Z+1, r25	; 0x01
     f8e:	80 83       	st	Z, r24
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
     f90:	c1 14       	cp	r12, r1
     f92:	d1 04       	cpc	r13, r1
     f94:	09 f0       	breq	.+2      	; 0xf98 <pf_read+0x1e8>
     f96:	49 cf       	rjmp	.-366    	; 0xe2a <pf_read+0x7a>
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	02 c0       	rjmp	.+4      	; 0xfa0 <pf_read+0x1f0>
	}

	return FR_OK;

fr_abort:
	fs->flag = 0;
     f9c:	1a 82       	std	Y+2, r1	; 0x02
     f9e:	81 e0       	ldi	r24, 0x01	; 1
	return FR_DISK_ERR;
}
     fa0:	df 91       	pop	r29
     fa2:	cf 91       	pop	r28
     fa4:	1f 91       	pop	r17
     fa6:	0f 91       	pop	r16
     fa8:	ff 90       	pop	r15
     faa:	ef 90       	pop	r14
     fac:	df 90       	pop	r13
     fae:	cf 90       	pop	r12
     fb0:	bf 90       	pop	r11
     fb2:	af 90       	pop	r10
     fb4:	9f 90       	pop	r9
     fb6:	8f 90       	pop	r8
     fb8:	7f 90       	pop	r7
     fba:	6f 90       	pop	r6
     fbc:	5f 90       	pop	r5
     fbe:	4f 90       	pop	r4
     fc0:	08 95       	ret

00000fc2 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     fc2:	af 92       	push	r10
     fc4:	bf 92       	push	r11
     fc6:	cf 92       	push	r12
     fc8:	df 92       	push	r13
     fca:	ef 92       	push	r14
     fcc:	ff 92       	push	r15
     fce:	0f 93       	push	r16
     fd0:	1f 93       	push	r17
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
     fd6:	b8 2e       	mov	r11, r24
     fd8:	a9 2e       	mov	r10, r25
     fda:	6a 01       	movw	r12, r20
     fdc:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
     fde:	2e ef       	ldi	r18, 0xFE	; 254
     fe0:	31 e0       	ldi	r19, 0x01	; 1
     fe2:	02 e0       	ldi	r16, 0x02	; 2
     fe4:	10 e0       	ldi	r17, 0x00	; 0
     fe6:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
     fea:	88 23       	and	r24, r24
     fec:	11 f0       	breq	.+4      	; 0xff2 <check_fs+0x30>
     fee:	23 e0       	ldi	r18, 0x03	; 3
     ff0:	33 c0       	rjmp	.+102    	; 0x1058 <check_fs+0x96>
		return 3;
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
     ff2:	cb 2d       	mov	r28, r11
     ff4:	da 2d       	mov	r29, r10
     ff6:	88 81       	ld	r24, Y
     ff8:	99 81       	ldd	r25, Y+1	; 0x01
     ffa:	85 55       	subi	r24, 0x55	; 85
     ffc:	9a 4a       	sbci	r25, 0xAA	; 170
     ffe:	11 f0       	breq	.+4      	; 0x1004 <check_fs+0x42>
    1000:	22 e0       	ldi	r18, 0x02	; 2
    1002:	2a c0       	rjmp	.+84     	; 0x1058 <check_fs+0x96>
		return 2;

	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
    1004:	8b 2d       	mov	r24, r11
    1006:	9a 2d       	mov	r25, r10
    1008:	b7 01       	movw	r22, r14
    100a:	a6 01       	movw	r20, r12
    100c:	26 e3       	ldi	r18, 0x36	; 54
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	02 e0       	ldi	r16, 0x02	; 2
    1012:	10 e0       	ldi	r17, 0x00	; 0
    1014:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
    1018:	88 23       	and	r24, r24
    101a:	39 f4       	brne	.+14     	; 0x102a <check_fs+0x68>
    101c:	88 81       	ld	r24, Y
    101e:	99 81       	ldd	r25, Y+1	; 0x01
    1020:	86 54       	subi	r24, 0x46	; 70
    1022:	91 44       	sbci	r25, 0x41	; 65
    1024:	11 f4       	brne	.+4      	; 0x102a <check_fs+0x68>
    1026:	20 e0       	ldi	r18, 0x00	; 0
    1028:	17 c0       	rjmp	.+46     	; 0x1058 <check_fs+0x96>
		return 0;
#if _FS_FAT32
	if (!disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
    102a:	8b 2d       	mov	r24, r11
    102c:	9a 2d       	mov	r25, r10
    102e:	b7 01       	movw	r22, r14
    1030:	a6 01       	movw	r20, r12
    1032:	22 e5       	ldi	r18, 0x52	; 82
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	02 e0       	ldi	r16, 0x02	; 2
    1038:	10 e0       	ldi	r17, 0x00	; 0
    103a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
    103e:	88 23       	and	r24, r24
    1040:	11 f0       	breq	.+4      	; 0x1046 <check_fs+0x84>
    1042:	21 e0       	ldi	r18, 0x01	; 1
    1044:	09 c0       	rjmp	.+18     	; 0x1058 <check_fs+0x96>
    1046:	20 e0       	ldi	r18, 0x00	; 0
    1048:	88 81       	ld	r24, Y
    104a:	99 81       	ldd	r25, Y+1	; 0x01
    104c:	86 54       	subi	r24, 0x46	; 70
    104e:	91 44       	sbci	r25, 0x41	; 65
    1050:	09 f4       	brne	.+2      	; 0x1054 <check_fs+0x92>
    1052:	21 e0       	ldi	r18, 0x01	; 1
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	28 27       	eor	r18, r24
		return 0;
#endif
	return 1;
}
    1058:	82 2f       	mov	r24, r18
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	1f 91       	pop	r17
    1060:	0f 91       	pop	r16
    1062:	ff 90       	pop	r15
    1064:	ef 90       	pop	r14
    1066:	df 90       	pop	r13
    1068:	cf 90       	pop	r12
    106a:	bf 90       	pop	r11
    106c:	af 90       	pop	r10
    106e:	08 95       	ret

00001070 <pf_mount>:
/*-----------------------------------------------------------------------*/

FRESULT pf_mount (
	FATFS *fs		/* Pointer to new file system object (NULL: Unmount) */
)
{
    1070:	6f 92       	push	r6
    1072:	7f 92       	push	r7
    1074:	8f 92       	push	r8
    1076:	9f 92       	push	r9
    1078:	af 92       	push	r10
    107a:	bf 92       	push	r11
    107c:	cf 92       	push	r12
    107e:	df 92       	push	r13
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	df 93       	push	r29
    108a:	cf 93       	push	r28
    108c:	cd b7       	in	r28, 0x3d	; 61
    108e:	de b7       	in	r29, 0x3e	; 62
    1090:	a4 97       	sbiw	r28, 0x24	; 36
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	de bf       	out	0x3e, r29	; 62
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	cd bf       	out	0x3d, r28	; 61
    109c:	5c 01       	movw	r10, r24
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
    109e:	10 92 c4 02 	sts	0x02C4, r1
    10a2:	10 92 c3 02 	sts	0x02C3, r1
	if (!fs) return FR_OK;				/* Unregister fs object */
    10a6:	00 97       	sbiw	r24, 0x00	; 0
    10a8:	09 f4       	brne	.+2      	; 0x10ac <pf_mount+0x3c>
    10aa:	ed c0       	rjmp	.+474    	; 0x1286 <pf_mount+0x216>

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
    10ac:	0e 94 0d 0b 	call	0x161a	; 0x161a <disk_initialize>
    10b0:	80 ff       	sbrs	r24, 0
    10b2:	02 c0       	rjmp	.+4      	; 0x10b8 <pf_mount+0x48>
    10b4:	82 e0       	ldi	r24, 0x02	; 2
    10b6:	ec c0       	rjmp	.+472    	; 0x1290 <pf_mount+0x220>
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
    10b8:	4e 01       	movw	r8, r28
    10ba:	08 94       	sec
    10bc:	81 1c       	adc	r8, r1
    10be:	91 1c       	adc	r9, r1
    10c0:	c4 01       	movw	r24, r8
    10c2:	40 e0       	ldi	r20, 0x00	; 0
    10c4:	50 e0       	ldi	r21, 0x00	; 0
    10c6:	60 e0       	ldi	r22, 0x00	; 0
    10c8:	70 e0       	ldi	r23, 0x00	; 0
    10ca:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <check_fs>
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
    10ce:	81 30       	cpi	r24, 0x01	; 1
    10d0:	21 f0       	breq	.+8      	; 0x10da <pf_mount+0x6a>
    10d2:	cc 24       	eor	r12, r12
    10d4:	dd 24       	eor	r13, r13
    10d6:	76 01       	movw	r14, r12
    10d8:	1b c0       	rjmp	.+54     	; 0x1110 <pf_mount+0xa0>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
    10da:	c4 01       	movw	r24, r8
    10dc:	40 e0       	ldi	r20, 0x00	; 0
    10de:	50 e0       	ldi	r21, 0x00	; 0
    10e0:	60 e0       	ldi	r22, 0x00	; 0
    10e2:	70 e0       	ldi	r23, 0x00	; 0
    10e4:	2e eb       	ldi	r18, 0xBE	; 190
    10e6:	31 e0       	ldi	r19, 0x01	; 1
    10e8:	00 e1       	ldi	r16, 0x10	; 16
    10ea:	10 e0       	ldi	r17, 0x00	; 0
    10ec:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
    10f0:	88 23       	and	r24, r24
    10f2:	09 f0       	breq	.+2      	; 0x10f6 <pf_mount+0x86>
    10f4:	ca c0       	rjmp	.+404    	; 0x128a <pf_mount+0x21a>
			fmt = 3;
		} else {
			if (buf[4]) {					/* Is the partition existing? */
    10f6:	8d 81       	ldd	r24, Y+5	; 0x05
    10f8:	88 23       	and	r24, r24
    10fa:	09 f4       	brne	.+2      	; 0x10fe <pf_mount+0x8e>
    10fc:	c8 c0       	rjmp	.+400    	; 0x128e <pf_mount+0x21e>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
    10fe:	c9 84       	ldd	r12, Y+9	; 0x09
    1100:	da 84       	ldd	r13, Y+10	; 0x0a
    1102:	eb 84       	ldd	r14, Y+11	; 0x0b
    1104:	fc 84       	ldd	r15, Y+12	; 0x0c
				fmt = check_fs(buf, bsect);	/* Check the partition */
    1106:	c4 01       	movw	r24, r8
    1108:	b7 01       	movw	r22, r14
    110a:	a6 01       	movw	r20, r12
    110c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <check_fs>
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1110:	83 30       	cpi	r24, 0x03	; 3
    1112:	09 f4       	brne	.+2      	; 0x1116 <pf_mount+0xa6>
    1114:	ba c0       	rjmp	.+372    	; 0x128a <pf_mount+0x21a>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    1116:	88 23       	and	r24, r24
    1118:	09 f0       	breq	.+2      	; 0x111c <pf_mount+0xac>
    111a:	b9 c0       	rjmp	.+370    	; 0x128e <pf_mount+0x21e>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
    111c:	ce 01       	movw	r24, r28
    111e:	01 96       	adiw	r24, 0x01	; 1
    1120:	b7 01       	movw	r22, r14
    1122:	a6 01       	movw	r20, r12
    1124:	2d e0       	ldi	r18, 0x0D	; 13
    1126:	30 e0       	ldi	r19, 0x00	; 0
    1128:	04 e2       	ldi	r16, 0x24	; 36
    112a:	10 e0       	ldi	r17, 0x00	; 0
    112c:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <disk_readp>
    1130:	88 23       	and	r24, r24
    1132:	09 f0       	breq	.+2      	; 0x1136 <pf_mount+0xc6>
    1134:	aa c0       	rjmp	.+340    	; 0x128a <pf_mount+0x21a>

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
    1136:	8a 85       	ldd	r24, Y+10	; 0x0a
    1138:	9b 85       	ldd	r25, Y+11	; 0x0b
    113a:	bc 01       	movw	r22, r24
    113c:	80 e0       	ldi	r24, 0x00	; 0
    113e:	90 e0       	ldi	r25, 0x00	; 0
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
    1140:	61 15       	cp	r22, r1
    1142:	71 05       	cpc	r23, r1
    1144:	81 05       	cpc	r24, r1
    1146:	91 05       	cpc	r25, r1
    1148:	21 f4       	brne	.+8      	; 0x1152 <pf_mount+0xe2>
    114a:	68 8d       	ldd	r22, Y+24	; 0x18
    114c:	79 8d       	ldd	r23, Y+25	; 0x19
    114e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1150:	9b 8d       	ldd	r25, Y+27	; 0x1b

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
    1152:	2c 81       	ldd	r18, Y+4	; 0x04
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	40 e0       	ldi	r20, 0x00	; 0
    1158:	50 e0       	ldi	r21, 0x00	; 0
    115a:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__mulsi3>
    115e:	3b 01       	movw	r6, r22
    1160:	4c 01       	movw	r8, r24
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
    1162:	8a 81       	ldd	r24, Y+2	; 0x02
    1164:	9b 81       	ldd	r25, Y+3	; 0x03
    1166:	a0 e0       	ldi	r26, 0x00	; 0
    1168:	b0 e0       	ldi	r27, 0x00	; 0
    116a:	c8 0e       	add	r12, r24
    116c:	d9 1e       	adc	r13, r25
    116e:	ea 1e       	adc	r14, r26
    1170:	fb 1e       	adc	r15, r27
    1172:	f5 01       	movw	r30, r10
    1174:	c4 86       	std	Z+12, r12	; 0x0c
    1176:	d5 86       	std	Z+13, r13	; 0x0d
    1178:	e6 86       	std	Z+14, r14	; 0x0e
    117a:	f7 86       	std	Z+15, r15	; 0x0f
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
    117c:	89 81       	ldd	r24, Y+1	; 0x01
    117e:	81 83       	std	Z+1, r24	; 0x01
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
    1180:	2d 81       	ldd	r18, Y+5	; 0x05
    1182:	3e 81       	ldd	r19, Y+6	; 0x06
    1184:	35 83       	std	Z+5, r19	; 0x05
    1186:	24 83       	std	Z+4, r18	; 0x04
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
    1188:	8f 81       	ldd	r24, Y+7	; 0x07
    118a:	98 85       	ldd	r25, Y+8	; 0x08
    118c:	7c 01       	movw	r14, r24
    118e:	00 e0       	ldi	r16, 0x00	; 0
    1190:	10 e0       	ldi	r17, 0x00	; 0
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
    1192:	e1 14       	cp	r14, r1
    1194:	f1 04       	cpc	r15, r1
    1196:	01 05       	cpc	r16, r1
    1198:	11 05       	cpc	r17, r1
    119a:	21 f4       	brne	.+8      	; 0x11a4 <pf_mount+0x134>
    119c:	ec 88       	ldd	r14, Y+20	; 0x14
    119e:	fd 88       	ldd	r15, Y+21	; 0x15
    11a0:	0e 89       	ldd	r16, Y+22	; 0x16
    11a2:	1f 89       	ldd	r17, Y+23	; 0x17
	mclst = (tsect						/* Last cluster# + 1 */
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	9b 81       	ldd	r25, Y+3	; 0x03
    11a8:	a0 e0       	ldi	r26, 0x00	; 0
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	e8 1a       	sub	r14, r24
    11ae:	f9 0a       	sbc	r15, r25
    11b0:	0a 0b       	sbc	r16, r26
    11b2:	1b 0b       	sbc	r17, r27
    11b4:	e6 18       	sub	r14, r6
    11b6:	f7 08       	sbc	r15, r7
    11b8:	08 09       	sbc	r16, r8
    11ba:	19 09       	sbc	r17, r9
    11bc:	b4 e0       	ldi	r27, 0x04	; 4
    11be:	36 95       	lsr	r19
    11c0:	27 95       	ror	r18
    11c2:	ba 95       	dec	r27
    11c4:	e1 f7       	brne	.-8      	; 0x11be <pf_mount+0x14e>
    11c6:	c9 01       	movw	r24, r18
    11c8:	a0 e0       	ldi	r26, 0x00	; 0
    11ca:	b0 e0       	ldi	r27, 0x00	; 0
    11cc:	e8 1a       	sub	r14, r24
    11ce:	f9 0a       	sbc	r15, r25
    11d0:	0a 0b       	sbc	r16, r26
    11d2:	1b 0b       	sbc	r17, r27
    11d4:	f5 01       	movw	r30, r10
    11d6:	21 81       	ldd	r18, Z+1	; 0x01
    11d8:	30 e0       	ldi	r19, 0x00	; 0
    11da:	40 e0       	ldi	r20, 0x00	; 0
    11dc:	50 e0       	ldi	r21, 0x00	; 0
    11de:	c8 01       	movw	r24, r16
    11e0:	b7 01       	movw	r22, r14
    11e2:	0e 94 98 19 	call	0x3330	; 0x3330 <__udivmodsi4>
    11e6:	2e 5f       	subi	r18, 0xFE	; 254
    11e8:	3f 4f       	sbci	r19, 0xFF	; 255
    11ea:	4f 4f       	sbci	r20, 0xFF	; 255
    11ec:	5f 4f       	sbci	r21, 0xFF	; 255
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->max_clust = (CLUST)mclst;
    11ee:	f5 01       	movw	r30, r10
    11f0:	20 87       	std	Z+8, r18	; 0x08
    11f2:	31 87       	std	Z+9, r19	; 0x09
    11f4:	42 87       	std	Z+10, r20	; 0x0a
    11f6:	53 87       	std	Z+11, r21	; 0x0b

	fmt = FS_FAT12;							/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;		/* Number of clusters >= 0xFF5 */
    11f8:	27 3f       	cpi	r18, 0xF7	; 247
    11fa:	ff e0       	ldi	r31, 0x0F	; 15
    11fc:	3f 07       	cpc	r19, r31
    11fe:	f0 e0       	ldi	r31, 0x00	; 0
    1200:	4f 07       	cpc	r20, r31
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	5f 07       	cpc	r21, r31
    1206:	10 f4       	brcc	.+4      	; 0x120c <pf_mount+0x19c>
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	08 c0       	rjmp	.+16     	; 0x121c <pf_mount+0x1ac>
	if (mclst >= 0xFFF7)					/* Number of clusters >= 0xFFF5 */
    120c:	27 5f       	subi	r18, 0xF7	; 247
    120e:	3f 4f       	sbci	r19, 0xFF	; 255
    1210:	40 40       	sbci	r20, 0x00	; 0
    1212:	50 40       	sbci	r21, 0x00	; 0
    1214:	10 f0       	brcs	.+4      	; 0x121a <pf_mount+0x1aa>
    1216:	83 e0       	ldi	r24, 0x03	; 3
    1218:	01 c0       	rjmp	.+2      	; 0x121c <pf_mount+0x1ac>
    121a:	82 e0       	ldi	r24, 0x02	; 2
		fmt = FS_FAT32;
#else
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
    121c:	f5 01       	movw	r30, r10
    121e:	80 83       	st	Z, r24
#if _FS_FAT32
	if (fmt == FS_FAT32)
    1220:	83 30       	cpi	r24, 0x03	; 3
    1222:	29 f4       	brne	.+10     	; 0x122e <pf_mount+0x1be>
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
    1224:	88 a1       	ldd	r24, Y+32	; 0x20
    1226:	99 a1       	ldd	r25, Y+33	; 0x21
    1228:	aa a1       	ldd	r26, Y+34	; 0x22
    122a:	bb a1       	ldd	r27, Y+35	; 0x23
    122c:	09 c0       	rjmp	.+18     	; 0x1240 <pf_mount+0x1d0>
	else
#endif
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
    122e:	f5 01       	movw	r30, r10
    1230:	84 85       	ldd	r24, Z+12	; 0x0c
    1232:	95 85       	ldd	r25, Z+13	; 0x0d
    1234:	a6 85       	ldd	r26, Z+14	; 0x0e
    1236:	b7 85       	ldd	r27, Z+15	; 0x0f
    1238:	86 0d       	add	r24, r6
    123a:	97 1d       	adc	r25, r7
    123c:	a8 1d       	adc	r26, r8
    123e:	b9 1d       	adc	r27, r9
    1240:	80 8b       	std	Z+16, r24	; 0x10
    1242:	91 8b       	std	Z+17, r25	; 0x11
    1244:	a2 8b       	std	Z+18, r26	; 0x12
    1246:	b3 8b       	std	Z+19, r27	; 0x13
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
    1248:	f5 01       	movw	r30, r10
    124a:	84 81       	ldd	r24, Z+4	; 0x04
    124c:	95 81       	ldd	r25, Z+5	; 0x05
    124e:	a4 e0       	ldi	r26, 0x04	; 4
    1250:	96 95       	lsr	r25
    1252:	87 95       	ror	r24
    1254:	aa 95       	dec	r26
    1256:	e1 f7       	brne	.-8      	; 0x1250 <pf_mount+0x1e0>
    1258:	a0 e0       	ldi	r26, 0x00	; 0
    125a:	b0 e0       	ldi	r27, 0x00	; 0
    125c:	24 85       	ldd	r18, Z+12	; 0x0c
    125e:	35 85       	ldd	r19, Z+13	; 0x0d
    1260:	46 85       	ldd	r20, Z+14	; 0x0e
    1262:	57 85       	ldd	r21, Z+15	; 0x0f
    1264:	82 0f       	add	r24, r18
    1266:	93 1f       	adc	r25, r19
    1268:	a4 1f       	adc	r26, r20
    126a:	b5 1f       	adc	r27, r21
    126c:	86 0d       	add	r24, r6
    126e:	97 1d       	adc	r25, r7
    1270:	a8 1d       	adc	r26, r8
    1272:	b9 1d       	adc	r27, r9
    1274:	84 8b       	std	Z+20, r24	; 0x14
    1276:	95 8b       	std	Z+21, r25	; 0x15
    1278:	a6 8b       	std	Z+22, r26	; 0x16
    127a:	b7 8b       	std	Z+23, r27	; 0x17

	fs->flag = 0;
    127c:	12 82       	std	Z+2, r1	; 0x02
	FatFs = fs;
    127e:	b0 92 c4 02 	sts	0x02C4, r11
    1282:	a0 92 c3 02 	sts	0x02C3, r10
    1286:	80 e0       	ldi	r24, 0x00	; 0
    1288:	03 c0       	rjmp	.+6      	; 0x1290 <pf_mount+0x220>

	return FR_OK;
    128a:	81 e0       	ldi	r24, 0x01	; 1
    128c:	01 c0       	rjmp	.+2      	; 0x1290 <pf_mount+0x220>
    128e:	87 e0       	ldi	r24, 0x07	; 7
}
    1290:	a4 96       	adiw	r28, 0x24	; 36
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	de bf       	out	0x3e, r29	; 62
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	cd bf       	out	0x3d, r28	; 61
    129c:	cf 91       	pop	r28
    129e:	df 91       	pop	r29
    12a0:	1f 91       	pop	r17
    12a2:	0f 91       	pop	r16
    12a4:	ff 90       	pop	r15
    12a6:	ef 90       	pop	r14
    12a8:	df 90       	pop	r13
    12aa:	cf 90       	pop	r12
    12ac:	bf 90       	pop	r11
    12ae:	af 90       	pop	r10
    12b0:	9f 90       	pop	r9
    12b2:	8f 90       	pop	r8
    12b4:	7f 90       	pop	r7
    12b6:	6f 90       	pop	r6
    12b8:	08 95       	ret

000012ba <sd_send_cmd>:
/* 引数：コマンド                     */
/* データ                             */
/* 機能：コマンドを送信する           */
/*------------------------------------*/
static uint8_t sd_send_cmd(uint8_t cmd, unsigned long data, uint8_t crc)
{
    12ba:	98 2f       	mov	r25, r24
	uint8_t res; //レスポンス
	int8_t i;
	
	/* ダミークロック, 有効化 */
	SS_H(); spi_inout(0xff); SS_L();
    12bc:	2a 9a       	sbi	0x05, 2	; 5
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    12be:	8f ef       	ldi	r24, 0xFF	; 255
    12c0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    12c2:	0d b4       	in	r0, 0x2d	; 45
    12c4:	07 fe       	sbrs	r0, 7
    12c6:	fd cf       	rjmp	.-6      	; 0x12c2 <sd_send_cmd+0x8>
	return SPDR;
    12c8:	8e b5       	in	r24, 0x2e	; 46
{
	uint8_t res; //レスポンス
	int8_t i;
	
	/* ダミークロック, 有効化 */
	SS_H(); spi_inout(0xff); SS_L();
    12ca:	2a 98       	cbi	0x05, 2	; 5
	/* スタート・ビット,コマンド */
	spi_inout(0x40 | cmd);
    12cc:	90 64       	ori	r25, 0x40	; 64
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    12ce:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & _BV(SPIF)));
    12d0:	0d b4       	in	r0, 0x2d	; 45
    12d2:	07 fe       	sbrs	r0, 7
    12d4:	fd cf       	rjmp	.-6      	; 0x12d0 <sd_send_cmd+0x16>
	return SPDR;
    12d6:	8e b5       	in	r24, 0x2e	; 46
    12d8:	e8 e1       	ldi	r30, 0x18	; 24
    12da:	f0 e0       	ldi	r31, 0x00	; 0
	/* ダミークロック, 有効化 */
	SS_H(); spi_inout(0xff); SS_L();
	/* スタート・ビット,コマンド */
	spi_inout(0x40 | cmd);
	/* データ */
	for(i = 24 ; i >= 0 ; i -= 8) spi_inout(data >> i);
    12dc:	db 01       	movw	r26, r22
    12de:	ca 01       	movw	r24, r20
    12e0:	0e 2e       	mov	r0, r30
    12e2:	04 c0       	rjmp	.+8      	; 0x12ec <sd_send_cmd+0x32>
    12e4:	b6 95       	lsr	r27
    12e6:	a7 95       	ror	r26
    12e8:	97 95       	ror	r25
    12ea:	87 95       	ror	r24
    12ec:	0a 94       	dec	r0
    12ee:	d2 f7       	brpl	.-12     	; 0x12e4 <sd_send_cmd+0x2a>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    12f0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    12f2:	0d b4       	in	r0, 0x2d	; 45
    12f4:	07 fe       	sbrs	r0, 7
    12f6:	fd cf       	rjmp	.-6      	; 0x12f2 <sd_send_cmd+0x38>
	return SPDR;
    12f8:	8e b5       	in	r24, 0x2e	; 46
    12fa:	38 97       	sbiw	r30, 0x08	; 8
	/* ダミークロック, 有効化 */
	SS_H(); spi_inout(0xff); SS_L();
	/* スタート・ビット,コマンド */
	spi_inout(0x40 | cmd);
	/* データ */
	for(i = 24 ; i >= 0 ; i -= 8) spi_inout(data >> i);
    12fc:	8f ef       	ldi	r24, 0xFF	; 255
    12fe:	e8 3f       	cpi	r30, 0xF8	; 248
    1300:	f8 07       	cpc	r31, r24
    1302:	61 f7       	brne	.-40     	; 0x12dc <sd_send_cmd+0x22>
	/* CRC,ストップ・ビット */
	spi_inout((crc << 1) | 0x01);
    1304:	22 0f       	add	r18, r18
    1306:	21 60       	ori	r18, 0x01	; 1
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1308:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    130a:	0d b4       	in	r0, 0x2d	; 45
    130c:	07 fe       	sbrs	r0, 7
    130e:	fd cf       	rjmp	.-6      	; 0x130a <sd_send_cmd+0x50>
	return SPDR;
    1310:	8e b5       	in	r24, 0x2e	; 46
    1312:	90 e0       	ldi	r25, 0x00	; 0
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1314:	2f ef       	ldi	r18, 0xFF	; 255
    1316:	01 c0       	rjmp	.+2      	; 0x131a <sd_send_cmd+0x60>
	/* データ */
	for(i = 24 ; i >= 0 ; i -= 8) spi_inout(data >> i);
	/* CRC,ストップ・ビット */
	spi_inout((crc << 1) | 0x01);
	/* レスポンス */
	for(i = 0 ; ((res = spi_inout(0xff)) & 0x80) && i < 8 ; i++);
    1318:	9f 5f       	subi	r25, 0xFF	; 255
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    131a:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    131c:	0d b4       	in	r0, 0x2d	; 45
    131e:	07 fe       	sbrs	r0, 7
    1320:	fd cf       	rjmp	.-6      	; 0x131c <sd_send_cmd+0x62>
	return SPDR;
    1322:	8e b5       	in	r24, 0x2e	; 46
	/* データ */
	for(i = 24 ; i >= 0 ; i -= 8) spi_inout(data >> i);
	/* CRC,ストップ・ビット */
	spi_inout((crc << 1) | 0x01);
	/* レスポンス */
	for(i = 0 ; ((res = spi_inout(0xff)) & 0x80) && i < 8 ; i++);
    1324:	87 ff       	sbrs	r24, 7
    1326:	02 c0       	rjmp	.+4      	; 0x132c <sd_send_cmd+0x72>
    1328:	98 30       	cpi	r25, 0x08	; 8
    132a:	b1 f7       	brne	.-20     	; 0x1318 <sd_send_cmd+0x5e>
	return res;
}
    132c:	08 95       	ret

0000132e <sd_read>:
/* オフセット                         */
/* 読込バイト数                       */
/* 機能：SDカードの読み込みを行う     */
/*------------------------------------*/
uint8_t sd_read(unsigned long address, uint8_t buf[], uint16_t offset, uint16_t count)
{
    132e:	af 92       	push	r10
    1330:	bf 92       	push	r11
    1332:	cf 92       	push	r12
    1334:	df 92       	push	r13
    1336:	ef 92       	push	r14
    1338:	ff 92       	push	r15
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	6b 01       	movw	r12, r22
    1344:	7c 01       	movw	r14, r24
    1346:	5a 01       	movw	r10, r20
    1348:	e9 01       	movw	r28, r18
	register uint16_t cnt;	// カウンタ
	uint8_t res;			// レスポンス

	/* シングル・ブロック・リード */
	res = sd_send_cmd(17, address, 0);
    134a:	81 e1       	ldi	r24, 0x11	; 17
    134c:	b7 01       	movw	r22, r14
    134e:	a6 01       	movw	r20, r12
    1350:	20 e0       	ldi	r18, 0x00	; 0
    1352:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    1356:	48 2f       	mov	r20, r24
	if(res == 0x00){
    1358:	88 23       	and	r24, r24
    135a:	09 f0       	breq	.+2      	; 0x135e <sd_read+0x30>
    135c:	4e c0       	rjmp	.+156    	; 0x13fa <sd_read+0xcc>
    135e:	80 e1       	ldi	r24, 0x10	; 16
    1360:	97 e2       	ldi	r25, 0x27	; 39
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1362:	3f ef       	ldi	r19, 0xFF	; 255
    1364:	03 c0       	rjmp	.+6      	; 0x136c <sd_read+0x3e>

	/* シングル・ブロック・リード */
	res = sd_send_cmd(17, address, 0);
	if(res == 0x00){
		/* データ・スタート(0xFE)またはエラー・レスポンス */
		for(cnt = 10000 ; cnt && ((res = spi_inout(0xff)) == 0xff) ; cnt--);
    1366:	01 97       	sbiw	r24, 0x01	; 1
    1368:	09 f4       	brne	.+2      	; 0x136c <sd_read+0x3e>
    136a:	46 c0       	rjmp	.+140    	; 0x13f8 <sd_read+0xca>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    136c:	3e bd       	out	0x2e, r19	; 46
	while(!(SPSR & _BV(SPIF)));
    136e:	0d b4       	in	r0, 0x2d	; 45
    1370:	07 fe       	sbrs	r0, 7
    1372:	fd cf       	rjmp	.-6      	; 0x136e <sd_read+0x40>
	return SPDR;
    1374:	2e b5       	in	r18, 0x2e	; 46

	/* シングル・ブロック・リード */
	res = sd_send_cmd(17, address, 0);
	if(res == 0x00){
		/* データ・スタート(0xFE)またはエラー・レスポンス */
		for(cnt = 10000 ; cnt && ((res = spi_inout(0xff)) == 0xff) ; cnt--);
    1376:	2f 3f       	cpi	r18, 0xFF	; 255
    1378:	b1 f3       	breq	.-20     	; 0x1366 <sd_read+0x38>
		if(res == 0xfe){
    137a:	2e 3f       	cpi	r18, 0xFE	; 254
    137c:	e9 f5       	brne	.+122    	; 0x13f8 <sd_read+0xca>
    137e:	9e 01       	movw	r18, r28
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1380:	8f ef       	ldi	r24, 0xFF	; 255
    1382:	07 c0       	rjmp	.+14     	; 0x1392 <sd_read+0x64>
    1384:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    1386:	0d b4       	in	r0, 0x2d	; 45
    1388:	07 fe       	sbrs	r0, 7
    138a:	fd cf       	rjmp	.-6      	; 0x1386 <sd_read+0x58>
	return SPDR;
    138c:	9e b5       	in	r25, 0x2e	; 46
		/* データ・スタート(0xFE)またはエラー・レスポンス */
		for(cnt = 10000 ; cnt && ((res = spi_inout(0xff)) == 0xff) ; cnt--);
		if(res == 0xfe){
			res = 0x00;
			/* データ格納 */
			for(cnt = offset ; cnt ; cnt--) spi_inout(0xff);					// オフセット移動
    138e:	21 50       	subi	r18, 0x01	; 1
    1390:	30 40       	sbci	r19, 0x00	; 0
    1392:	21 15       	cp	r18, r1
    1394:	31 05       	cpc	r19, r1
    1396:	b1 f7       	brne	.-20     	; 0x1384 <sd_read+0x56>
    1398:	0c c0       	rjmp	.+24     	; 0x13b2 <sd_read+0x84>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    139a:	9e bd       	out	0x2e, r25	; 46
	while(!(SPSR & _BV(SPIF)));
    139c:	0d b4       	in	r0, 0x2d	; 45
    139e:	07 fe       	sbrs	r0, 7
    13a0:	fd cf       	rjmp	.-6      	; 0x139c <sd_read+0x6e>
	return SPDR;
    13a2:	8e b5       	in	r24, 0x2e	; 46
		for(cnt = 10000 ; cnt && ((res = spi_inout(0xff)) == 0xff) ; cnt--);
		if(res == 0xfe){
			res = 0x00;
			/* データ格納 */
			for(cnt = offset ; cnt ; cnt--) spi_inout(0xff);					// オフセット移動
			for(; cnt < count ; cnt++) buf[cnt] = spi_inout(0xff);			// 指定バイト読込
    13a4:	f5 01       	movw	r30, r10
    13a6:	e2 0f       	add	r30, r18
    13a8:	f3 1f       	adc	r31, r19
    13aa:	80 83       	st	Z, r24
    13ac:	2f 5f       	subi	r18, 0xFF	; 255
    13ae:	3f 4f       	sbci	r19, 0xFF	; 255
    13b0:	01 c0       	rjmp	.+2      	; 0x13b4 <sd_read+0x86>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    13b2:	9f ef       	ldi	r25, 0xFF	; 255
		for(cnt = 10000 ; cnt && ((res = spi_inout(0xff)) == 0xff) ; cnt--);
		if(res == 0xfe){
			res = 0x00;
			/* データ格納 */
			for(cnt = offset ; cnt ; cnt--) spi_inout(0xff);					// オフセット移動
			for(; cnt < count ; cnt++) buf[cnt] = spi_inout(0xff);			// 指定バイト読込
    13b4:	20 17       	cp	r18, r16
    13b6:	31 07       	cpc	r19, r17
    13b8:	80 f3       	brcs	.-32     	; 0x139a <sd_read+0x6c>
			for(cnt = 512 - offset - count ; cnt ; cnt--) spi_inout(0xff);	// 残り移動
    13ba:	88 27       	eor	r24, r24
    13bc:	99 27       	eor	r25, r25
    13be:	8c 1b       	sub	r24, r28
    13c0:	9d 0b       	sbc	r25, r29
    13c2:	80 50       	subi	r24, 0x00	; 0
    13c4:	9e 4f       	sbci	r25, 0xFE	; 254
    13c6:	80 1b       	sub	r24, r16
    13c8:	91 0b       	sbc	r25, r17
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    13ca:	2f ef       	ldi	r18, 0xFF	; 255
    13cc:	06 c0       	rjmp	.+12     	; 0x13da <sd_read+0xac>
    13ce:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    13d0:	0d b4       	in	r0, 0x2d	; 45
    13d2:	07 fe       	sbrs	r0, 7
    13d4:	fd cf       	rjmp	.-6      	; 0x13d0 <sd_read+0xa2>
	return SPDR;
    13d6:	3e b5       	in	r19, 0x2e	; 46
		if(res == 0xfe){
			res = 0x00;
			/* データ格納 */
			for(cnt = offset ; cnt ; cnt--) spi_inout(0xff);					// オフセット移動
			for(; cnt < count ; cnt++) buf[cnt] = spi_inout(0xff);			// 指定バイト読込
			for(cnt = 512 - offset - count ; cnt ; cnt--) spi_inout(0xff);	// 残り移動
    13d8:	01 97       	sbiw	r24, 0x01	; 1
    13da:	00 97       	sbiw	r24, 0x00	; 0
    13dc:	c1 f7       	brne	.-16     	; 0x13ce <sd_read+0xa0>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    13de:	8f ef       	ldi	r24, 0xFF	; 255
    13e0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    13e2:	0d b4       	in	r0, 0x2d	; 45
    13e4:	07 fe       	sbrs	r0, 7
    13e6:	fd cf       	rjmp	.-6      	; 0x13e2 <sd_read+0xb4>
	return SPDR;
    13e8:	8e b5       	in	r24, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    13ea:	8f ef       	ldi	r24, 0xFF	; 255
    13ec:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    13ee:	0d b4       	in	r0, 0x2d	; 45
    13f0:	07 fe       	sbrs	r0, 7
    13f2:	fd cf       	rjmp	.-6      	; 0x13ee <sd_read+0xc0>
	return SPDR;
    13f4:	8e b5       	in	r24, 0x2e	; 46
    13f6:	01 c0       	rjmp	.+2      	; 0x13fa <sd_read+0xcc>
    13f8:	42 2f       	mov	r20, r18
			for(; cnt < count ; cnt++) buf[cnt] = spi_inout(0xff);			// 指定バイト読込
			for(cnt = 512 - offset - count ; cnt ; cnt--) spi_inout(0xff);	// 残り移動
			spi_inout(0xff); spi_inout(0xff);									// CRC読み込み
		}
	}
	SS_H();
    13fa:	2a 9a       	sbi	0x05, 2	; 5
	return res;
}
    13fc:	84 2f       	mov	r24, r20
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	1f 91       	pop	r17
    1404:	0f 91       	pop	r16
    1406:	ff 90       	pop	r15
    1408:	ef 90       	pop	r14
    140a:	df 90       	pop	r13
    140c:	cf 90       	pop	r12
    140e:	bf 90       	pop	r11
    1410:	af 90       	pop	r10
    1412:	08 95       	ret

00001414 <sd_init>:
/* 戻り値：エラーコード(0なら正常終了)*/
/* 引数：ブロック・フラグへのポインタ */
/* 機能：SDカードの初期化処理を行う   */
/*------------------------------------*/
uint8_t sd_init(uint8_t* const block_flg)
{
    1414:	ef 92       	push	r14
    1416:	ff 92       	push	r15
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	7c 01       	movw	r14, r24
	uint16_t cnt;		// 送信カウンタ
	uint8_t	res,		// レスポンス
			type = 0;	// 種類：0:MMC 1:SD1 2:SD2
	/* SPI初期化 */
	DDRB |= _BV(SCK) | _BV(MOSI) | _BV(SS);
    1422:	84 b1       	in	r24, 0x04	; 4
    1424:	8c 62       	ori	r24, 0x2C	; 44
    1426:	84 b9       	out	0x04, r24	; 4
	SPCR = _BV(SPE) | _BV(MSTR) | _BV(SPR1);	// Mode0
    1428:	82 e5       	ldi	r24, 0x52	; 82
    142a:	8c bd       	out	0x2c, r24	; 44
	SPSR = _BV(SPI2X); 							// 1/32 (250kHz)
    142c:	81 e0       	ldi	r24, 0x01	; 1
    142e:	8d bd       	out	0x2d, r24	; 45
	/* コマンド受付準備 */
	SS_H();
    1430:	2a 9a       	sbi	0x05, 2	; 5
    1432:	8a e0       	ldi	r24, 0x0A	; 10
    1434:	90 e0       	ldi	r25, 0x00	; 0
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1436:	2f ef       	ldi	r18, 0xFF	; 255
    1438:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    143a:	0d b4       	in	r0, 0x2d	; 45
    143c:	07 fe       	sbrs	r0, 7
    143e:	fd cf       	rjmp	.-6      	; 0x143a <sd_init+0x26>
	return SPDR;
    1440:	3e b5       	in	r19, 0x2e	; 46
	DDRB |= _BV(SCK) | _BV(MOSI) | _BV(SS);
	SPCR = _BV(SPE) | _BV(MSTR) | _BV(SPR1);	// Mode0
	SPSR = _BV(SPI2X); 							// 1/32 (250kHz)
	/* コマンド受付準備 */
	SS_H();
	for(cnt = 10 ; cnt ; cnt--) spi_inout(0xff);
    1442:	01 97       	sbiw	r24, 0x01	; 1
    1444:	c9 f7       	brne	.-14     	; 0x1438 <sd_init+0x24>
	/* ダミー・ウェイト */
	SS_L();
    1446:	2a 98       	cbi	0x05, 2	; 5
    1448:	88 ee       	ldi	r24, 0xE8	; 232
    144a:	93 e0       	ldi	r25, 0x03	; 3
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    144c:	2f ef       	ldi	r18, 0xFF	; 255
    144e:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    1450:	0d b4       	in	r0, 0x2d	; 45
    1452:	07 fe       	sbrs	r0, 7
    1454:	fd cf       	rjmp	.-6      	; 0x1450 <sd_init+0x3c>
	return SPDR;
    1456:	3e b5       	in	r19, 0x2e	; 46
	/* コマンド受付準備 */
	SS_H();
	for(cnt = 10 ; cnt ; cnt--) spi_inout(0xff);
	/* ダミー・ウェイト */
	SS_L();
	for(cnt = 1000 ; cnt ; cnt--) spi_inout(0xff);
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	c9 f7       	brne	.-14     	; 0x144e <sd_init+0x3a>
    145c:	ca e0       	ldi	r28, 0x0A	; 10
    145e:	d0 e0       	ldi	r29, 0x00	; 0
	/* ソフトウェア・リセット */
	cnt = 10;
	do{
		res = sd_send_cmd(0, 0, 0x4a);
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	40 e0       	ldi	r20, 0x00	; 0
    1464:	50 e0       	ldi	r21, 0x00	; 0
    1466:	60 e0       	ldi	r22, 0x00	; 0
    1468:	70 e0       	ldi	r23, 0x00	; 0
    146a:	2a e4       	ldi	r18, 0x4A	; 74
    146c:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    1470:	18 2f       	mov	r17, r24
	} while(res != 0x01 && --cnt);
    1472:	81 30       	cpi	r24, 0x01	; 1
    1474:	39 f0       	breq	.+14     	; 0x1484 <sd_init+0x70>
    1476:	21 97       	sbiw	r28, 0x01	; 1
    1478:	99 f7       	brne	.-26     	; 0x1460 <sd_init+0x4c>
			if(res == 0x00 && *block_flg == 0) res = sd_send_cmd(16, 512, 0); // ブロック長セット
		
		}
		else res = 0x81;
	}
	else if(res == 0x00) res = 0x80;
    147a:	88 23       	and	r24, r24
    147c:	09 f0       	breq	.+2      	; 0x1480 <sd_init+0x6c>
    147e:	a7 c0       	rjmp	.+334    	; 0x15ce <sd_init+0x1ba>
    1480:	10 e8       	ldi	r17, 0x80	; 128
    1482:	a5 c0       	rjmp	.+330    	; 0x15ce <sd_init+0x1ba>
	do{
		res = sd_send_cmd(0, 0, 0x4a);
	} while(res != 0x01 && --cnt);
	if(res == 0x01){
		/* SDCv2判定 */
		if(
    1484:	88 e0       	ldi	r24, 0x08	; 8
    1486:	4a ea       	ldi	r20, 0xAA	; 170
    1488:	51 e0       	ldi	r21, 0x01	; 1
    148a:	60 e0       	ldi	r22, 0x00	; 0
    148c:	70 e0       	ldi	r23, 0x00	; 0
    148e:	23 e4       	ldi	r18, 0x43	; 67
    1490:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    1494:	82 30       	cpi	r24, 0x02	; 2
    1496:	10 f5       	brcc	.+68     	; 0x14dc <sd_init+0xc8>
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1498:	8f ef       	ldi	r24, 0xFF	; 255
    149a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    149c:	0d b4       	in	r0, 0x2d	; 45
    149e:	07 fe       	sbrs	r0, 7
    14a0:	fd cf       	rjmp	.-6      	; 0x149c <sd_init+0x88>
	return SPDR;
    14a2:	8e b5       	in	r24, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    14a4:	8f ef       	ldi	r24, 0xFF	; 255
    14a6:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    14a8:	0d b4       	in	r0, 0x2d	; 45
    14aa:	07 fe       	sbrs	r0, 7
    14ac:	fd cf       	rjmp	.-6      	; 0x14a8 <sd_init+0x94>
	return SPDR;
    14ae:	8e b5       	in	r24, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    14b0:	8f ef       	ldi	r24, 0xFF	; 255
    14b2:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    14b4:	0d b4       	in	r0, 0x2d	; 45
    14b6:	07 fe       	sbrs	r0, 7
    14b8:	fd cf       	rjmp	.-6      	; 0x14b4 <sd_init+0xa0>
	return SPDR;
    14ba:	3e b5       	in	r19, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    14bc:	8f ef       	ldi	r24, 0xFF	; 255
    14be:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    14c0:	0d b4       	in	r0, 0x2d	; 45
    14c2:	07 fe       	sbrs	r0, 7
    14c4:	fd cf       	rjmp	.-6      	; 0x14c0 <sd_init+0xac>
	return SPDR;
    14c6:	2e b5       	in	r18, 0x2e	; 46
	do{
		res = sd_send_cmd(0, 0, 0x4a);
	} while(res != 0x01 && --cnt);
	if(res == 0x01){
		/* SDCv2判定 */
		if(
    14c8:	93 2f       	mov	r25, r19
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	30 e0       	ldi	r19, 0x00	; 0
    14ce:	82 2b       	or	r24, r18
    14d0:	93 2b       	or	r25, r19
    14d2:	8a 5a       	subi	r24, 0xAA	; 170
    14d4:	91 40       	sbci	r25, 0x01	; 1
    14d6:	11 f4       	brne	.+4      	; 0x14dc <sd_init+0xc8>
    14d8:	02 e0       	ldi	r16, 0x02	; 2
    14da:	18 c0       	rjmp	.+48     	; 0x150c <sd_init+0xf8>
				(spi_inout(0xff) << 8) | spi_inout(0xff) |
				(spi_inout(0xff) & 0x00) | (spi_inout(0xff) & 0x00)
			) == 0x1aa
		) type = 2;
		/* SDCv1判定 */
		else if(sd_send_cmd(55, 0, 0) < 2 && (res = sd_send_cmd(41, 0, 0)) < 2) type = 1;
    14dc:	87 e3       	ldi	r24, 0x37	; 55
    14de:	40 e0       	ldi	r20, 0x00	; 0
    14e0:	50 e0       	ldi	r21, 0x00	; 0
    14e2:	60 e0       	ldi	r22, 0x00	; 0
    14e4:	70 e0       	ldi	r23, 0x00	; 0
    14e6:	20 e0       	ldi	r18, 0x00	; 0
    14e8:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    14ec:	82 30       	cpi	r24, 0x02	; 2
    14ee:	68 f4       	brcc	.+26     	; 0x150a <sd_init+0xf6>
    14f0:	89 e2       	ldi	r24, 0x29	; 41
    14f2:	40 e0       	ldi	r20, 0x00	; 0
    14f4:	50 e0       	ldi	r21, 0x00	; 0
    14f6:	60 e0       	ldi	r22, 0x00	; 0
    14f8:	70 e0       	ldi	r23, 0x00	; 0
    14fa:	20 e0       	ldi	r18, 0x00	; 0
    14fc:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    1500:	18 2f       	mov	r17, r24
    1502:	82 30       	cpi	r24, 0x02	; 2
    1504:	10 f4       	brcc	.+4      	; 0x150a <sd_init+0xf6>
    1506:	01 e0       	ldi	r16, 0x01	; 1
    1508:	01 c0       	rjmp	.+2      	; 0x150c <sd_init+0xf8>
    150a:	00 e0       	ldi	r16, 0x00	; 0
    150c:	c0 e3       	ldi	r28, 0x30	; 48
    150e:	d5 e7       	ldi	r29, 0x75	; 117
    1510:	20 c0       	rjmp	.+64     	; 0x1552 <sd_init+0x13e>
		/* 初期化 */
		cnt = 30000;
		while(res && --cnt){
			res = type ? sd_send_cmd(55, 0, 0) : 0x00;
    1512:	00 23       	and	r16, r16
    1514:	11 f4       	brne	.+4      	; 0x151a <sd_init+0x106>
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	14 c0       	rjmp	.+40     	; 0x1542 <sd_init+0x12e>
    151a:	87 e3       	ldi	r24, 0x37	; 55
    151c:	40 e0       	ldi	r20, 0x00	; 0
    151e:	50 e0       	ldi	r21, 0x00	; 0
    1520:	60 e0       	ldi	r22, 0x00	; 0
    1522:	70 e0       	ldi	r23, 0x00	; 0
    1524:	20 e0       	ldi	r18, 0x00	; 0
    1526:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    152a:	18 2f       	mov	r17, r24
			if(res < 2) res = sd_send_cmd(type ? 41 : 1, (type == 2) ? 1UL << 30 : 0, 0);
    152c:	82 30       	cpi	r24, 0x02	; 2
    152e:	88 f4       	brcc	.+34     	; 0x1552 <sd_init+0x13e>
    1530:	02 30       	cpi	r16, 0x02	; 2
    1532:	31 f4       	brne	.+12     	; 0x1540 <sd_init+0x12c>
    1534:	40 e0       	ldi	r20, 0x00	; 0
    1536:	50 e0       	ldi	r21, 0x00	; 0
    1538:	60 e0       	ldi	r22, 0x00	; 0
    153a:	70 e4       	ldi	r23, 0x40	; 64
    153c:	89 e2       	ldi	r24, 0x29	; 41
    153e:	05 c0       	rjmp	.+10     	; 0x154a <sd_init+0x136>
    1540:	89 e2       	ldi	r24, 0x29	; 41
    1542:	40 e0       	ldi	r20, 0x00	; 0
    1544:	50 e0       	ldi	r21, 0x00	; 0
    1546:	60 e0       	ldi	r22, 0x00	; 0
    1548:	70 e0       	ldi	r23, 0x00	; 0
    154a:	20 e0       	ldi	r18, 0x00	; 0
    154c:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    1550:	18 2f       	mov	r17, r24
		) type = 2;
		/* SDCv1判定 */
		else if(sd_send_cmd(55, 0, 0) < 2 && (res = sd_send_cmd(41, 0, 0)) < 2) type = 1;
		/* 初期化 */
		cnt = 30000;
		while(res && --cnt){
    1552:	11 23       	and	r17, r17
    1554:	21 f0       	breq	.+8      	; 0x155e <sd_init+0x14a>
    1556:	21 97       	sbiw	r28, 0x01	; 1
    1558:	e1 f6       	brne	.-72     	; 0x1512 <sd_init+0xfe>
    155a:	11 e8       	ldi	r17, 0x81	; 129
    155c:	38 c0       	rjmp	.+112    	; 0x15ce <sd_init+0x1ba>
			if(res < 2) res = sd_send_cmd(type ? 41 : 1, (type == 2) ? 1UL << 30 : 0, 0);
		}
		/* 設定 */
		if(res == 0x00){
			/* ブロック・アドレッシング方式判定 */
			res = sd_send_cmd(58, 0, 0);
    155e:	8a e3       	ldi	r24, 0x3A	; 58
    1560:	40 e0       	ldi	r20, 0x00	; 0
    1562:	50 e0       	ldi	r21, 0x00	; 0
    1564:	60 e0       	ldi	r22, 0x00	; 0
    1566:	70 e0       	ldi	r23, 0x00	; 0
    1568:	20 e0       	ldi	r18, 0x00	; 0
    156a:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    156e:	18 2f       	mov	r17, r24
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1570:	8f ef       	ldi	r24, 0xFF	; 255
    1572:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    1574:	0d b4       	in	r0, 0x2d	; 45
    1576:	07 fe       	sbrs	r0, 7
    1578:	fd cf       	rjmp	.-6      	; 0x1574 <sd_init+0x160>
	return SPDR;
    157a:	8e b5       	in	r24, 0x2e	; 46
		}
		/* 設定 */
		if(res == 0x00){
			/* ブロック・アドレッシング方式判定 */
			res = sd_send_cmd(58, 0, 0);
			*block_flg = (spi_inout(0xff) & 0x40) ? 1 : 0;
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	26 e0       	ldi	r18, 0x06	; 6
    1580:	96 95       	lsr	r25
    1582:	87 95       	ror	r24
    1584:	2a 95       	dec	r18
    1586:	e1 f7       	brne	.-8      	; 0x1580 <sd_init+0x16c>
    1588:	98 2f       	mov	r25, r24
    158a:	91 70       	andi	r25, 0x01	; 1
    158c:	f7 01       	movw	r30, r14
    158e:	90 83       	st	Z, r25
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    1590:	8f ef       	ldi	r24, 0xFF	; 255
    1592:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    1594:	0d b4       	in	r0, 0x2d	; 45
    1596:	07 fe       	sbrs	r0, 7
    1598:	fd cf       	rjmp	.-6      	; 0x1594 <sd_init+0x180>
	return SPDR;
    159a:	8e b5       	in	r24, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    159c:	8f ef       	ldi	r24, 0xFF	; 255
    159e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    15a0:	0d b4       	in	r0, 0x2d	; 45
    15a2:	07 fe       	sbrs	r0, 7
    15a4:	fd cf       	rjmp	.-6      	; 0x15a0 <sd_init+0x18c>
	return SPDR;
    15a6:	8e b5       	in	r24, 0x2e	; 46
/* 引数：送信データ                   */
/* 機能：SPIでデータの送受信を行う    */
/*------------------------------------*/
static uint8_t spi_inout(uint8_t d)
{
	SPDR = d;
    15a8:	8f ef       	ldi	r24, 0xFF	; 255
    15aa:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    15ac:	0d b4       	in	r0, 0x2d	; 45
    15ae:	07 fe       	sbrs	r0, 7
    15b0:	fd cf       	rjmp	.-6      	; 0x15ac <sd_init+0x198>
	return SPDR;
    15b2:	8e b5       	in	r24, 0x2e	; 46
		if(res == 0x00){
			/* ブロック・アドレッシング方式判定 */
			res = sd_send_cmd(58, 0, 0);
			*block_flg = (spi_inout(0xff) & 0x40) ? 1 : 0;
			spi_inout(0xff); spi_inout(0xff); spi_inout(0xff);
			if(res == 0x00 && *block_flg == 0) res = sd_send_cmd(16, 512, 0); // ブロック長セット
    15b4:	11 23       	and	r17, r17
    15b6:	59 f4       	brne	.+22     	; 0x15ce <sd_init+0x1ba>
    15b8:	99 23       	and	r25, r25
    15ba:	49 f4       	brne	.+18     	; 0x15ce <sd_init+0x1ba>
    15bc:	80 e1       	ldi	r24, 0x10	; 16
    15be:	40 e0       	ldi	r20, 0x00	; 0
    15c0:	52 e0       	ldi	r21, 0x02	; 2
    15c2:	60 e0       	ldi	r22, 0x00	; 0
    15c4:	70 e0       	ldi	r23, 0x00	; 0
    15c6:	20 e0       	ldi	r18, 0x00	; 0
    15c8:	0e 94 5d 09 	call	0x12ba	; 0x12ba <sd_send_cmd>
    15cc:	18 2f       	mov	r17, r24
		
		}
		else res = 0x81;
	}
	else if(res == 0x00) res = 0x80;
	SS_H();
    15ce:	2a 9a       	sbi	0x05, 2	; 5
	/* クロック変更 */
	SPCR &= ~_BV(SPR1);	// 1/2(4Mhz)
    15d0:	8c b5       	in	r24, 0x2c	; 44
    15d2:	8d 7f       	andi	r24, 0xFD	; 253
    15d4:	8c bd       	out	0x2c, r24	; 44
	return res;
}
    15d6:	81 2f       	mov	r24, r17
    15d8:	df 91       	pop	r29
    15da:	cf 91       	pop	r28
    15dc:	1f 91       	pop	r17
    15de:	0f 91       	pop	r16
    15e0:	ff 90       	pop	r15
    15e2:	ef 90       	pop	r14
    15e4:	08 95       	ret

000015e6 <disk_writep>:
		// Send data to the disk

	}

	return res;
}
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	08 95       	ret

000015ea <disk_readp>:
	BYTE* dest,			/* Pointer to the destination object */
	DWORD sector,		/* Sector number (LBA) */
	WORD sofs,			/* Offset in the sector */
	WORD count			/* Byte count (bit15:destination) */
)
{
    15ea:	0f 93       	push	r16
    15ec:	1f 93       	push	r17
    15ee:	fc 01       	movw	r30, r24
	return sd_read(block_flg ? sector : sector * 512, dest, sofs, count) ? RES_ERROR : RES_OK;
    15f0:	80 91 c5 02 	lds	r24, 0x02C5
    15f4:	88 23       	and	r24, r24
    15f6:	39 f4       	brne	.+14     	; 0x1606 <disk_readp+0x1c>
    15f8:	89 e0       	ldi	r24, 0x09	; 9
    15fa:	44 0f       	add	r20, r20
    15fc:	55 1f       	adc	r21, r21
    15fe:	66 1f       	adc	r22, r22
    1600:	77 1f       	adc	r23, r23
    1602:	8a 95       	dec	r24
    1604:	d1 f7       	brne	.-12     	; 0x15fa <disk_readp+0x10>
    1606:	cb 01       	movw	r24, r22
    1608:	ba 01       	movw	r22, r20
    160a:	af 01       	movw	r20, r30
    160c:	0e 94 97 09 	call	0x132e	; 0x132e <sd_read>
    1610:	81 11       	cpse	r24, r1
    1612:	81 e0       	ldi	r24, 0x01	; 1
}
    1614:	1f 91       	pop	r17
    1616:	0f 91       	pop	r16
    1618:	08 95       	ret

0000161a <disk_initialize>:
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (void)
{
	return sd_init(&block_flg) ? STA_NOINIT : 0;
    161a:	85 ec       	ldi	r24, 0xC5	; 197
    161c:	92 e0       	ldi	r25, 0x02	; 2
    161e:	0e 94 0a 0a 	call	0x1414	; 0x1414 <sd_init>
    1622:	81 11       	cpse	r24, r1
    1624:	81 e0       	ldi	r24, 0x01	; 1
}
    1626:	08 95       	ret

00001628 <ledMatrixCtrl_init>:


/* 初期化 */
void ledMatrixCtrl_init()
{
    DDRD |= _BV(LMC_MOSI) | _BV(LMC_SCLK) | _BV(LMC_SS);
    1628:	8a b1       	in	r24, 0x0a	; 10
    162a:	87 60       	ori	r24, 0x07	; 7
    162c:	8a b9       	out	0x0a, r24	; 10
}
    162e:	08 95       	ret

00001630 <ledMatrixCtrl_enable>:


/* 有効化 */
void ledMatrixCtrl_enable()
{
	LMC_SS_L();
    1630:	5a 98       	cbi	0x0b, 2	; 11
}
    1632:	08 95       	ret

00001634 <ledMatrixCtrl_disable>:


/* 無効化 */
void ledMatrixCtrl_disable()
{
	LMC_SS_H();
    1634:	5a 9a       	sbi	0x0b, 2	; 11
}
    1636:	08 95       	ret

00001638 <writeLine>:
}


/* 1ラインを書き込み */
static void writeLine(uint16_t line)
{
    1638:	ac 01       	movw	r20, r24
    163a:	2f e0       	ldi	r18, 0x0F	; 15
    163c:	30 e0       	ldi	r19, 0x00	; 0
	// データを転送 //
	for(uint8_t col=0; col<LMC_WIDTH_COUNT; col++) {
#if LMC_BITODER == 0
		// MSBFIRST //
		if((line >> (LMC_WIDTH_COUNT - col - 1)) & 0x0001) {
    163e:	ca 01       	movw	r24, r20
    1640:	02 2e       	mov	r0, r18
    1642:	02 c0       	rjmp	.+4      	; 0x1648 <writeLine+0x10>
    1644:	96 95       	lsr	r25
    1646:	87 95       	ror	r24
    1648:	0a 94       	dec	r0
    164a:	e2 f7       	brpl	.-8      	; 0x1644 <writeLine+0xc>
    164c:	80 ff       	sbrs	r24, 0
    164e:	02 c0       	rjmp	.+4      	; 0x1654 <writeLine+0x1c>
			LMC_MOSI_L();
    1650:	58 98       	cbi	0x0b, 0	; 11
    1652:	01 c0       	rjmp	.+2      	; 0x1656 <writeLine+0x1e>
		} else {
			LMC_MOSI_H();
    1654:	58 9a       	sbi	0x0b, 0	; 11
		} else {
			LMC_MOSI_H();
		}
#endif

		LMC_SCLK_H();
    1656:	59 9a       	sbi	0x0b, 1	; 11
		LMC_SCLK_L();
    1658:	59 98       	cbi	0x0b, 1	; 11
    165a:	21 50       	subi	r18, 0x01	; 1
    165c:	30 40       	sbci	r19, 0x00	; 0

/* 1ラインを書き込み */
static void writeLine(uint16_t line)
{
	// データを転送 //
	for(uint8_t col=0; col<LMC_WIDTH_COUNT; col++) {
    165e:	8f ef       	ldi	r24, 0xFF	; 255
    1660:	2f 3f       	cpi	r18, 0xFF	; 255
    1662:	38 07       	cpc	r19, r24
    1664:	61 f7       	brne	.-40     	; 0x163e <writeLine+0x6>
#endif

		LMC_SCLK_H();
		LMC_SCLK_L();
	}
}
    1666:	08 95       	ret

00001668 <ledMatrixCtrl_writeFrameAsync>:
}


/* 1フレームをノンブロッキングで表示 */
uint8_t ledMatrixCtrl_writeFrameAsync(uint16_t *frame)
{
    1668:	1f 93       	push	r17
	static uint8_t row = 0;

	// データを転送 //
	writeLine(frame[row]);
    166a:	10 91 c6 02 	lds	r17, 0x02C6
    166e:	e1 2f       	mov	r30, r17
    1670:	f0 e0       	ldi	r31, 0x00	; 0
    1672:	ee 0f       	add	r30, r30
    1674:	ff 1f       	adc	r31, r31
    1676:	e8 0f       	add	r30, r24
    1678:	f9 1f       	adc	r31, r25
    167a:	80 81       	ld	r24, Z
    167c:	91 81       	ldd	r25, Z+1	; 0x01
    167e:	0e 94 1c 0b 	call	0x1638	; 0x1638 <writeLine>
    1682:	80 e0       	ldi	r24, 0x00	; 0

/* パディングを書き込み */
static inline void writePadding()
{
	for(uint8_t i=0; i<8; i++) {
		LMC_SCLK_H();
    1684:	59 9a       	sbi	0x0b, 1	; 11
		LMC_SCLK_L();
    1686:	59 98       	cbi	0x0b, 1	; 11


/* パディングを書き込み */
static inline void writePadding()
{
	for(uint8_t i=0; i<8; i++) {
    1688:	8f 5f       	subi	r24, 0xFF	; 255
    168a:	88 30       	cpi	r24, 0x08	; 8
    168c:	d9 f7       	brne	.-10     	; 0x1684 <ledMatrixCtrl_writeFrameAsync+0x1c>

	// パディング //
	writePadding();

	// カウンターをインクリメント //
	row = (row + 1) % LMC_HEIGHT_COUNT;
    168e:	81 2f       	mov	r24, r17
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	01 96       	adiw	r24, 0x01	; 1
    1694:	6e e0       	ldi	r22, 0x0E	; 14
    1696:	70 e0       	ldi	r23, 0x00	; 0
    1698:	0e 94 85 19 	call	0x330a	; 0x330a <__divmodhi4>
    169c:	80 93 c6 02 	sts	0x02C6, r24

	return row;
}
    16a0:	1f 91       	pop	r17
    16a2:	08 95       	ret

000016a4 <ledMatrixCtrl_writeFrame>:
}


/* 1フレームをブロッキングで表示 */
uint8_t ledMatrixCtrl_writeFrame(uint16_t *frame)
{
    16a4:	df 92       	push	r13
    16a6:	ef 92       	push	r14
    16a8:	ff 92       	push	r15
    16aa:	0f 93       	push	r16
    16ac:	1f 93       	push	r17
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	8c 01       	movw	r16, r24
    16b4:	c0 e0       	ldi	r28, 0x00	; 0
    16b6:	d0 e0       	ldi	r29, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    16b8:	45 e8       	ldi	r20, 0x85	; 133
    16ba:	d4 2e       	mov	r13, r20
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16bc:	38 e5       	ldi	r19, 0x58	; 88
    16be:	e3 2e       	mov	r14, r19
    16c0:	32 e0       	ldi	r19, 0x02	; 2
    16c2:	f3 2e       	mov	r15, r19
	for(uint8_t row=0; row<LMC_HEIGHT_COUNT; row++) {
		// データを転送 //
		writeLine(frame[row]);
    16c4:	f8 01       	movw	r30, r16
    16c6:	ec 0f       	add	r30, r28
    16c8:	fd 1f       	adc	r31, r29
    16ca:	80 81       	ld	r24, Z
    16cc:	91 81       	ldd	r25, Z+1	; 0x01
    16ce:	0e 94 1c 0b 	call	0x1638	; 0x1638 <writeLine>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    16d2:	8d 2d       	mov	r24, r13
    16d4:	8a 95       	dec	r24
    16d6:	f1 f7       	brne	.-4      	; 0x16d4 <ledMatrixCtrl_writeFrame+0x30>
    16d8:	80 e0       	ldi	r24, 0x00	; 0

/* パディングを書き込み */
static inline void writePadding()
{
	for(uint8_t i=0; i<8; i++) {
		LMC_SCLK_H();
    16da:	59 9a       	sbi	0x0b, 1	; 11
		LMC_SCLK_L();
    16dc:	59 98       	cbi	0x0b, 1	; 11


/* パディングを書き込み */
static inline void writePadding()
{
	for(uint8_t i=0; i<8; i++) {
    16de:	8f 5f       	subi	r24, 0xFF	; 255
    16e0:	88 30       	cpi	r24, 0x08	; 8
    16e2:	d9 f7       	brne	.-10     	; 0x16da <ledMatrixCtrl_writeFrame+0x36>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16e4:	c7 01       	movw	r24, r14
    16e6:	01 97       	sbiw	r24, 0x01	; 1
    16e8:	f1 f7       	brne	.-4      	; 0x16e6 <ledMatrixCtrl_writeFrame+0x42>
    16ea:	22 96       	adiw	r28, 0x02	; 2


/* 1フレームをブロッキングで表示 */
uint8_t ledMatrixCtrl_writeFrame(uint16_t *frame)
{
	for(uint8_t row=0; row<LMC_HEIGHT_COUNT; row++) {
    16ec:	cc 31       	cpi	r28, 0x1C	; 28
    16ee:	d1 05       	cpc	r29, r1
    16f0:	49 f7       	brne	.-46     	; 0x16c4 <ledMatrixCtrl_writeFrame+0x20>
		// 点灯時間 //
		_delay_us(LMC_TIME_ON);
	}

	return 0;
}
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	df 91       	pop	r29
    16f6:	cf 91       	pop	r28
    16f8:	1f 91       	pop	r17
    16fa:	0f 91       	pop	r16
    16fc:	ff 90       	pop	r15
    16fe:	ef 90       	pop	r14
    1700:	df 90       	pop	r13
    1702:	08 95       	ret

00001704 <uart_putchar>:
}


/* UARTで一文字送信 */
int uart_putchar(char c, FILE* unused)
{
    1704:	98 2f       	mov	r25, r24
	while(!(UCSR0A & _BV(UDRE0)));
    1706:	80 91 c0 00 	lds	r24, 0x00C0
    170a:	85 ff       	sbrs	r24, 5
    170c:	fc cf       	rjmp	.-8      	; 0x1706 <uart_putchar+0x2>
	UDR0 = c;
    170e:	90 93 c6 00 	sts	0x00C6, r25
	return 0;
}
    1712:	80 e0       	ldi	r24, 0x00	; 0
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	08 95       	ret

00001718 <usart_init>:


/* UART初期化 */
void usart_init(unsigned int baud)
{
    UBRR0 = F_CPU / 16 / baud - 1;
    1718:	9c 01       	movw	r18, r24
    171a:	40 e0       	ldi	r20, 0x00	; 0
    171c:	50 e0       	ldi	r21, 0x00	; 0
    171e:	60 e2       	ldi	r22, 0x20	; 32
    1720:	71 ea       	ldi	r23, 0xA1	; 161
    1722:	87 e0       	ldi	r24, 0x07	; 7
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	0e 94 98 19 	call	0x3330	; 0x3330 <__udivmodsi4>
    172a:	21 50       	subi	r18, 0x01	; 1
    172c:	30 40       	sbci	r19, 0x00	; 0
    172e:	30 93 c5 00 	sts	0x00C5, r19
    1732:	20 93 c4 00 	sts	0x00C4, r18
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    1736:	88 e1       	ldi	r24, 0x18	; 24
    1738:	80 93 c1 00 	sts	0x00C1, r24

    fdevopen(uart_putchar, NULL);
    173c:	82 e8       	ldi	r24, 0x82	; 130
    173e:	9b e0       	ldi	r25, 0x0B	; 11
    1740:	60 e0       	ldi	r22, 0x00	; 0
    1742:	70 e0       	ldi	r23, 0x00	; 0
    1744:	0e 94 1c 1b 	call	0x3638	; 0x3638 <fdevopen>
}
    1748:	08 95       	ret

0000174a <pushStack>:
	stackP->top = stackP->stack + size;
}


static void
pushStack(stack * const stack, int const value) {
    174a:	dc 01       	movw	r26, r24
	if (stack->sp >= stack->top) {
    174c:	12 96       	adiw	r26, 0x02	; 2
    174e:	ed 91       	ld	r30, X+
    1750:	fc 91       	ld	r31, X
    1752:	13 97       	sbiw	r26, 0x03	; 3
    1754:	14 96       	adiw	r26, 0x04	; 4
    1756:	8d 91       	ld	r24, X+
    1758:	9c 91       	ld	r25, X
    175a:	15 97       	sbiw	r26, 0x05	; 5
    175c:	e8 17       	cp	r30, r24
    175e:	f9 07       	cpc	r31, r25
    1760:	40 f0       	brcs	.+16     	; 0x1772 <pushStack+0x28>
//		printf("stack overflow\n");
		puts("E13");
    1762:	87 e2       	ldi	r24, 0x27	; 39
    1764:	91 e0       	ldi	r25, 0x01	; 1
    1766:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		exit(1);
    176a:	81 e0       	ldi	r24, 0x01	; 1
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
	}
	*(stack->sp++) = value;
    1772:	61 93       	st	Z+, r22
    1774:	71 93       	st	Z+, r23
    1776:	13 96       	adiw	r26, 0x03	; 3
    1778:	fc 93       	st	X, r31
    177a:	ee 93       	st	-X, r30
    177c:	12 97       	sbiw	r26, 0x02	; 2
}
    177e:	08 95       	ret

00001780 <popStack>:
	return stack->sp == stack->stack;
}


static int
popStack(stack * const stack) {
    1780:	dc 01       	movw	r26, r24
	if (stack->sp <= stack->stack) {
    1782:	12 96       	adiw	r26, 0x02	; 2
    1784:	ed 91       	ld	r30, X+
    1786:	fc 91       	ld	r31, X
    1788:	13 97       	sbiw	r26, 0x03	; 3
    178a:	8d 91       	ld	r24, X+
    178c:	9c 91       	ld	r25, X
    178e:	11 97       	sbiw	r26, 0x01	; 1
    1790:	8e 17       	cp	r24, r30
    1792:	9f 07       	cpc	r25, r31
    1794:	40 f0       	brcs	.+16     	; 0x17a6 <popStack+0x26>
//		printf("stack underflow\n");
		puts("E14");
    1796:	8b e2       	ldi	r24, 0x2B	; 43
    1798:	91 e0       	ldi	r25, 0x01	; 1
    179a:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		exit(1);
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
	}
	return *(--stack->sp);
    17a6:	32 97       	sbiw	r30, 0x02	; 2
    17a8:	13 96       	adiw	r26, 0x03	; 3
    17aa:	fc 93       	st	X, r31
    17ac:	ee 93       	st	-X, r30
    17ae:	12 97       	sbiw	r26, 0x02	; 2
}
    17b0:	80 81       	ld	r24, Z
    17b2:	91 81       	ldd	r25, Z+1	; 0x01
    17b4:	08 95       	ret

000017b6 <readColorTable>:
	gifCtrl->transparentIndex = 0;
}


static void
readColorTable(FILE * gifFile, gifColorTable colorTable, uint16_t const colorTableSize) {
    17b6:	8f 92       	push	r8
    17b8:	9f 92       	push	r9
    17ba:	af 92       	push	r10
    17bc:	bf 92       	push	r11
    17be:	cf 92       	push	r12
    17c0:	df 92       	push	r13
    17c2:	ef 92       	push	r14
    17c4:	ff 92       	push	r15
    17c6:	0f 93       	push	r16
    17c8:	1f 93       	push	r17
    17ca:	df 93       	push	r29
    17cc:	cf 93       	push	r28
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <readColorTable+0x1a>
    17d0:	00 d0       	rcall	.+0      	; 0x17d2 <readColorTable+0x1c>
    17d2:	0f 92       	push	r0
    17d4:	cd b7       	in	r28, 0x3d	; 61
    17d6:	de b7       	in	r29, 0x3e	; 62
    17d8:	6a 01       	movw	r12, r20
    17da:	8b 01       	movw	r16, r22
    17dc:	ee 24       	eor	r14, r14
    17de:	ff 24       	eor	r15, r15
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    17e0:	83 e0       	ldi	r24, 0x03	; 3
    17e2:	88 2e       	mov	r8, r24
    17e4:	91 2c       	mov	r9, r1
    17e6:	8c 0e       	add	r8, r28
    17e8:	9d 1e       	adc	r9, r29
    17ea:	5e 01       	movw	r10, r28
    17ec:	08 94       	sec
    17ee:	a1 1c       	adc	r10, r1
    17f0:	b1 1c       	adc	r11, r1
    17f2:	1e c0       	rjmp	.+60     	; 0x1830 <readColorTable+0x7a>
    17f4:	c4 01       	movw	r24, r8
    17f6:	63 e0       	ldi	r22, 0x03	; 3
    17f8:	70 e0       	ldi	r23, 0x00	; 0
    17fa:	a5 01       	movw	r20, r10
    17fc:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
	uint8_t rgb[3];

//	assert(colorTableSize <= MAXCOLORTABLESIZE);

	for (i = 0; i < colorTableSize; ++i) {
		if (!ReadOK(gifFile, rgb, sizeof(rgb))) {
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	89 2b       	or	r24, r25
    1806:	41 f4       	brne	.+16     	; 0x1818 <readColorTable+0x62>
//			printf("Unable to read Color %d from colorTable\n", i);
			puts("E04");
    1808:	8f e2       	ldi	r24, 0x2F	; 47
    180a:	91 e0       	ldi	r25, 0x01	; 1
    180c:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
			exit(1);
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
		}

		colorTable[CM_RED][i] = rgb[0];
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	f8 01       	movw	r30, r16
    181c:	80 83       	st	Z, r24
		colorTable[CM_GRN][i] = rgb[1];
    181e:	8c 81       	ldd	r24, Y+4	; 0x04
    1820:	84 83       	std	Z+4, r24	; 0x04
		colorTable[CM_BLU][i] = rgb[2];
    1822:	8d 81       	ldd	r24, Y+5	; 0x05
    1824:	80 87       	std	Z+8, r24	; 0x08
	uint16_t i;
	uint8_t rgb[3];

//	assert(colorTableSize <= MAXCOLORTABLESIZE);

	for (i = 0; i < colorTableSize; ++i) {
    1826:	08 94       	sec
    1828:	e1 1c       	adc	r14, r1
    182a:	f1 1c       	adc	r15, r1
    182c:	0f 5f       	subi	r16, 0xFF	; 255
    182e:	1f 4f       	sbci	r17, 0xFF	; 255
    1830:	ec 14       	cp	r14, r12
    1832:	fd 04       	cpc	r15, r13
    1834:	f8 f2       	brcs	.-66     	; 0x17f4 <readColorTable+0x3e>

		colorTable[CM_RED][i] = rgb[0];
		colorTable[CM_GRN][i] = rgb[1];
		colorTable[CM_BLU][i] = rgb[2];
	}
}
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	0f 90       	pop	r0
    183e:	0f 90       	pop	r0
    1840:	cf 91       	pop	r28
    1842:	df 91       	pop	r29
    1844:	1f 91       	pop	r17
    1846:	0f 91       	pop	r16
    1848:	ff 90       	pop	r15
    184a:	ef 90       	pop	r14
    184c:	df 90       	pop	r13
    184e:	cf 90       	pop	r12
    1850:	bf 90       	pop	r11
    1852:	af 90       	pop	r10
    1854:	9f 90       	pop	r9
    1856:	8f 90       	pop	r8
    1858:	08 95       	ret

0000185a <getDataBlock>:
static bool zeroDataBlock = false;
/* the most recently read DataBlock was an EOD marker, i.e. had zero length */


static void
getDataBlock(FILE * const gifFile, uint8_t * const buf, bool * const eof, uint8_t * const length) {
    185a:	af 92       	push	r10
    185c:	bf 92       	push	r11
    185e:	cf 92       	push	r12
    1860:	df 92       	push	r13
    1862:	ef 92       	push	r14
    1864:	ff 92       	push	r15
    1866:	0f 93       	push	r16
    1868:	1f 93       	push	r17
    186a:	df 93       	push	r29
    186c:	cf 93       	push	r28
    186e:	00 d0       	rcall	.+0      	; 0x1870 <getDataBlock+0x16>
    1870:	0f 92       	push	r0
    1872:	cd b7       	in	r28, 0x3d	; 61
    1874:	de b7       	in	r29, 0x3e	; 62
    1876:	6b 01       	movw	r12, r22
    1878:	8a 01       	movw	r16, r20
    187a:	79 01       	movw	r14, r18
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    187c:	92 e0       	ldi	r25, 0x02	; 2
    187e:	a9 2e       	mov	r10, r25
    1880:	b1 2c       	mov	r11, r1
    1882:	ac 0e       	add	r10, r28
    1884:	bd 1e       	adc	r11, r29
    1886:	ce 01       	movw	r24, r28
    1888:	01 96       	adiw	r24, 0x01	; 1
    188a:	61 e0       	ldi	r22, 0x01	; 1
    188c:	70 e0       	ldi	r23, 0x00	; 0
    188e:	a5 01       	movw	r20, r10
    1890:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>

	 We return *eof == false if we don't hit EOF or have an I/O error.
	 -----------------------------------------------------------------------------*/
	uint8_t count;

	if (!ReadOK(gifFile, &count, 1)) {
    1894:	8a 81       	ldd	r24, Y+2	; 0x02
    1896:	9b 81       	ldd	r25, Y+3	; 0x03
    1898:	89 2b       	or	r24, r25
    189a:	51 f4       	brne	.+20     	; 0x18b0 <getDataBlock+0x56>
//		printf("EOF or error in reading DataBlock size from file\n" );
		puts("E05");
    189c:	83 e3       	ldi	r24, 0x33	; 51
    189e:	91 e0       	ldi	r25, 0x01	; 1
    18a0:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		*eof = true;
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	f8 01       	movw	r30, r16
    18a8:	80 83       	st	Z, r24
		*length = 0;
    18aa:	f7 01       	movw	r30, r14
    18ac:	10 82       	st	Z, r1
    18ae:	1e c0       	rjmp	.+60     	; 0x18ec <getDataBlock+0x92>
	} else {
		*eof = false;
    18b0:	f8 01       	movw	r30, r16
    18b2:	10 82       	st	Z, r1
		*length = count;
    18b4:	69 81       	ldd	r22, Y+1	; 0x01
    18b6:	f7 01       	movw	r30, r14
    18b8:	60 83       	st	Z, r22

		if (count == 0) {
    18ba:	66 23       	and	r22, r22
    18bc:	21 f4       	brne	.+8      	; 0x18c6 <getDataBlock+0x6c>
			zeroDataBlock = true;
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	80 93 c7 02 	sts	0x02C7, r24
    18c4:	13 c0       	rjmp	.+38     	; 0x18ec <getDataBlock+0x92>
		} else {
			zeroDataBlock = false;
    18c6:	10 92 c7 02 	sts	0x02C7, r1
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    18ca:	c6 01       	movw	r24, r12
    18cc:	70 e0       	ldi	r23, 0x00	; 0
    18ce:	a5 01       	movw	r20, r10
    18d0:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
		if (count == 0) {
			zeroDataBlock = true;
		} else {
			zeroDataBlock = false;

			if (!ReadOK(gifFile, buf, count)) {
    18d4:	8a 81       	ldd	r24, Y+2	; 0x02
    18d6:	9b 81       	ldd	r25, Y+3	; 0x03
    18d8:	89 2b       	or	r24, r25
    18da:	41 f4       	brne	.+16     	; 0x18ec <getDataBlock+0x92>
//				printf("EOF or error reading data portion of %d byte DataBlock from file\n", count);
				puts("E06");
    18dc:	87 e3       	ldi	r24, 0x37	; 55
    18de:	91 e0       	ldi	r25, 0x01	; 1
    18e0:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
				exit(1);
    18e4:	81 e0       	ldi	r24, 0x01	; 1
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
			}
		}
	}
}
    18ec:	0f 90       	pop	r0
    18ee:	0f 90       	pop	r0
    18f0:	0f 90       	pop	r0
    18f2:	cf 91       	pop	r28
    18f4:	df 91       	pop	r29
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	ff 90       	pop	r15
    18fc:	ef 90       	pop	r14
    18fe:	df 90       	pop	r13
    1900:	cf 90       	pop	r12
    1902:	bf 90       	pop	r11
    1904:	af 90       	pop	r10
    1906:	08 95       	ret

00001908 <readThroughEod>:


static void
readThroughEod(FILE * const gifFile) {
    1908:	af 92       	push	r10
    190a:	bf 92       	push	r11
    190c:	cf 92       	push	r12
    190e:	df 92       	push	r13
    1910:	ef 92       	push	r14
    1912:	ff 92       	push	r15
    1914:	0f 93       	push	r16
    1916:	1f 93       	push	r17
    1918:	df 93       	push	r29
    191a:	cf 93       	push	r28
    191c:	cd b7       	in	r28, 0x3d	; 61
    191e:	de b7       	in	r29, 0x3e	; 62
    1920:	c2 50       	subi	r28, 0x02	; 2
    1922:	d1 40       	sbci	r29, 0x01	; 1
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	f8 94       	cli
    1928:	de bf       	out	0x3e, r29	; 62
    192a:	0f be       	out	0x3f, r0	; 63
    192c:	cd bf       	out	0x3d, r28	; 61
    192e:	8c 01       	movw	r16, r24

	eod = false;
	while (!eod) {
		bool eof;

		getDataBlock(gifFile, buf, &eof, &count);
    1930:	33 e0       	ldi	r19, 0x03	; 3
    1932:	a3 2e       	mov	r10, r19
    1934:	b1 2c       	mov	r11, r1
    1936:	ac 0e       	add	r10, r28
    1938:	bd 1e       	adc	r11, r29
    193a:	22 e0       	ldi	r18, 0x02	; 2
    193c:	c2 2e       	mov	r12, r18
    193e:	d1 2c       	mov	r13, r1
    1940:	cc 0e       	add	r12, r28
    1942:	dd 1e       	adc	r13, r29
    1944:	7e 01       	movw	r14, r28
    1946:	08 94       	sec
    1948:	e1 1c       	adc	r14, r1
    194a:	f1 1c       	adc	r15, r1
    194c:	c8 01       	movw	r24, r16
    194e:	b5 01       	movw	r22, r10
    1950:	a6 01       	movw	r20, r12
    1952:	97 01       	movw	r18, r14
    1954:	0e 94 2d 0c 	call	0x185a	; 0x185a <getDataBlock>
		if (eof) {
    1958:	8a 81       	ldd	r24, Y+2	; 0x02
    195a:	88 23       	and	r24, r24
    195c:	21 f0       	breq	.+8      	; 0x1966 <readThroughEod+0x5e>
//			printf("EOF encountered before EOD marker.  The GIF file is malformed, but we are proceeding "
//					"anyway as if an EOD marker were at the end of the file.\n");
			puts("E07");
    195e:	8b e3       	ldi	r24, 0x3B	; 59
    1960:	91 e0       	ldi	r25, 0x01	; 1
    1962:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		}
		if (eof || count == 0) {
    1966:	8a 81       	ldd	r24, Y+2	; 0x02
    1968:	88 23       	and	r24, r24
    196a:	19 f4       	brne	.+6      	; 0x1972 <readThroughEod+0x6a>
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	88 23       	and	r24, r24
    1970:	69 f7       	brne	.-38     	; 0x194c <readThroughEod+0x44>
			eod = true;
		}
	}
}
    1972:	ce 5f       	subi	r28, 0xFE	; 254
    1974:	de 4f       	sbci	r29, 0xFE	; 254
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	f8 94       	cli
    197a:	de bf       	out	0x3e, r29	; 62
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	cd bf       	out	0x3d, r28	; 61
    1980:	cf 91       	pop	r28
    1982:	df 91       	pop	r29
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	ef 90       	pop	r14
    198c:	df 90       	pop	r13
    198e:	cf 90       	pop	r12
    1990:	bf 90       	pop	r11
    1992:	af 90       	pop	r10
    1994:	08 95       	ret

00001996 <doGraphicControlExtension>:
//	}
//}


static void 
doGraphicControlExtension(FILE * const gifFile, gifCtrl * const gifCtrl) {
    1996:	ef 92       	push	r14
    1998:	ff 92       	push	r15
    199a:	0f 93       	push	r16
    199c:	1f 93       	push	r17
    199e:	df 93       	push	r29
    19a0:	cf 93       	push	r28
    19a2:	cd b7       	in	r28, 0x3d	; 61
    19a4:	de b7       	in	r29, 0x3e	; 62
    19a6:	c2 50       	subi	r28, 0x02	; 2
    19a8:	d1 40       	sbci	r29, 0x01	; 1
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	de bf       	out	0x3e, r29	; 62
    19b0:	0f be       	out	0x3f, r0	; 63
    19b2:	cd bf       	out	0x3d, r28	; 61
    19b4:	7c 01       	movw	r14, r24
    19b6:	8b 01       	movw	r16, r22
	uint8_t buf[256];
	uint8_t length;
	bool eof;

	getDataBlock(gifFile, buf, &eof, &length);
    19b8:	be 01       	movw	r22, r28
    19ba:	6d 5f       	subi	r22, 0xFD	; 253
    19bc:	7f 4f       	sbci	r23, 0xFF	; 255
    19be:	ae 01       	movw	r20, r28
    19c0:	4e 5f       	subi	r20, 0xFE	; 254
    19c2:	5f 4f       	sbci	r21, 0xFF	; 255
    19c4:	9e 01       	movw	r18, r28
    19c6:	2f 5f       	subi	r18, 0xFF	; 255
    19c8:	3f 4f       	sbci	r19, 0xFF	; 255
    19ca:	0e 94 2d 0c 	call	0x185a	; 0x185a <getDataBlock>
	if (eof) {
    19ce:	8a 81       	ldd	r24, Y+2	; 0x02
    19d0:	88 23       	and	r24, r24
    19d2:	19 f0       	breq	.+6      	; 0x19da <doGraphicControlExtension+0x44>
//		printf("EOF/error encountered reading "
//				"1st DataBlock of Graphic Control Extension.\n");
		puts("E08");
    19d4:	8f e3       	ldi	r24, 0x3F	; 63
    19d6:	91 e0       	ldi	r25, 0x01	; 1
    19d8:	05 c0       	rjmp	.+10     	; 0x19e4 <doGraphicControlExtension+0x4e>
		exit(1);
	} else if (length < 4) {
    19da:	89 81       	ldd	r24, Y+1	; 0x01
    19dc:	84 30       	cpi	r24, 0x04	; 4
    19de:	40 f4       	brcc	.+16     	; 0x19f0 <doGraphicControlExtension+0x5a>
//		printf("graphic control extension 1st DataBlock too short.  "
//				"It must be at least 4 bytes; it is %d bytes.\n", length);
		puts("E09");
    19e0:	83 e4       	ldi	r24, 0x43	; 67
    19e2:	91 e0       	ldi	r25, 0x01	; 1
    19e4:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		exit(1);
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
	} else {
		gifCtrl->disposal = (buf[0] >> 2) & 0x07;
    19f0:	4b 81       	ldd	r20, Y+3	; 0x03
    19f2:	84 2f       	mov	r24, r20
    19f4:	86 95       	lsr	r24
    19f6:	86 95       	lsr	r24
    19f8:	87 70       	andi	r24, 0x07	; 7
    19fa:	f8 01       	movw	r30, r16
    19fc:	80 83       	st	Z, r24
		gifCtrl->userInput = (buf[0] >> 1) & 0x01;
    19fe:	84 2f       	mov	r24, r20
    1a00:	86 95       	lsr	r24
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	81 70       	andi	r24, 0x01	; 1
    1a06:	90 70       	andi	r25, 0x00	; 0
    1a08:	81 83       	std	Z+1, r24	; 0x01
		gifCtrl->delayTime = LM_to_uint(buf[1],buf[2]);
    1a0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a0c:	80 e0       	ldi	r24, 0x00	; 0
    1a0e:	2c 81       	ldd	r18, Y+4	; 0x04
    1a10:	30 e0       	ldi	r19, 0x00	; 0
    1a12:	82 2b       	or	r24, r18
    1a14:	93 2b       	or	r25, r19
    1a16:	93 83       	std	Z+3, r25	; 0x03
    1a18:	82 83       	std	Z+2, r24	; 0x02
		gifCtrl->useTransparent = buf[0] & 0x01;
    1a1a:	50 e0       	ldi	r21, 0x00	; 0
    1a1c:	41 70       	andi	r20, 0x01	; 1
    1a1e:	50 70       	andi	r21, 0x00	; 0
    1a20:	44 83       	std	Z+4, r20	; 0x04
		gifCtrl->transparentIndex = buf[3];
    1a22:	8e 81       	ldd	r24, Y+6	; 0x06
    1a24:	85 83       	std	Z+5, r24	; 0x05

		readThroughEod(gifFile);
    1a26:	c7 01       	movw	r24, r14
    1a28:	0e 94 84 0c 	call	0x1908	; 0x1908 <readThroughEod>
	}
}
    1a2c:	ce 5f       	subi	r28, 0xFE	; 254
    1a2e:	de 4f       	sbci	r29, 0xFE	; 254
    1a30:	0f b6       	in	r0, 0x3f	; 63
    1a32:	f8 94       	cli
    1a34:	de bf       	out	0x3e, r29	; 62
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	cd bf       	out	0x3d, r28	; 61
    1a3a:	cf 91       	pop	r28
    1a3c:	df 91       	pop	r29
    1a3e:	1f 91       	pop	r17
    1a40:	0f 91       	pop	r16
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	08 95       	ret

00001a48 <getCode>:
	}
}


static int
getCode(FILE * const gifFile, int const codeSize, bool const init) {
    1a48:	3f 92       	push	r3
    1a4a:	4f 92       	push	r4
    1a4c:	5f 92       	push	r5
    1a4e:	6f 92       	push	r6
    1a50:	7f 92       	push	r7
    1a52:	8f 92       	push	r8
    1a54:	9f 92       	push	r9
    1a56:	af 92       	push	r10
    1a58:	bf 92       	push	r11
    1a5a:	cf 92       	push	r12
    1a5c:	df 92       	push	r13
    1a5e:	ef 92       	push	r14
    1a60:	ff 92       	push	r15
    1a62:	0f 93       	push	r16
    1a64:	1f 93       	push	r17
    1a66:	df 93       	push	r29
    1a68:	cf 93       	push	r28
    1a6a:	00 d0       	rcall	.+0      	; 0x1a6c <getCode+0x24>
    1a6c:	cd b7       	in	r28, 0x3d	; 61
    1a6e:	de b7       	in	r29, 0x3e	; 62
    1a70:	8c 01       	movw	r16, r24
    1a72:	3b 01       	movw	r6, r22
	  -----------------------------------------------------------------------------*/
	static getCodeState getCodeState;

	int retval;

	if (init) {
    1a74:	44 23       	and	r20, r20
    1a76:	09 f4       	brne	.+2      	; 0x1a7a <getCode+0x32>
    1a78:	57 c0       	rjmp	.+174    	; 0x1b28 <getCode+0xe0>


static void
initGetCode(getCodeState * const getCodeState) {
	/* Fake a previous data block */
	getCodeState->buf[0] = 0;
    1a7a:	10 92 c8 02 	sts	0x02C8, r1
	getCodeState->buf[1] = 0;
    1a7e:	10 92 c9 02 	sts	0x02C9, r1
	getCodeState->bufCount = 2;
    1a82:	82 e0       	ldi	r24, 0x02	; 2
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	90 93 aa 03 	sts	0x03AA, r25
    1a8a:	80 93 a9 03 	sts	0x03A9, r24
	getCodeState->curbit = getCodeState->bufCount * 8;
    1a8e:	80 e1       	ldi	r24, 0x10	; 16
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	90 93 ac 03 	sts	0x03AC, r25
    1a96:	80 93 ab 03 	sts	0x03AB, r24
	getCodeState->streamExhausted = false;
    1a9a:	10 92 ad 03 	sts	0x03AD, r1
    1a9e:	ee 24       	eor	r14, r14
    1aa0:	ff 24       	eor	r15, r15
    1aa2:	9f c0       	rjmp	.+318    	; 0x1be2 <getCode+0x19a>
	/* Shift buffer down so last two bytes are now the
	   first two bytes.  Shift 'curbit' cursor, which must
	   be somewhere in or immediately after those two
	   bytes, accordingly.
	 */
	getCodeState->buf[0] = getCodeState->buf[getCodeState->bufCount - 2];
    1aa4:	fa 01       	movw	r30, r20
    1aa6:	e8 53       	subi	r30, 0x38	; 56
    1aa8:	fd 4f       	sbci	r31, 0xFD	; 253
    1aaa:	32 97       	sbiw	r30, 0x02	; 2
    1aac:	81 91       	ld	r24, Z+
    1aae:	80 93 c8 02 	sts	0x02C8, r24
	getCodeState->buf[1] = getCodeState->buf[getCodeState->bufCount - 1];
    1ab2:	80 81       	ld	r24, Z
    1ab4:	80 93 c9 02 	sts	0x02C9, r24

	getCodeState->curbit -= (getCodeState->bufCount - 2) * 8;
    1ab8:	c7 01       	movw	r24, r14
    1aba:	84 1b       	sub	r24, r20
    1abc:	95 0b       	sbc	r25, r21
    1abe:	f3 e0       	ldi	r31, 0x03	; 3
    1ac0:	88 0f       	add	r24, r24
    1ac2:	99 1f       	adc	r25, r25
    1ac4:	fa 95       	dec	r31
    1ac6:	e1 f7       	brne	.-8      	; 0x1ac0 <getCode+0x78>
    1ac8:	8a 0d       	add	r24, r10
    1aca:	9b 1d       	adc	r25, r11
    1acc:	90 93 ac 03 	sts	0x03AC, r25
    1ad0:	80 93 ab 03 	sts	0x03AB, r24
	getCodeState->bufCount = 2;
    1ad4:	f0 92 aa 03 	sts	0x03AA, r15
    1ad8:	e0 92 a9 03 	sts	0x03A9, r14

	/* Add the next block to the buffer */
	getDataBlock(gifFile, &getCodeState->buf[getCodeState->bufCount], &eof, &count);
    1adc:	c8 01       	movw	r24, r16
    1ade:	6a ec       	ldi	r22, 0xCA	; 202
    1ae0:	72 e0       	ldi	r23, 0x02	; 2
    1ae2:	a2 01       	movw	r20, r4
    1ae4:	96 01       	movw	r18, r12
    1ae6:	0e 94 2d 0c 	call	0x185a	; 0x185a <getDataBlock>
	if (eof) {
    1aea:	8a 81       	ldd	r24, Y+2	; 0x02
    1aec:	88 23       	and	r24, r24
    1aee:	39 f0       	breq	.+14     	; 0x1afe <getCode+0xb6>
//		printf("EOF encountered in image before EOD marker.  The GIF file is malformed, but we are proceeding "
//				"anyway as if an EOD marker were at the end of the file.\n");
		puts("E10");
    1af0:	87 e4       	ldi	r24, 0x47	; 71
    1af2:	91 e0       	ldi	r25, 0x01	; 1
    1af4:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
    1af8:	20 e0       	ldi	r18, 0x00	; 0
    1afa:	30 e0       	ldi	r19, 0x00	; 0
    1afc:	03 c0       	rjmp	.+6      	; 0x1b04 <getCode+0xbc>
		assumed_count = 0;
	} else {
		assumed_count = count;
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	28 2f       	mov	r18, r24
    1b02:	30 e0       	ldi	r19, 0x00	; 0
	}

	getCodeState->streamExhausted = (assumed_count == 0);
    1b04:	10 92 ad 03 	sts	0x03AD, r1
    1b08:	21 15       	cp	r18, r1
    1b0a:	31 05       	cpc	r19, r1
    1b0c:	11 f4       	brne	.+4      	; 0x1b12 <getCode+0xca>
    1b0e:	30 92 ad 03 	sts	0x03AD, r3
	getCodeState->bufCount += assumed_count;
    1b12:	80 91 a9 03 	lds	r24, 0x03A9
    1b16:	90 91 aa 03 	lds	r25, 0x03AA
    1b1a:	28 0f       	add	r18, r24
    1b1c:	39 1f       	adc	r19, r25
    1b1e:	30 93 aa 03 	sts	0x03AA, r19
    1b22:	20 93 a9 03 	sts	0x03A9, r18
    1b26:	0e c0       	rjmp	.+28     	; 0x1b44 <getCode+0xfc>
	   bytes, accordingly.
	 */
	getCodeState->buf[0] = getCodeState->buf[getCodeState->bufCount - 2];
	getCodeState->buf[1] = getCodeState->buf[getCodeState->bufCount - 1];

	getCodeState->curbit -= (getCodeState->bufCount - 2) * 8;
    1b28:	e2 e0       	ldi	r30, 0x02	; 2
    1b2a:	ee 2e       	mov	r14, r30
    1b2c:	f1 2c       	mov	r15, r1
	getCodeState->bufCount = 2;

	/* Add the next block to the buffer */
	getDataBlock(gifFile, &getCodeState->buf[getCodeState->bufCount], &eof, &count);
    1b2e:	72 e0       	ldi	r23, 0x02	; 2
    1b30:	47 2e       	mov	r4, r23
    1b32:	51 2c       	mov	r5, r1
    1b34:	4c 0e       	add	r4, r28
    1b36:	5d 1e       	adc	r5, r29
    1b38:	6e 01       	movw	r12, r28
    1b3a:	08 94       	sec
    1b3c:	c1 1c       	adc	r12, r1
    1b3e:	d1 1c       	adc	r13, r1
		assumed_count = 0;
	} else {
		assumed_count = count;
	}

	getCodeState->streamExhausted = (assumed_count == 0);
    1b40:	33 24       	eor	r3, r3
    1b42:	33 94       	inc	r3


static void
doGetCode(FILE * const gifFile, int const codeSize, getCodeState * const getCodeState, int * const retval) {

	while (getCodeState->curbit + codeSize > getCodeState->bufCount * 8 && !getCodeState->streamExhausted) 
    1b44:	a0 90 ab 03 	lds	r10, 0x03AB
    1b48:	b0 90 ac 03 	lds	r11, 0x03AC
    1b4c:	43 01       	movw	r8, r6
    1b4e:	8a 0c       	add	r8, r10
    1b50:	9b 1c       	adc	r9, r11
    1b52:	40 91 a9 03 	lds	r20, 0x03A9
    1b56:	50 91 aa 03 	lds	r21, 0x03AA
    1b5a:	9a 01       	movw	r18, r20
    1b5c:	63 e0       	ldi	r22, 0x03	; 3
    1b5e:	22 0f       	add	r18, r18
    1b60:	33 1f       	adc	r19, r19
    1b62:	6a 95       	dec	r22
    1b64:	e1 f7       	brne	.-8      	; 0x1b5e <getCode+0x116>
    1b66:	28 15       	cp	r18, r8
    1b68:	39 05       	cpc	r19, r9
    1b6a:	34 f4       	brge	.+12     	; 0x1b78 <getCode+0x130>
    1b6c:	80 91 ad 03 	lds	r24, 0x03AD
    1b70:	88 23       	and	r24, r24
    1b72:	09 f4       	brne	.+2      	; 0x1b76 <getCode+0x12e>
    1b74:	97 cf       	rjmp	.-210    	; 0x1aa4 <getCode+0x5c>
    1b76:	4a c0       	rjmp	.+148    	; 0x1c0c <getCode+0x1c4>
    1b78:	ee 24       	eor	r14, r14
    1b7a:	ff 24       	eor	r15, r15
    1b7c:	cc 24       	eor	r12, r12
    1b7e:	dd 24       	eor	r13, r13
    1b80:	26 c0       	rjmp	.+76     	; 0x1bce <getCode+0x186>

		int const bitsUnused = getCodeState->bufCount * 8 - getCodeState->curbit;
		if (bitsUnused > 0) {
//			printf("Stream ends with a partial code (%d bits left in file; "
//					"expected a %d bit code).  Ignoring.\n", bitsUnused, codeSize);
			puts("E11");
    1b82:	8b e4       	ldi	r24, 0x4B	; 75
    1b84:	91 e0       	ldi	r25, 0x01	; 1
    1b86:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
    1b8a:	46 c0       	rjmp	.+140    	; 0x1c18 <getCode+0x1d0>
		int code;
		uint8_t * const buf = getCodeState->buf;

		code = 0;  /* initial value */
		for (i = getCodeState->curbit, j = 0; j < codeSize; ++i, ++j) {
			code |= ((buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;
    1b8c:	c8 01       	movw	r24, r16
    1b8e:	68 e0       	ldi	r22, 0x08	; 8
    1b90:	70 e0       	ldi	r23, 0x00	; 0
    1b92:	0e 94 85 19 	call	0x330a	; 0x330a <__divmodhi4>
    1b96:	fb 01       	movw	r30, r22
    1b98:	e8 53       	subi	r30, 0x38	; 56
    1b9a:	fd 4f       	sbci	r31, 0xFD	; 253
    1b9c:	20 81       	ld	r18, Z
    1b9e:	30 e0       	ldi	r19, 0x00	; 0
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	68 e0       	ldi	r22, 0x08	; 8
    1ba4:	70 e0       	ldi	r23, 0x00	; 0
    1ba6:	0e 94 85 19 	call	0x330a	; 0x330a <__divmodhi4>
    1baa:	02 c0       	rjmp	.+4      	; 0x1bb0 <getCode+0x168>
    1bac:	35 95       	asr	r19
    1bae:	27 95       	ror	r18
    1bb0:	8a 95       	dec	r24
    1bb2:	e2 f7       	brpl	.-8      	; 0x1bac <getCode+0x164>
    1bb4:	21 70       	andi	r18, 0x01	; 1
    1bb6:	30 70       	andi	r19, 0x00	; 0
    1bb8:	0c 2c       	mov	r0, r12
    1bba:	02 c0       	rjmp	.+4      	; 0x1bc0 <getCode+0x178>
    1bbc:	22 0f       	add	r18, r18
    1bbe:	33 1f       	adc	r19, r19
    1bc0:	0a 94       	dec	r0
    1bc2:	e2 f7       	brpl	.-8      	; 0x1bbc <getCode+0x174>
    1bc4:	e2 2a       	or	r14, r18
    1bc6:	f3 2a       	or	r15, r19
		int i, j;
		int code;
		uint8_t * const buf = getCodeState->buf;

		code = 0;  /* initial value */
		for (i = getCodeState->curbit, j = 0; j < codeSize; ++i, ++j) {
    1bc8:	08 94       	sec
    1bca:	c1 1c       	adc	r12, r1
    1bcc:	d1 1c       	adc	r13, r1
	}
}


static int
getCode(FILE * const gifFile, int const codeSize, bool const init) {
    1bce:	86 01       	movw	r16, r12
    1bd0:	0a 0d       	add	r16, r10
    1bd2:	1b 1d       	adc	r17, r11
		int i, j;
		int code;
		uint8_t * const buf = getCodeState->buf;

		code = 0;  /* initial value */
		for (i = getCodeState->curbit, j = 0; j < codeSize; ++i, ++j) {
    1bd4:	c6 14       	cp	r12, r6
    1bd6:	d7 04       	cpc	r13, r7
    1bd8:	cc f2       	brlt	.-78     	; 0x1b8c <getCode+0x144>
			code |= ((buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;
		}
		getCodeState->curbit += codeSize;
    1bda:	90 92 ac 03 	sts	0x03AC, r9
    1bde:	80 92 ab 03 	sts	0x03AB, r8
		retval = 0;
	} else {
		doGetCode(gifFile, codeSize, &getCodeState, &retval);
	}
	return retval;
}
    1be2:	c7 01       	movw	r24, r14
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
    1be8:	cf 91       	pop	r28
    1bea:	df 91       	pop	r29
    1bec:	1f 91       	pop	r17
    1bee:	0f 91       	pop	r16
    1bf0:	ff 90       	pop	r15
    1bf2:	ef 90       	pop	r14
    1bf4:	df 90       	pop	r13
    1bf6:	cf 90       	pop	r12
    1bf8:	bf 90       	pop	r11
    1bfa:	af 90       	pop	r10
    1bfc:	9f 90       	pop	r9
    1bfe:	8f 90       	pop	r8
    1c00:	7f 90       	pop	r7
    1c02:	6f 90       	pop	r6
    1c04:	5f 90       	pop	r5
    1c06:	4f 90       	pop	r4
    1c08:	3f 90       	pop	r3
    1c0a:	08 95       	ret
		   there were no data blocks left to read.
		 */
		*retval = -1;  /* EOF */

		int const bitsUnused = getCodeState->bufCount * 8 - getCodeState->curbit;
		if (bitsUnused > 0) {
    1c0c:	2a 19       	sub	r18, r10
    1c0e:	3b 09       	sbc	r19, r11
    1c10:	12 16       	cp	r1, r18
    1c12:	13 06       	cpc	r1, r19
    1c14:	0c f4       	brge	.+2      	; 0x1c18 <getCode+0x1d0>
    1c16:	b5 cf       	rjmp	.-150    	; 0x1b82 <getCode+0x13a>
    1c18:	ee 24       	eor	r14, r14
    1c1a:	ea 94       	dec	r14
    1c1c:	fe 2c       	mov	r15, r14
    1c1e:	e1 cf       	rjmp	.-62     	; 0x1be2 <getCode+0x19a>

00001c20 <lzwReadByte>:
	decomp->prevcode = incode;
}


static int
lzwReadByte(decompressor * const decomp) {
    1c20:	6f 92       	push	r6
    1c22:	7f 92       	push	r7
    1c24:	8f 92       	push	r8
    1c26:	9f 92       	push	r9
    1c28:	af 92       	push	r10
    1c2a:	bf 92       	push	r11
    1c2c:	cf 92       	push	r12
    1c2e:	df 92       	push	r13
    1c30:	ef 92       	push	r14
    1c32:	ff 92       	push	r15
    1c34:	0f 93       	push	r16
    1c36:	1f 93       	push	r17
    1c38:	cf 93       	push	r28
    1c3a:	df 93       	push	r29
    1c3c:	ec 01       	movw	r28, r24
		} else {
			retval = decomp->firstcode;
		}
	} else {
		int code;
		code = getCode(decomp->gifFile, decomp->codeSize, false);
    1c3e:	f2 e1       	ldi	r31, 0x12	; 18
    1c40:	cf 2e       	mov	r12, r31
    1c42:	f1 e0       	ldi	r31, 0x01	; 1
    1c44:	df 2e       	mov	r13, r31
    1c46:	c8 0e       	add	r12, r24
    1c48:	d9 1e       	adc	r13, r25
		if (code == -1) {
			retval = -1;
		} else {
//			assert(code >= 0);  /* -1 is only possible error return */
			if (code == decomp->clear_code) {
    1c4a:	e7 e1       	ldi	r30, 0x17	; 23
    1c4c:	8e 2e       	mov	r8, r30
    1c4e:	e1 e0       	ldi	r30, 0x01	; 1
    1c50:	9e 2e       	mov	r9, r30
    1c52:	88 0e       	add	r8, r24
    1c54:	99 1e       	adc	r9, r25
} decompressor;


static void
resetDecompressor(decompressor * const decomp) {
	decomp->codeSize = decomp->init_codeSize+1;
    1c56:	74 e1       	ldi	r23, 0x14	; 20
    1c58:	a7 2e       	mov	r10, r23
    1c5a:	71 e0       	ldi	r23, 0x01	; 1
    1c5c:	b7 2e       	mov	r11, r23
    1c5e:	a8 0e       	add	r10, r24
    1c60:	b9 1e       	adc	r11, r25
	decomp->maxnum_code = 1 << decomp->codeSize;
    1c62:	61 e0       	ldi	r22, 0x01	; 1
    1c64:	66 2e       	mov	r6, r22
    1c66:	71 2c       	mov	r7, r1
	decomp->next_tableSlot = decomp->max_dataVal + 3;
    1c68:	55 e1       	ldi	r21, 0x15	; 21
    1c6a:	e5 2e       	mov	r14, r21
    1c6c:	51 e0       	ldi	r21, 0x01	; 1
    1c6e:	f5 2e       	mov	r15, r21
    1c70:	e8 0e       	add	r14, r24
    1c72:	f9 1e       	adc	r15, r25

	  Return -3 if we encounter errors in the LZW stream.
	  -----------------------------------------------------------------------------*/
	int retval;

	if (!stackIsEmpty(&decomp->stack)) {
    1c74:	2a 81       	ldd	r18, Y+2	; 0x02
    1c76:	3b 81       	ldd	r19, Y+3	; 0x03
    1c78:	88 81       	ld	r24, Y
    1c7a:	99 81       	ldd	r25, Y+1	; 0x01
    1c7c:	28 17       	cp	r18, r24
    1c7e:	39 07       	cpc	r19, r25
    1c80:	11 f0       	breq	.+4      	; 0x1c86 <lzwReadByte+0x66>
		retval = popStack(&decomp->stack);
    1c82:	ce 01       	movw	r24, r28
    1c84:	06 c1       	rjmp	.+524    	; 0x1e92 <lzwReadByte+0x272>
	} else if (decomp->fresh) {
    1c86:	8e 81       	ldd	r24, Y+6	; 0x06
    1c88:	9f 81       	ldd	r25, Y+7	; 0x07
    1c8a:	89 2b       	or	r24, r25
    1c8c:	69 f1       	breq	.+90     	; 0x1ce8 <lzwReadByte+0xc8>
		decomp->fresh = false;
    1c8e:	1f 82       	std	Y+7, r1	; 0x07
    1c90:	1e 82       	std	Y+6, r1	; 0x06
		/* Read off all initial clear codes, read the first non-clear code,
		   and return it.  There are no strings in the table yet, so the next
		   code must be a direct true data code.
		 */
		do {
			decomp->firstcode = getCode(decomp->gifFile, decomp->codeSize, false);
    1c92:	8e 01       	movw	r16, r28
    1c94:	0e 5e       	subi	r16, 0xEE	; 238
    1c96:	1e 4f       	sbci	r17, 0xFE	; 254
			decomp->prevcode = decomp->firstcode;
		} while (decomp->firstcode == decomp->clear_code);
    1c98:	47 e1       	ldi	r20, 0x17	; 23
    1c9a:	e4 2e       	mov	r14, r20
    1c9c:	41 e0       	ldi	r20, 0x01	; 1
    1c9e:	f4 2e       	mov	r15, r20
    1ca0:	ec 0e       	add	r14, r28
    1ca2:	fd 1e       	adc	r15, r29
		/* Read off all initial clear codes, read the first non-clear code,
		   and return it.  There are no strings in the table yet, so the next
		   code must be a direct true data code.
		 */
		do {
			decomp->firstcode = getCode(decomp->gifFile, decomp->codeSize, false);
    1ca4:	68 85       	ldd	r22, Y+8	; 0x08
    1ca6:	79 85       	ldd	r23, Y+9	; 0x09
    1ca8:	f8 01       	movw	r30, r16
    1caa:	80 81       	ld	r24, Z
    1cac:	91 81       	ldd	r25, Z+1	; 0x01
    1cae:	40 e0       	ldi	r20, 0x00	; 0
    1cb0:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <getCode>
    1cb4:	8e 87       	std	Y+14, r24	; 0x0e
    1cb6:	9f 87       	std	Y+15, r25	; 0x0f
			decomp->prevcode = decomp->firstcode;
    1cb8:	88 8b       	std	Y+16, r24	; 0x10
    1cba:	99 8b       	std	Y+17, r25	; 0x11
		} while (decomp->firstcode == decomp->clear_code);
    1cbc:	9c 01       	movw	r18, r24
    1cbe:	f7 01       	movw	r30, r14
    1cc0:	80 81       	ld	r24, Z
    1cc2:	91 81       	ldd	r25, Z+1	; 0x01
    1cc4:	28 17       	cp	r18, r24
    1cc6:	39 07       	cpc	r19, r25
    1cc8:	69 f3       	breq	.-38     	; 0x1ca4 <lzwReadByte+0x84>
		if (decomp->firstcode == decomp->end_code) {
    1cca:	c7 5e       	subi	r28, 0xE7	; 231
    1ccc:	de 4f       	sbci	r29, 0xFE	; 254
    1cce:	88 81       	ld	r24, Y
    1cd0:	99 81       	ldd	r25, Y+1	; 0x01
    1cd2:	28 17       	cp	r18, r24
    1cd4:	39 07       	cpc	r19, r25
    1cd6:	09 f0       	breq	.+2      	; 0x1cda <lzwReadByte+0xba>
    1cd8:	e2 c0       	rjmp	.+452    	; 0x1e9e <lzwReadByte+0x27e>
			if (!zeroDataBlock) {
    1cda:	80 91 c7 02 	lds	r24, 0x02C7
    1cde:	88 23       	and	r24, r24
    1ce0:	09 f0       	breq	.+2      	; 0x1ce4 <lzwReadByte+0xc4>
    1ce2:	db c0       	rjmp	.+438    	; 0x1e9a <lzwReadByte+0x27a>
				readThroughEod(decomp->gifFile);
    1ce4:	f8 01       	movw	r30, r16
    1ce6:	3f c0       	rjmp	.+126    	; 0x1d66 <lzwReadByte+0x146>
		} else {
			retval = decomp->firstcode;
		}
	} else {
		int code;
		code = getCode(decomp->gifFile, decomp->codeSize, false);
    1ce8:	68 85       	ldd	r22, Y+8	; 0x08
    1cea:	79 85       	ldd	r23, Y+9	; 0x09
    1cec:	f6 01       	movw	r30, r12
    1cee:	80 81       	ld	r24, Z
    1cf0:	91 81       	ldd	r25, Z+1	; 0x01
    1cf2:	40 e0       	ldi	r20, 0x00	; 0
    1cf4:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <getCode>
    1cf8:	8c 01       	movw	r16, r24
		if (code == -1) {
    1cfa:	ff ef       	ldi	r31, 0xFF	; 255
    1cfc:	8f 3f       	cpi	r24, 0xFF	; 255
    1cfe:	9f 07       	cpc	r25, r31
    1d00:	19 f4       	brne	.+6      	; 0x1d08 <lzwReadByte+0xe8>
    1d02:	2f ef       	ldi	r18, 0xFF	; 255
    1d04:	3f ef       	ldi	r19, 0xFF	; 255
    1d06:	cb c0       	rjmp	.+406    	; 0x1e9e <lzwReadByte+0x27e>
			retval = -1;
		} else {
//			assert(code >= 0);  /* -1 is only possible error return */
			if (code == decomp->clear_code) {
    1d08:	f4 01       	movw	r30, r8
    1d0a:	80 81       	ld	r24, Z
    1d0c:	91 81       	ldd	r25, Z+1	; 0x01
    1d0e:	08 17       	cp	r16, r24
    1d10:	19 07       	cpc	r17, r25
    1d12:	b9 f4       	brne	.+46     	; 0x1d42 <lzwReadByte+0x122>
} decompressor;


static void
resetDecompressor(decompressor * const decomp) {
	decomp->codeSize = decomp->init_codeSize+1;
    1d14:	f5 01       	movw	r30, r10
    1d16:	80 81       	ld	r24, Z
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	01 96       	adiw	r24, 0x01	; 1
    1d1c:	99 87       	std	Y+9, r25	; 0x09
    1d1e:	88 87       	std	Y+8, r24	; 0x08
	decomp->maxnum_code = 1 << decomp->codeSize;
    1d20:	93 01       	movw	r18, r6
    1d22:	02 c0       	rjmp	.+4      	; 0x1d28 <lzwReadByte+0x108>
    1d24:	22 0f       	add	r18, r18
    1d26:	33 1f       	adc	r19, r19
    1d28:	8a 95       	dec	r24
    1d2a:	e2 f7       	brpl	.-8      	; 0x1d24 <lzwReadByte+0x104>
    1d2c:	3b 87       	std	Y+11, r19	; 0x0b
    1d2e:	2a 87       	std	Y+10, r18	; 0x0a
	decomp->next_tableSlot = decomp->max_dataVal + 3;
    1d30:	f7 01       	movw	r30, r14
    1d32:	80 81       	ld	r24, Z
    1d34:	91 81       	ldd	r25, Z+1	; 0x01
    1d36:	03 96       	adiw	r24, 0x03	; 3
    1d38:	9d 87       	std	Y+13, r25	; 0x0d
    1d3a:	8c 87       	std	Y+12, r24	; 0x0c
	decomp->fresh = 1;
    1d3c:	7f 82       	std	Y+7, r7	; 0x07
    1d3e:	6e 82       	std	Y+6, r6	; 0x06
    1d40:	99 cf       	rjmp	.-206    	; 0x1c74 <lzwReadByte+0x54>
    1d42:	c8 01       	movw	r24, r16
    1d44:	80 2e       	mov	r8, r16
    1d46:	79 2e       	mov	r7, r25
//			assert(code >= 0);  /* -1 is only possible error return */
			if (code == decomp->clear_code) {
				resetDecompressor(decomp);
				retval = lzwReadByte(decomp);
			} else {
				if (code == decomp->end_code) {
    1d48:	c7 5e       	subi	r28, 0xE7	; 231
    1d4a:	de 4f       	sbci	r29, 0xFE	; 254
    1d4c:	88 81       	ld	r24, Y
    1d4e:	99 81       	ldd	r25, Y+1	; 0x01
    1d50:	c9 51       	subi	r28, 0x19	; 25
    1d52:	d1 40       	sbci	r29, 0x01	; 1
    1d54:	08 17       	cp	r16, r24
    1d56:	19 07       	cpc	r17, r25
    1d58:	59 f4       	brne	.+22     	; 0x1d70 <lzwReadByte+0x150>
					if (!zeroDataBlock) {
    1d5a:	80 91 c7 02 	lds	r24, 0x02C7
    1d5e:	88 23       	and	r24, r24
    1d60:	09 f0       	breq	.+2      	; 0x1d64 <lzwReadByte+0x144>
    1d62:	9b c0       	rjmp	.+310    	; 0x1e9a <lzwReadByte+0x27a>
						readThroughEod(decomp->gifFile);
    1d64:	f6 01       	movw	r30, r12
    1d66:	80 81       	ld	r24, Z
    1d68:	91 81       	ldd	r25, Z+1	; 0x01
    1d6a:	0e 94 84 0c 	call	0x1908	; 0x1908 <readThroughEod>
    1d6e:	95 c0       	rjmp	.+298    	; 0x1e9a <lzwReadByte+0x27a>
	  -----------------------------------------------------------------------------*/
	int code;

	*error = false;

	if (incode < decomp->next_tableSlot) {
    1d70:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d72:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d74:	08 17       	cp	r16, r24
    1d76:	19 07       	cpc	r17, r25
    1d78:	3c f0       	brlt	.+14     	; 0x1d88 <lzwReadByte+0x168>
		code = incode;
	} else {
		/* It's a code that isn't in our translation table yet */
		pushStack(&decomp->stack, decomp->firstcode);
    1d7a:	6e 85       	ldd	r22, Y+14	; 0x0e
    1d7c:	7f 85       	ldd	r23, Y+15	; 0x0f
    1d7e:	ce 01       	movw	r24, r28
    1d80:	0e 94 a5 0b 	call	0x174a	; 0x174a <pushStack>
		code = decomp->prevcode;
    1d84:	08 89       	ldd	r16, Y+16	; 0x10
    1d86:	19 89       	ldd	r17, Y+17	; 0x11
//			printf("Error in GIF image: contains LZW string loop\n");
			puts("E15");
			*error = true;
		} else {
			++stringCount;
			pushStack(&decomp->stack, decomp->table[1][code]);
    1d88:	ac 2e       	mov	r10, r28
    1d8a:	9d 2e       	mov	r9, r29
    1d8c:	ee 24       	eor	r14, r14
    1d8e:	ff 24       	eor	r15, r15
    1d90:	bb 24       	eor	r11, r11
	 */

	unsigned int stringCount;
	stringCount = 0;

	while (code > decomp->max_dataVal && !(*error)) {
    1d92:	35 e1       	ldi	r19, 0x15	; 21
    1d94:	c3 2e       	mov	r12, r19
    1d96:	31 e0       	ldi	r19, 0x01	; 1
    1d98:	d3 2e       	mov	r13, r19
    1d9a:	cc 0e       	add	r12, r28
    1d9c:	dd 1e       	adc	r13, r29
    1d9e:	24 c0       	rjmp	.+72     	; 0x1de8 <lzwReadByte+0x1c8>
		if (stringCount > maxnum_lzwCode) {
    1da0:	f1 e4       	ldi	r31, 0x41	; 65
    1da2:	ef 16       	cp	r14, r31
    1da4:	f1 04       	cpc	r15, r1
    1da6:	38 f0       	brcs	.+14     	; 0x1db6 <lzwReadByte+0x196>
//			printf("Error in GIF image: contains LZW string loop\n");
			puts("E15");
    1da8:	8f e4       	ldi	r24, 0x4F	; 79
    1daa:	91 e0       	ldi	r25, 0x01	; 1
    1dac:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
    1db0:	bb 24       	eor	r11, r11
    1db2:	b3 94       	inc	r11
    1db4:	19 c0       	rjmp	.+50     	; 0x1de8 <lzwReadByte+0x1c8>
			*error = true;
		} else {
			++stringCount;
    1db6:	08 94       	sec
    1db8:	e1 1c       	adc	r14, r1
    1dba:	f1 1c       	adc	r15, r1
			pushStack(&decomp->stack, decomp->table[1][code]);
    1dbc:	07 5b       	subi	r16, 0xB7	; 183
    1dbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1dc0:	f8 01       	movw	r30, r16
    1dc2:	ee 0f       	add	r30, r30
    1dc4:	ff 1f       	adc	r31, r31
    1dc6:	ec 0f       	add	r30, r28
    1dc8:	fd 1f       	adc	r31, r29
    1dca:	60 81       	ld	r22, Z
    1dcc:	71 81       	ldd	r23, Z+1	; 0x01
    1dce:	8a 2d       	mov	r24, r10
    1dd0:	99 2d       	mov	r25, r9
    1dd2:	0e 94 a5 0b 	call	0x174a	; 0x174a <pushStack>
			code = decomp->table[0][code];
    1dd6:	f8 01       	movw	r30, r16
    1dd8:	e0 54       	subi	r30, 0x40	; 64
    1dda:	f0 40       	sbci	r31, 0x00	; 0
    1ddc:	ee 0f       	add	r30, r30
    1dde:	ff 1f       	adc	r31, r31
    1de0:	ec 0f       	add	r30, r28
    1de2:	fd 1f       	adc	r31, r29
    1de4:	00 81       	ld	r16, Z
    1de6:	11 81       	ldd	r17, Z+1	; 0x01
	 */

	unsigned int stringCount;
	stringCount = 0;

	while (code > decomp->max_dataVal && !(*error)) {
    1de8:	f6 01       	movw	r30, r12
    1dea:	80 81       	ld	r24, Z
    1dec:	91 81       	ldd	r25, Z+1	; 0x01
    1dee:	80 17       	cp	r24, r16
    1df0:	91 07       	cpc	r25, r17
    1df2:	14 f4       	brge	.+4      	; 0x1df8 <lzwReadByte+0x1d8>
    1df4:	bb 20       	and	r11, r11
    1df6:	a1 f2       	breq	.-88     	; 0x1da0 <lzwReadByte+0x180>
			++stringCount;
			pushStack(&decomp->stack, decomp->table[1][code]);
			code = decomp->table[0][code];
		}
	}
	decomp->firstcode = decomp->table[1][code];
    1df8:	07 5b       	subi	r16, 0xB7	; 183
    1dfa:	1f 4f       	sbci	r17, 0xFF	; 255
    1dfc:	00 0f       	add	r16, r16
    1dfe:	11 1f       	adc	r17, r17
    1e00:	0c 0f       	add	r16, r28
    1e02:	1d 1f       	adc	r17, r29
    1e04:	f8 01       	movw	r30, r16
    1e06:	60 81       	ld	r22, Z
    1e08:	71 81       	ldd	r23, Z+1	; 0x01
    1e0a:	7f 87       	std	Y+15, r23	; 0x0f
    1e0c:	6e 87       	std	Y+14, r22	; 0x0e
	pushStack(&decomp->stack, decomp->firstcode);
    1e0e:	8a 2d       	mov	r24, r10
    1e10:	99 2d       	mov	r25, r9
    1e12:	0e 94 a5 0b 	call	0x174a	; 0x174a <pushStack>

	if (decomp->next_tableSlot < maxnum_lzwCode) {
    1e16:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e18:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e1a:	20 34       	cpi	r18, 0x40	; 64
    1e1c:	31 05       	cpc	r19, r1
    1e1e:	80 f5       	brcc	.+96     	; 0x1e80 <lzwReadByte+0x260>
		decomp->table[0][decomp->next_tableSlot] = decomp->prevcode;
    1e20:	f9 01       	movw	r30, r18
    1e22:	39 96       	adiw	r30, 0x09	; 9
    1e24:	ee 0f       	add	r30, r30
    1e26:	ff 1f       	adc	r31, r31
    1e28:	ec 0f       	add	r30, r28
    1e2a:	fd 1f       	adc	r31, r29
    1e2c:	88 89       	ldd	r24, Y+16	; 0x10
    1e2e:	99 89       	ldd	r25, Y+17	; 0x11
    1e30:	91 83       	std	Z+1, r25	; 0x01
    1e32:	80 83       	st	Z, r24
		decomp->table[1][decomp->next_tableSlot] = decomp->firstcode;
    1e34:	27 5b       	subi	r18, 0xB7	; 183
    1e36:	3f 4f       	sbci	r19, 0xFF	; 255
    1e38:	f9 01       	movw	r30, r18
    1e3a:	ee 0f       	add	r30, r30
    1e3c:	ff 1f       	adc	r31, r31
    1e3e:	ec 0f       	add	r30, r28
    1e40:	fd 1f       	adc	r31, r29
    1e42:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e44:	9f 85       	ldd	r25, Y+15	; 0x0f
    1e46:	91 83       	std	Z+1, r25	; 0x01
    1e48:	80 83       	st	Z, r24
		++decomp->next_tableSlot;
    1e4a:	28 54       	subi	r18, 0x48	; 72
    1e4c:	30 40       	sbci	r19, 0x00	; 0
    1e4e:	3d 87       	std	Y+13, r19	; 0x0d
    1e50:	2c 87       	std	Y+12, r18	; 0x0c
		if (decomp->next_tableSlot >= decomp->maxnum_code) {
    1e52:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e54:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e56:	28 17       	cp	r18, r24
    1e58:	39 07       	cpc	r19, r25
    1e5a:	94 f0       	brlt	.+36     	; 0x1e80 <lzwReadByte+0x260>
			   Future codes in the stream will have codes one bit longer.
			   But there's an exception if we're already at the LZW
			   maximum, in which case the codes will simply continue
			   the same size.
			 */
			if (decomp->codeSize < MAX_LZW_BITS) {
    1e5c:	28 85       	ldd	r18, Y+8	; 0x08
    1e5e:	39 85       	ldd	r19, Y+9	; 0x09
    1e60:	26 30       	cpi	r18, 0x06	; 6
    1e62:	31 05       	cpc	r19, r1
    1e64:	6c f4       	brge	.+26     	; 0x1e80 <lzwReadByte+0x260>
				++decomp->codeSize;
    1e66:	2f 5f       	subi	r18, 0xFF	; 255
    1e68:	3f 4f       	sbci	r19, 0xFF	; 255
    1e6a:	39 87       	std	Y+9, r19	; 0x09
    1e6c:	28 87       	std	Y+8, r18	; 0x08
				decomp->maxnum_code = 1 << decomp->codeSize;
    1e6e:	81 e0       	ldi	r24, 0x01	; 1
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	02 c0       	rjmp	.+4      	; 0x1e78 <lzwReadByte+0x258>
    1e74:	88 0f       	add	r24, r24
    1e76:	99 1f       	adc	r25, r25
    1e78:	2a 95       	dec	r18
    1e7a:	e2 f7       	brpl	.-8      	; 0x1e74 <lzwReadByte+0x254>
    1e7c:	9b 87       	std	Y+11, r25	; 0x0b
    1e7e:	8a 87       	std	Y+10, r24	; 0x0a
			}
		}
	}

	decomp->prevcode = incode;
    1e80:	88 8a       	std	Y+16, r8	; 0x10
    1e82:	79 8a       	std	Y+17, r7	; 0x11
					}
					retval = -2;
				} else {
					bool error;
					expandCodeOntoStack(decomp, code, &error);
					if (error) {
    1e84:	bb 20       	and	r11, r11
    1e86:	19 f0       	breq	.+6      	; 0x1e8e <lzwReadByte+0x26e>
    1e88:	2d ef       	ldi	r18, 0xFD	; 253
    1e8a:	3f ef       	ldi	r19, 0xFF	; 255
    1e8c:	08 c0       	rjmp	.+16     	; 0x1e9e <lzwReadByte+0x27e>
						retval = -3;
					} else {
						retval = popStack(&decomp->stack);
    1e8e:	8a 2d       	mov	r24, r10
    1e90:	99 2d       	mov	r25, r9
    1e92:	0e 94 c0 0b 	call	0x1780	; 0x1780 <popStack>
    1e96:	9c 01       	movw	r18, r24
    1e98:	02 c0       	rjmp	.+4      	; 0x1e9e <lzwReadByte+0x27e>
    1e9a:	2e ef       	ldi	r18, 0xFE	; 254
    1e9c:	3f ef       	ldi	r19, 0xFF	; 255
				}
			}
		}
	}
	return retval;
}
    1e9e:	c9 01       	movw	r24, r18
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	ff 90       	pop	r15
    1eaa:	ef 90       	pop	r14
    1eac:	df 90       	pop	r13
    1eae:	cf 90       	pop	r12
    1eb0:	bf 90       	pop	r11
    1eb2:	af 90       	pop	r10
    1eb4:	9f 90       	pop	r9
    1eb6:	8f 90       	pop	r8
    1eb8:	7f 90       	pop	r7
    1eba:	6f 90       	pop	r6
    1ebc:	08 95       	ret

00001ebe <mallocProduct>:
	return (bytesRead != 0);
}


static inline void
mallocProduct(void ** const result, unsigned int const factor1, unsigned int const factor2) {
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	ec 01       	movw	r28, r24
    1ec4:	fb 01       	movw	r30, r22
    1ec6:	9a 01       	movw	r18, r20
	  us, like UINT_MAX, of what the limitations of size_t are.  We
	  assume size_t is at least as expressive as unsigned int and that
	  nobody really needs to allocate more than 4GB of memory.
	  -----------------------------------------------------------------------------*/

	if (factor1 == 0 || factor2 == 0) {
    1ec8:	61 15       	cp	r22, r1
    1eca:	71 05       	cpc	r23, r1
    1ecc:	19 f0       	breq	.+6      	; 0x1ed4 <mallocProduct+0x16>
    1ece:	41 15       	cp	r20, r1
    1ed0:	51 05       	cpc	r21, r1
    1ed2:	19 f4       	brne	.+6      	; 0x1eda <mallocProduct+0x1c>
		*result = malloc(1);
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	12 c0       	rjmp	.+36     	; 0x1efe <mallocProduct+0x40>
	} else {
		if (UINT_MAX / factor2 < factor1) {
    1eda:	8f ef       	ldi	r24, 0xFF	; 255
    1edc:	9f ef       	ldi	r25, 0xFF	; 255
    1ede:	ba 01       	movw	r22, r20
    1ee0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <__udivmodhi4>
    1ee4:	6e 17       	cp	r22, r30
    1ee6:	7f 07       	cpc	r23, r31
    1ee8:	18 f4       	brcc	.+6      	; 0x1ef0 <mallocProduct+0x32>
			*result = NULL;
    1eea:	19 82       	std	Y+1, r1	; 0x01
    1eec:	18 82       	st	Y, r1
    1eee:	0b c0       	rjmp	.+22     	; 0x1f06 <mallocProduct+0x48>
		} else {
			*result = malloc(factor1 * factor2);
    1ef0:	2e 9f       	mul	r18, r30
    1ef2:	c0 01       	movw	r24, r0
    1ef4:	2f 9f       	mul	r18, r31
    1ef6:	90 0d       	add	r25, r0
    1ef8:	3e 9f       	mul	r19, r30
    1efa:	90 0d       	add	r25, r0
    1efc:	11 24       	eor	r1, r1
    1efe:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <malloc>
    1f02:	88 83       	st	Y, r24
    1f04:	99 83       	std	Y+1, r25	; 0x01
		}
	}
}
    1f06:	df 91       	pop	r29
    1f08:	cf 91       	pop	r28
    1f0a:	08 95       	ret

00001f0c <img_allocarray>:
	arrayName = array; \
} while (0)


pixel**
img_allocarray(uint16_t const cols, uint16_t const rows) {
    1f0c:	8f 92       	push	r8
    1f0e:	9f 92       	push	r9
    1f10:	af 92       	push	r10
    1f12:	bf 92       	push	r11
    1f14:	cf 92       	push	r12
    1f16:	df 92       	push	r13
    1f18:	ef 92       	push	r14
    1f1a:	ff 92       	push	r15
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	df 93       	push	r29
    1f22:	cf 93       	push	r28
    1f24:	00 d0       	rcall	.+0      	; 0x1f26 <img_allocarray+0x1a>
    1f26:	cd b7       	in	r28, 0x3d	; 61
    1f28:	de b7       	in	r29, 0x3e	; 62
    1f2a:	5c 01       	movw	r10, r24
    1f2c:	6b 01       	movw	r12, r22
	char * rowheap;
	uint8_t size; 

	size = sizeof(pixel);

	MALLOCARRAY(rowIndex, rows + 1);
    1f2e:	6f 5f       	subi	r22, 0xFF	; 255
    1f30:	7f 4f       	sbci	r23, 0xFF	; 255
    1f32:	ce 01       	movw	r24, r28
    1f34:	01 96       	adiw	r24, 0x01	; 1
    1f36:	42 e0       	ldi	r20, 0x02	; 2
    1f38:	50 e0       	ldi	r21, 0x00	; 0
    1f3a:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <mallocProduct>
    1f3e:	f9 80       	ldd	r15, Y+1	; 0x01
    1f40:	ea 80       	ldd	r14, Y+2	; 0x02
    1f42:	0f 2d       	mov	r16, r15
    1f44:	1e 2d       	mov	r17, r14
	if (rowIndex == NULL) {
    1f46:	01 15       	cp	r16, r1
    1f48:	11 05       	cpc	r17, r1
    1f4a:	19 f4       	brne	.+6      	; 0x1f52 <img_allocarray+0x46>
//		printf("out of memory allocating row index (%u rows) for an array", rows);
		puts("E01");
    1f4c:	83 e5       	ldi	r24, 0x53	; 83
    1f4e:	91 e0       	ldi	r25, 0x01	; 1
    1f50:	23 c0       	rjmp	.+70     	; 0x1f98 <img_allocarray+0x8c>
		exit(1);
	}

	uint16_t row;

	rowheap = malloc(rows * cols * size);
    1f52:	ca 9c       	mul	r12, r10
    1f54:	c0 01       	movw	r24, r0
    1f56:	cb 9c       	mul	r12, r11
    1f58:	90 0d       	add	r25, r0
    1f5a:	da 9c       	mul	r13, r10
    1f5c:	90 0d       	add	r25, r0
    1f5e:	11 24       	eor	r1, r1
    1f60:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <malloc>
    1f64:	ac 01       	movw	r20, r24
    1f66:	f6 01       	movw	r30, r12
    1f68:	ee 0f       	add	r30, r30
    1f6a:	ff 1f       	adc	r31, r31
	if (rowheap == NULL) {
    1f6c:	00 97       	sbiw	r24, 0x00	; 0
    1f6e:	69 f5       	brne	.+90     	; 0x1fca <img_allocarray+0xbe>
		/* We couldn't get the whole heap in one block, so try fragmented
		   format.
		 */
		rowIndex[rows] = NULL;   /* Declare it fragmented format */
    1f70:	e0 0f       	add	r30, r16
    1f72:	f1 1f       	adc	r31, r17
    1f74:	11 82       	std	Z+1, r1	; 0x01
    1f76:	10 82       	st	Z, r1
    1f78:	8f 2d       	mov	r24, r15
    1f7a:	9e 2d       	mov	r25, r14
    1f7c:	9c 01       	movw	r18, r24
    1f7e:	49 01       	movw	r8, r18
    1f80:	ee 24       	eor	r14, r14
    1f82:	ff 24       	eor	r15, r15
    1f84:	1e c0       	rjmp	.+60     	; 0x1fc2 <img_allocarray+0xb6>

		for (row = 0; row < rows; ++row) {
			if (UINT_MAX / cols < size) {
    1f86:	8f ef       	ldi	r24, 0xFF	; 255
    1f88:	9f ef       	ldi	r25, 0xFF	; 255
    1f8a:	b5 01       	movw	r22, r10
    1f8c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <__udivmodhi4>
    1f90:	67 2b       	or	r22, r23
    1f92:	41 f4       	brne	.+16     	; 0x1fa4 <img_allocarray+0x98>
//				printf("Arithmetic overflow multiplying %u by %u to get the "
//						"size of a row to allocate.", cols, size);
				puts("E02");
    1f94:	87 e5       	ldi	r24, 0x57	; 87
    1f96:	91 e0       	ldi	r25, 0x01	; 1
    1f98:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
				exit(1);
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
			}

			rowIndex[row] = malloc(cols * size);
    1fa4:	c5 01       	movw	r24, r10
    1fa6:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <malloc>
    1faa:	f4 01       	movw	r30, r8
    1fac:	81 93       	st	Z+, r24
    1fae:	91 93       	st	Z+, r25
    1fb0:	4f 01       	movw	r8, r30

			if (rowIndex[row] == NULL) {
    1fb2:	00 97       	sbiw	r24, 0x00	; 0
    1fb4:	19 f4       	brne	.+6      	; 0x1fbc <img_allocarray+0xb0>
//				printf("out of memory allocating Row %u (%u columns, %u bytes per tuple) "
//						"of an array", row, cols, size);
				puts("E03");
    1fb6:	8b e5       	ldi	r24, 0x5B	; 91
    1fb8:	91 e0       	ldi	r25, 0x01	; 1
    1fba:	ee cf       	rjmp	.-36     	; 0x1f98 <img_allocarray+0x8c>
		/* We couldn't get the whole heap in one block, so try fragmented
		   format.
		 */
		rowIndex[rows] = NULL;   /* Declare it fragmented format */

		for (row = 0; row < rows; ++row) {
    1fbc:	08 94       	sec
    1fbe:	e1 1c       	adc	r14, r1
    1fc0:	f1 1c       	adc	r15, r1
    1fc2:	ec 14       	cp	r14, r12
    1fc4:	fd 04       	cpc	r15, r13
    1fc6:	f8 f2       	brcs	.-66     	; 0x1f86 <img_allocarray+0x7a>
    1fc8:	17 c0       	rjmp	.+46     	; 0x1ff8 <img_allocarray+0xec>
				exit(1);
			}
		}
	} else {
		/* It's unfragmented format */
		rowIndex[rows] = rowheap;  /* Declare it unfragmented format */
    1fca:	e0 0f       	add	r30, r16
    1fcc:	f1 1f       	adc	r31, r17
    1fce:	91 83       	std	Z+1, r25	; 0x01
    1fd0:	80 83       	st	Z, r24
    1fd2:	2f 2d       	mov	r18, r15
    1fd4:	3e 2d       	mov	r19, r14
    1fd6:	c9 01       	movw	r24, r18
    1fd8:	fc 01       	movw	r30, r24
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	07 c0       	rjmp	.+14     	; 0x1fee <img_allocarray+0xe2>

		for (row = 0; row < rows; ++row) {
			rowIndex[row] = &(rowheap[row * cols * size]);
    1fe0:	ca 01       	movw	r24, r20
    1fe2:	8a 19       	sub	r24, r10
    1fe4:	9b 09       	sbc	r25, r11
    1fe6:	81 93       	st	Z+, r24
    1fe8:	91 93       	st	Z+, r25
		}
	} else {
		/* It's unfragmented format */
		rowIndex[rows] = rowheap;  /* Declare it unfragmented format */

		for (row = 0; row < rows; ++row) {
    1fea:	2f 5f       	subi	r18, 0xFF	; 255
    1fec:	3f 4f       	sbci	r19, 0xFF	; 255
    1fee:	4a 0d       	add	r20, r10
    1ff0:	5b 1d       	adc	r21, r11
    1ff2:	2c 15       	cp	r18, r12
    1ff4:	3d 05       	cpc	r19, r13
    1ff6:	a0 f3       	brcs	.-24     	; 0x1fe0 <img_allocarray+0xd4>
			rowIndex[row] = &(rowheap[row * cols * size]);
		}
	}
	return (pixel**)rowIndex;
}
    1ff8:	c8 01       	movw	r24, r16
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	cf 91       	pop	r28
    2000:	df 91       	pop	r29
    2002:	1f 91       	pop	r17
    2004:	0f 91       	pop	r16
    2006:	ff 90       	pop	r15
    2008:	ef 90       	pop	r14
    200a:	df 90       	pop	r13
    200c:	cf 90       	pop	r12
    200e:	bf 90       	pop	r11
    2010:	af 90       	pop	r10
    2012:	9f 90       	pop	r9
    2014:	8f 90       	pop	r8
    2016:	08 95       	ret

00002018 <readImageData>:
		uint16_t const cols,
		uint16_t const rows,
		gifColorTable colorTable,
		uint16_t const colorTableSize,
		bool const useInterlace,
		uint8_t const transparentIndex) {
    2018:	2f 92       	push	r2
    201a:	3f 92       	push	r3
    201c:	4f 92       	push	r4
    201e:	5f 92       	push	r5
    2020:	6f 92       	push	r6
    2022:	7f 92       	push	r7
    2024:	8f 92       	push	r8
    2026:	9f 92       	push	r9
    2028:	af 92       	push	r10
    202a:	bf 92       	push	r11
    202c:	cf 92       	push	r12
    202e:	df 92       	push	r13
    2030:	ef 92       	push	r14
    2032:	ff 92       	push	r15
    2034:	0f 93       	push	r16
    2036:	1f 93       	push	r17
    2038:	df 93       	push	r29
    203a:	cf 93       	push	r28
    203c:	cd b7       	in	r28, 0x3d	; 61
    203e:	de b7       	in	r29, 0x3e	; 62
    2040:	c4 52       	subi	r28, 0x24	; 36
    2042:	d1 40       	sbci	r29, 0x01	; 1
    2044:	0f b6       	in	r0, 0x3f	; 63
    2046:	f8 94       	cli
    2048:	de bf       	out	0x3e, r29	; 62
    204a:	0f be       	out	0x3f, r0	; 63
    204c:	cd bf       	out	0x3d, r28	; 61
    204e:	5c 01       	movw	r10, r24
    2050:	ce 5d       	subi	r28, 0xDE	; 222
    2052:	de 4f       	sbci	r29, 0xFE	; 254
    2054:	79 83       	std	Y+1, r23	; 0x01
    2056:	68 83       	st	Y, r22
    2058:	c2 52       	subi	r28, 0x22	; 34
    205a:	d1 40       	sbci	r29, 0x01	; 1
    205c:	1a 01       	movw	r2, r20
    205e:	49 01       	movw	r8, r18
    2060:	28 01       	movw	r4, r16
    2062:	37 01       	movw	r6, r14
    2064:	cc 5d       	subi	r28, 0xDC	; 220
    2066:	de 4f       	sbci	r29, 0xFE	; 254
    2068:	c8 82       	st	Y, r12
    206a:	c4 52       	subi	r28, 0x24	; 36
    206c:	d1 40       	sbci	r29, 0x01	; 1
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    206e:	ce 01       	movw	r24, r28
    2070:	01 96       	adiw	r24, 0x01	; 1
    2072:	61 e0       	ldi	r22, 0x01	; 1
    2074:	70 e0       	ldi	r23, 0x00	; 0
    2076:	ae 01       	movw	r20, r28
    2078:	4e 5f       	subi	r20, 0xFE	; 254
    207a:	5f 4f       	sbci	r21, 0xFF	; 255
    207c:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
	imageBuffer.pixels = pixels;
	imageBuffer.col = 0;
	imageBuffer.row = 0;

	gotMinCodeSize = ReadOK(gifFile, &lzwMinCodeSize, 1);
	if (!gotMinCodeSize) {
    2080:	8a 81       	ldd	r24, Y+2	; 0x02
    2082:	9b 81       	ldd	r25, Y+3	; 0x03
    2084:	89 2b       	or	r24, r25
    2086:	19 f4       	brne	.+6      	; 0x208e <readImageData+0x76>
//		printf("GIF stream ends (or read error) "
//				"right after an image separator; no "
//				"image data follows.\n");
		puts("E17");
    2088:	8f e5       	ldi	r24, 0x5F	; 95
    208a:	91 e0       	ldi	r25, 0x01	; 1
    208c:	05 c0       	rjmp	.+10     	; 0x2098 <readImageData+0x80>
		exit(1);
	}

	if (lzwMinCodeSize > MAX_LZW_BITS) {
    208e:	a9 81       	ldd	r26, Y+1	; 0x01
    2090:	a7 30       	cpi	r26, 0x07	; 7
    2092:	40 f0       	brcs	.+16     	; 0x20a4 <readImageData+0x8c>
//		printf("Invalid minimum code size value in image data: %u.  "
//				"Maximum allowable code size in GIF is %u\n", 
//				lzwMinCodeSize, MAX_LZW_BITS);
		puts("E18");
    2094:	83 e6       	ldi	r24, 0x63	; 99
    2096:	91 e0       	ldi	r25, 0x01	; 1
    2098:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		exit(1);
    209c:	81 e0       	ldi	r24, 0x01	; 1
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
	decomp->gifFile = gifFile;
	decomp->init_codeSize = init_codeSize;

//	assert(decomp->init_codeSize < sizeof(decomp->max_dataVal) * 8);

	decomp->max_dataVal = (1 << init_codeSize) - 1;
    20a4:	8a 2f       	mov	r24, r26
    20a6:	90 e0       	ldi	r25, 0x00	; 0
    20a8:	61 e0       	ldi	r22, 0x01	; 1
    20aa:	70 e0       	ldi	r23, 0x00	; 0
    20ac:	0a 2e       	mov	r0, r26
    20ae:	02 c0       	rjmp	.+4      	; 0x20b4 <readImageData+0x9c>
    20b0:	66 0f       	add	r22, r22
    20b2:	77 1f       	adc	r23, r23
    20b4:	0a 94       	dec	r0
    20b6:	e2 f7       	brpl	.-8      	; 0x20b0 <readImageData+0x98>
    20b8:	9b 01       	movw	r18, r22
    20ba:	21 50       	subi	r18, 0x01	; 1
    20bc:	30 40       	sbci	r19, 0x00	; 0
    20be:	fe 01       	movw	r30, r28
    20c0:	78 96       	adiw	r30, 0x18	; 24
    20c2:	40 e0       	ldi	r20, 0x00	; 0
    20c4:	50 e0       	ldi	r21, 0x00	; 0
    20c6:	0a c0       	rjmp	.+20     	; 0x20dc <readImageData+0xc4>
	   constant throughout the stream.  We set them now and they never
	   change.
	 */
	uint16_t i;
	for (i = 0; i <= decomp->max_dataVal; ++i) {
		decomp->table[0][i] = 0;
    20c8:	11 82       	std	Z+1, r1	; 0x01
    20ca:	10 82       	st	Z, r1
		decomp->table[1][i] = i;
    20cc:	e0 58       	subi	r30, 0x80	; 128
    20ce:	ff 4f       	sbci	r31, 0xFF	; 255
    20d0:	51 83       	std	Z+1, r21	; 0x01
    20d2:	40 83       	st	Z, r20
	/* The entries in the translation table for true data codes are
	   constant throughout the stream.  We set them now and they never
	   change.
	 */
	uint16_t i;
	for (i = 0; i <= decomp->max_dataVal; ++i) {
    20d4:	4f 5f       	subi	r20, 0xFF	; 255
    20d6:	5f 4f       	sbci	r21, 0xFF	; 255
    20d8:	ee 57       	subi	r30, 0x7E	; 126
    20da:	f0 40       	sbci	r31, 0x00	; 0
    20dc:	24 17       	cp	r18, r20
    20de:	35 07       	cpc	r19, r21
    20e0:	98 f7       	brcc	.-26     	; 0x20c8 <readImageData+0xb0>
} decompressor;


static void
resetDecompressor(decompressor * const decomp) {
	decomp->codeSize = decomp->init_codeSize+1;
    20e2:	01 96       	adiw	r24, 0x01	; 1
    20e4:	9f 87       	std	Y+15, r25	; 0x0f
    20e6:	8e 87       	std	Y+14, r24	; 0x0e
	decomp->maxnum_code = 1 << decomp->codeSize;
    20e8:	01 e0       	ldi	r16, 0x01	; 1
    20ea:	10 e0       	ldi	r17, 0x00	; 0
    20ec:	a8 01       	movw	r20, r16
    20ee:	02 c0       	rjmp	.+4      	; 0x20f4 <readImageData+0xdc>
    20f0:	44 0f       	add	r20, r20
    20f2:	55 1f       	adc	r21, r21
    20f4:	8a 95       	dec	r24
    20f6:	e2 f7       	brpl	.-8      	; 0x20f0 <readImageData+0xd8>
    20f8:	59 8b       	std	Y+17, r21	; 0x11
    20fa:	48 8b       	std	Y+16, r20	; 0x10
	decomp->next_tableSlot = decomp->max_dataVal + 3;
    20fc:	2d 5f       	subi	r18, 0xFD	; 253
    20fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2100:	3b 8b       	std	Y+19, r19	; 0x13
    2102:	2a 8b       	std	Y+18, r18	; 0x12
	decomp->fresh = 1;
    2104:	1d 87       	std	Y+13, r17	; 0x0d
    2106:	0c 87       	std	Y+12, r16	; 0x0c

//	assert(decomp->init_codeSize < sizeof(decomp->max_dataVal) * 8);

	decomp->max_dataVal = (1 << init_codeSize) - 1;
	decomp->clear_code = decomp->max_dataVal + 1;
	decomp->end_code = decomp->max_dataVal + 2;
    2108:	21 50       	subi	r18, 0x01	; 1
    210a:	30 40       	sbci	r19, 0x00	; 0
    210c:	fe 01       	movw	r30, r28
    210e:	e1 5e       	subi	r30, 0xE1	; 225
    2110:	fe 4f       	sbci	r31, 0xFE	; 254
    2112:	31 83       	std	Z+1, r19	; 0x01
    2114:	20 83       	st	Z, r18
    2116:	22 50       	subi	r18, 0x02	; 2
    2118:	30 40       	sbci	r19, 0x00	; 0
	decomp->init_codeSize = init_codeSize;

//	assert(decomp->init_codeSize < sizeof(decomp->max_dataVal) * 8);

	decomp->max_dataVal = (1 << init_codeSize) - 1;
	decomp->clear_code = decomp->max_dataVal + 1;
    211a:	fe 01       	movw	r30, r28
    211c:	e3 5e       	subi	r30, 0xE3	; 227
    211e:	fe 4f       	sbci	r31, 0xFE	; 254
    2120:	71 83       	std	Z+1, r23	; 0x01
    2122:	60 83       	st	Z, r22
	decomp->gifFile = gifFile;
	decomp->init_codeSize = init_codeSize;

//	assert(decomp->init_codeSize < sizeof(decomp->max_dataVal) * 8);

	decomp->max_dataVal = (1 << init_codeSize) - 1;
    2124:	fe 01       	movw	r30, r28
    2126:	e5 5e       	subi	r30, 0xE5	; 229
    2128:	fe 4f       	sbci	r31, 0xFE	; 254
    212a:	31 83       	std	Z+1, r19	; 0x01
    212c:	20 83       	st	Z, r18
lzwInit(decompressor * const decomp, FILE * const gifFile, uint8_t const init_codeSize) {

//	printf("Image says the initial compression code size is " "%d bits\n", init_codeSize);

	decomp->gifFile = gifFile;
	decomp->init_codeSize = init_codeSize;
    212e:	fe 01       	movw	r30, r28
    2130:	e6 5e       	subi	r30, 0xE6	; 230
    2132:	fe 4f       	sbci	r31, 0xFE	; 254
    2134:	a0 83       	st	Z, r26
static void
lzwInit(decompressor * const decomp, FILE * const gifFile, uint8_t const init_codeSize) {

//	printf("Image says the initial compression code size is " "%d bits\n", init_codeSize);

	decomp->gifFile = gifFile;
    2136:	fe 01       	movw	r30, r28
    2138:	e8 5e       	subi	r30, 0xE8	; 232
    213a:	fe 4f       	sbci	r31, 0xFE	; 254
    213c:	b1 82       	std	Z+1, r11	; 0x01
    213e:	a0 82       	st	Z, r10
		decomp->table[0][i] = 0;
		decomp->table[1][i] = i;
	}
	resetDecompressor(decomp);

	getCode(decomp->gifFile, 0, true);
    2140:	c5 01       	movw	r24, r10
    2142:	60 e0       	ldi	r22, 0x00	; 0
    2144:	70 e0       	ldi	r23, 0x00	; 0
    2146:	41 e0       	ldi	r20, 0x01	; 1
    2148:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <getCode>

	decomp->fresh = true;
    214c:	1d 87       	std	Y+13, r17	; 0x0d
    214e:	0c 87       	std	Y+12, r16	; 0x0c
} stack;


static void 
initStack(stack * const stackP, uint16_t const size) {
	MALLOCARRAY(stackP->stack, size);
    2150:	ce 01       	movw	r24, r28
    2152:	04 96       	adiw	r24, 0x04	; 4
    2154:	60 e8       	ldi	r22, 0x80	; 128
    2156:	70 e0       	ldi	r23, 0x00	; 0
    2158:	42 e0       	ldi	r20, 0x02	; 2
    215a:	50 e0       	ldi	r21, 0x00	; 0
    215c:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <mallocProduct>
    2160:	8c 81       	ldd	r24, Y+4	; 0x04
    2162:	9d 81       	ldd	r25, Y+5	; 0x05
    2164:	9f 83       	std	Y+7, r25	; 0x07
    2166:	8e 83       	std	Y+6, r24	; 0x06
	if (stackP->stack == NULL) {
    2168:	00 97       	sbiw	r24, 0x00	; 0
    216a:	19 f4       	brne	.+6      	; 0x2172 <readImageData+0x15a>
//		printf("Unable to allocate %d-word stack.\n", size);
		puts("E12");
    216c:	87 e6       	ldi	r24, 0x67	; 103
    216e:	91 e0       	ldi	r25, 0x01	; 1
    2170:	93 cf       	rjmp	.-218    	; 0x2098 <readImageData+0x80>
		exit(1);
	}
	stackP->sp = stackP->stack;
    2172:	99 87       	std	Y+9, r25	; 0x09
    2174:	88 87       	std	Y+8, r24	; 0x08
	stackP->top = stackP->stack + size;
    2176:	80 50       	subi	r24, 0x00	; 0
    2178:	9f 4f       	sbci	r25, 0xFF	; 255
    217a:	9b 87       	std	Y+11, r25	; 0x0b
    217c:	8a 87       	std	Y+10, r24	; 0x0a
    217e:	cf 5d       	subi	r28, 0xDF	; 223
    2180:	de 4f       	sbci	r29, 0xFE	; 254
    2182:	18 82       	st	Y, r1
    2184:	c1 52       	subi	r28, 0x21	; 33
    2186:	d1 40       	sbci	r29, 0x01	; 1
    2188:	00 e0       	ldi	r16, 0x00	; 0
    218a:	10 e0       	ldi	r17, 0x00	; 0

	lzwInit(&decomp, gifFile, lzwMinCodeSize);


	while (imageBuffer.row < rows) {
		int const rc = lzwReadByte(&decomp);
    218c:	86 e0       	ldi	r24, 0x06	; 6
    218e:	a8 2e       	mov	r10, r24
    2190:	b1 2c       	mov	r11, r1
    2192:	ac 0e       	add	r10, r28
    2194:	bd 1e       	adc	r11, r29
    2196:	82 c0       	rjmp	.+260    	; 0x229c <readImageData+0x284>
    2198:	c5 01       	movw	r24, r10
    219a:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <lzwReadByte>

		switch (rc) {
    219e:	5f ef       	ldi	r21, 0xFF	; 255
    21a0:	8e 3f       	cpi	r24, 0xFE	; 254
    21a2:	95 07       	cpc	r25, r21
    21a4:	59 f0       	breq	.+22     	; 0x21bc <readImageData+0x1a4>
    21a6:	ef ef       	ldi	r30, 0xFF	; 255
    21a8:	8f 3f       	cpi	r24, 0xFF	; 255
    21aa:	9e 07       	cpc	r25, r30
    21ac:	51 f0       	breq	.+20     	; 0x21c2 <readImageData+0x1aa>
    21ae:	ff ef       	ldi	r31, 0xFF	; 255
    21b0:	8d 3f       	cpi	r24, 0xFD	; 253
    21b2:	9f 07       	cpc	r25, r31
    21b4:	49 f4       	brne	.+18     	; 0x21c8 <readImageData+0x1b0>
			case -3:
//				printf("Error in GIF input stream\n");
				puts("E19");
    21b6:	8b e6       	ldi	r24, 0x6B	; 107
    21b8:	91 e0       	ldi	r25, 0x01	; 1
    21ba:	6e cf       	rjmp	.-292    	; 0x2098 <readImageData+0x80>

			case -2:
//				printf("Error in GIF image: Not enough raster data to fill "
//						"%u x %u dimensions.  Ran out of raster data in "
//						"row %u\n", cols, rows, imageBuffer.row);
				puts("E20");
    21bc:	8f e6       	ldi	r24, 0x6F	; 111
    21be:	91 e0       	ldi	r25, 0x01	; 1
    21c0:	6b cf       	rjmp	.-298    	; 0x2098 <readImageData+0x80>
				exit(1);
				break;

			case -1:
//				printf("Premature end of file; no proper GIF closing\n");
				puts("E21");
    21c2:	83 e7       	ldi	r24, 0x73	; 115
    21c4:	91 e0       	ldi	r25, 0x01	; 1
    21c6:	68 cf       	rjmp	.-304    	; 0x2098 <readImageData+0x80>
		gifColorTable colorTable, 
		uint16_t const colorTableSize,
		bool const useInterlace,
		enum pass * const pass) {

	if (colorTableIndex >= colorTableSize) {
    21c8:	a8 2f       	mov	r26, r24
    21ca:	b0 e0       	ldi	r27, 0x00	; 0
    21cc:	a6 15       	cp	r26, r6
    21ce:	b7 05       	cpc	r27, r7
    21d0:	18 f0       	brcs	.+6      	; 0x21d8 <readImageData+0x1c0>
//		printf("Invalid color index %u in an image that has only "
//				"%u colors in the color table.\n", colorTableIndex, colorTableSize);
		puts("E16");
    21d2:	87 e7       	ldi	r24, 0x77	; 119
    21d4:	91 e0       	ldi	r25, 0x01	; 1
    21d6:	60 cf       	rjmp	.-320    	; 0x2098 <readImageData+0x80>
		exit(1);
	}

	imageBuffer->pixels[imageBuffer->row][imageBuffer->col].r = colorTable[CM_RED][colorTableIndex];
    21d8:	f6 01       	movw	r30, r12
    21da:	20 81       	ld	r18, Z
    21dc:	31 81       	ldd	r19, Z+1	; 0x01
    21de:	2e 0d       	add	r18, r14
    21e0:	3f 1d       	adc	r19, r15
    21e2:	a4 0d       	add	r26, r4
    21e4:	b5 1d       	adc	r27, r5
    21e6:	8c 91       	ld	r24, X
    21e8:	f9 01       	movw	r30, r18
    21ea:	80 83       	st	Z, r24
    21ec:	08 94       	sec
    21ee:	e1 1c       	adc	r14, r1
    21f0:	f1 1c       	adc	r15, r1
//	imageBuffer->pixels[imageBuffer->row][imageBuffer->col].g = colorTable[CM_GRN][colorTableIndex];
//	imageBuffer->pixels[imageBuffer->row][imageBuffer->col].b = colorTable[CM_BLU][colorTableIndex];

	++imageBuffer->col;
	if (imageBuffer->col == cols) {
    21f2:	e2 14       	cp	r14, r2
    21f4:	f3 04       	cpc	r15, r3
    21f6:	81 f6       	brne	.-96     	; 0x2198 <readImageData+0x180>
		imageBuffer->col = 0;
		if (useInterlace) {
    21f8:	cc 5d       	subi	r28, 0xDC	; 220
    21fa:	de 4f       	sbci	r29, 0xFE	; 254
    21fc:	f8 81       	ld	r31, Y
    21fe:	c4 52       	subi	r28, 0x24	; 36
    2200:	d1 40       	sbci	r29, 0x01	; 1
    2202:	ff 23       	and	r31, r31
    2204:	09 f4       	brne	.+2      	; 0x2208 <readImageData+0x1f0>
    2206:	48 c0       	rjmp	.+144    	; 0x2298 <readImageData+0x280>
MULT8PLUS4: Rows 4, 12, 20, 28, etc.
MULT4PLUS2: Rows 2, 6, 10, 14, etc.
MULT2PLUS1: Rows 1, 3, 5, 7, 9, etc.
	 */

	switch (*pass) {
    2208:	cf 5d       	subi	r28, 0xDF	; 223
    220a:	de 4f       	sbci	r29, 0xFE	; 254
    220c:	28 81       	ld	r18, Y
    220e:	c1 52       	subi	r28, 0x21	; 33
    2210:	d1 40       	sbci	r29, 0x01	; 1
    2212:	21 30       	cpi	r18, 0x01	; 1
    2214:	39 f0       	breq	.+14     	; 0x2224 <readImageData+0x20c>
    2216:	21 30       	cpi	r18, 0x01	; 1
    2218:	28 f0       	brcs	.+10     	; 0x2224 <readImageData+0x20c>
    221a:	22 30       	cpi	r18, 0x02	; 2
    221c:	31 f0       	breq	.+12     	; 0x222a <readImageData+0x212>
    221e:	23 30       	cpi	r18, 0x03	; 3
    2220:	81 f5       	brne	.+96     	; 0x2282 <readImageData+0x26a>
    2222:	06 c0       	rjmp	.+12     	; 0x2230 <readImageData+0x218>
		case MULT8PLUS0:
			*row += 8;
			break;

		case MULT8PLUS4:
			*row += 8;
    2224:	08 5f       	subi	r16, 0xF8	; 248
    2226:	1f 4f       	sbci	r17, 0xFF	; 255
    2228:	2c c0       	rjmp	.+88     	; 0x2282 <readImageData+0x26a>
			break;

		case MULT4PLUS2:
			*row += 4;
    222a:	0c 5f       	subi	r16, 0xFC	; 252
    222c:	1f 4f       	sbci	r17, 0xFF	; 255
    222e:	29 c0       	rjmp	.+82     	; 0x2282 <readImageData+0x26a>
			break;

		case MULT2PLUS1:
			*row += 2;
    2230:	0e 5f       	subi	r16, 0xFE	; 254
    2232:	1f 4f       	sbci	r17, 0xFF	; 255
    2234:	26 c0       	rjmp	.+76     	; 0x2282 <readImageData+0x26a>
    2236:	04 e0       	ldi	r16, 0x04	; 4
    2238:	10 e0       	ldi	r17, 0x00	; 0
	   more than 4 rows, the sequence of passes is sequential, but
	   when there are fewer than 4, we may skip e.g. from MULT8PLUS0
	   to MULT4PLUS2.
	 */
	while (*row >= rows && *pass != MULT2PLUS1) {
		switch (*pass) {
    223a:	cf 5d       	subi	r28, 0xDF	; 223
    223c:	de 4f       	sbci	r29, 0xFE	; 254
    223e:	48 81       	ld	r20, Y
    2240:	c1 52       	subi	r28, 0x21	; 33
    2242:	d1 40       	sbci	r29, 0x01	; 1
    2244:	41 30       	cpi	r20, 0x01	; 1
    2246:	a9 f0       	breq	.+42     	; 0x2272 <readImageData+0x25a>
    2248:	41 30       	cpi	r20, 0x01	; 1
    224a:	18 f0       	brcs	.+6      	; 0x2252 <readImageData+0x23a>
    224c:	42 30       	cpi	r20, 0x02	; 2
    224e:	99 f7       	brne	.-26     	; 0x2236 <readImageData+0x21e>
    2250:	07 c0       	rjmp	.+14     	; 0x2260 <readImageData+0x248>
    2252:	51 e0       	ldi	r21, 0x01	; 1
    2254:	cf 5d       	subi	r28, 0xDF	; 223
    2256:	de 4f       	sbci	r29, 0xFE	; 254
    2258:	58 83       	st	Y, r21
    225a:	c1 52       	subi	r28, 0x21	; 33
    225c:	d1 40       	sbci	r29, 0x01	; 1
    225e:	11 c0       	rjmp	.+34     	; 0x2282 <readImageData+0x26a>
    2260:	83 e0       	ldi	r24, 0x03	; 3
    2262:	cf 5d       	subi	r28, 0xDF	; 223
    2264:	de 4f       	sbci	r29, 0xFE	; 254
    2266:	88 83       	st	Y, r24
    2268:	c1 52       	subi	r28, 0x21	; 33
    226a:	d1 40       	sbci	r29, 0x01	; 1
    226c:	01 e0       	ldi	r16, 0x01	; 1
    226e:	10 e0       	ldi	r17, 0x00	; 0
    2270:	08 c0       	rjmp	.+16     	; 0x2282 <readImageData+0x26a>
    2272:	92 e0       	ldi	r25, 0x02	; 2
    2274:	cf 5d       	subi	r28, 0xDF	; 223
    2276:	de 4f       	sbci	r29, 0xFE	; 254
    2278:	98 83       	st	Y, r25
    227a:	c1 52       	subi	r28, 0x21	; 33
    227c:	d1 40       	sbci	r29, 0x01	; 1
    227e:	02 e0       	ldi	r16, 0x02	; 2
    2280:	10 e0       	ldi	r17, 0x00	; 0
	/* Set the proper pass for the next read.  Note that if there are
	   more than 4 rows, the sequence of passes is sequential, but
	   when there are fewer than 4, we may skip e.g. from MULT8PLUS0
	   to MULT4PLUS2.
	 */
	while (*row >= rows && *pass != MULT2PLUS1) {
    2282:	08 15       	cp	r16, r8
    2284:	19 05       	cpc	r17, r9
    2286:	50 f0       	brcs	.+20     	; 0x229c <readImageData+0x284>
    2288:	cf 5d       	subi	r28, 0xDF	; 223
    228a:	de 4f       	sbci	r29, 0xFE	; 254
    228c:	e8 81       	ld	r30, Y
    228e:	c1 52       	subi	r28, 0x21	; 33
    2290:	d1 40       	sbci	r29, 0x01	; 1
    2292:	e3 30       	cpi	r30, 0x03	; 3
    2294:	81 f6       	brne	.-96     	; 0x2236 <readImageData+0x21e>
    2296:	02 c0       	rjmp	.+4      	; 0x229c <readImageData+0x284>
	if (imageBuffer->col == cols) {
		imageBuffer->col = 0;
		if (useInterlace) {
			bumpRowInterlace(&imageBuffer->row, rows, pass);
		} else {
			++imageBuffer->row;
    2298:	0f 5f       	subi	r16, 0xFF	; 255
    229a:	1f 4f       	sbci	r17, 0xFF	; 255
	}

	lzwInit(&decomp, gifFile, lzwMinCodeSize);


	while (imageBuffer.row < rows) {
    229c:	08 15       	cp	r16, r8
    229e:	19 05       	cpc	r17, r9
    22a0:	70 f4       	brcc	.+28     	; 0x22be <readImageData+0x2a6>
//				"%u colors in the color table.\n", colorTableIndex, colorTableSize);
		puts("E16");
		exit(1);
	}

	imageBuffer->pixels[imageBuffer->row][imageBuffer->col].r = colorTable[CM_RED][colorTableIndex];
    22a2:	68 01       	movw	r12, r16
    22a4:	cc 0c       	add	r12, r12
    22a6:	dd 1c       	adc	r13, r13
    22a8:	ce 5d       	subi	r28, 0xDE	; 222
    22aa:	de 4f       	sbci	r29, 0xFE	; 254
    22ac:	48 81       	ld	r20, Y
    22ae:	59 81       	ldd	r21, Y+1	; 0x01
    22b0:	c2 52       	subi	r28, 0x22	; 34
    22b2:	d1 40       	sbci	r29, 0x01	; 1
    22b4:	c4 0e       	add	r12, r20
    22b6:	d5 1e       	adc	r13, r21
    22b8:	ee 24       	eor	r14, r14
    22ba:	ff 24       	eor	r15, r15
    22bc:	6d cf       	rjmp	.-294    	; 0x2198 <readImageData+0x180>
						useInterlace, &pass);
				break;
		}
	}

	if (lzwReadByte(&decomp) >= 0) {
    22be:	ce 01       	movw	r24, r28
    22c0:	06 96       	adiw	r24, 0x06	; 6
    22c2:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <lzwReadByte>
    22c6:	97 fd       	sbrc	r25, 7
    22c8:	04 c0       	rjmp	.+8      	; 0x22d2 <readImageData+0x2ba>
//		printf("Extraneous data at end of image.  Skipped to end of image\n");
		puts("E22");
    22ca:	8b e7       	ldi	r24, 0x7B	; 123
    22cc:	91 e0       	ldi	r25, 0x01	; 1
    22ce:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
}


static void
termStack(stack * const stack) {
	free(stack->stack);
    22d2:	8e 81       	ldd	r24, Y+6	; 0x06
    22d4:	9f 81       	ldd	r25, Y+7	; 0x07
    22d6:	0e 94 9e 1a 	call	0x353c	; 0x353c <free>
//		printf("Extraneous data at end of image.  Skipped to end of image\n");
		puts("E22");
	}

	lzwTerm(&decomp);
}
    22da:	cc 5d       	subi	r28, 0xDC	; 220
    22dc:	de 4f       	sbci	r29, 0xFE	; 254
    22de:	0f b6       	in	r0, 0x3f	; 63
    22e0:	f8 94       	cli
    22e2:	de bf       	out	0x3e, r29	; 62
    22e4:	0f be       	out	0x3f, r0	; 63
    22e6:	cd bf       	out	0x3d, r28	; 61
    22e8:	cf 91       	pop	r28
    22ea:	df 91       	pop	r29
    22ec:	1f 91       	pop	r17
    22ee:	0f 91       	pop	r16
    22f0:	ff 90       	pop	r15
    22f2:	ef 90       	pop	r14
    22f4:	df 90       	pop	r13
    22f6:	cf 90       	pop	r12
    22f8:	bf 90       	pop	r11
    22fa:	af 90       	pop	r10
    22fc:	9f 90       	pop	r9
    22fe:	8f 90       	pop	r8
    2300:	7f 90       	pop	r7
    2302:	6f 90       	pop	r6
    2304:	5f 90       	pop	r5
    2306:	4f 90       	pop	r4
    2308:	3f 90       	pop	r3
    230a:	2f 90       	pop	r2
    230c:	08 95       	ret

0000230e <img_freearray>:
	return (pixel**)rowIndex;
}


void
img_freearray(pixel ** const rowIndex, uint16_t const rows) {
    230e:	cf 92       	push	r12
    2310:	df 92       	push	r13
    2312:	ef 92       	push	r14
    2314:	ff 92       	push	r15
    2316:	0f 93       	push	r16
    2318:	1f 93       	push	r17
    231a:	cf 93       	push	r28
    231c:	df 93       	push	r29
    231e:	8c 01       	movw	r16, r24
    2320:	6b 01       	movw	r12, r22
	void * const rowheap = rowIndex[rows];
    2322:	fb 01       	movw	r30, r22
    2324:	ee 0f       	add	r30, r30
    2326:	ff 1f       	adc	r31, r31
    2328:	e0 0f       	add	r30, r16
    232a:	f1 1f       	adc	r31, r17
    232c:	80 81       	ld	r24, Z
    232e:	91 81       	ldd	r25, Z+1	; 0x01

	if (rowheap != NULL)
    2330:	00 97       	sbiw	r24, 0x00	; 0
    2332:	21 f4       	brne	.+8      	; 0x233c <img_freearray+0x2e>
    2334:	78 01       	movw	r14, r16
    2336:	c0 e0       	ldi	r28, 0x00	; 0
    2338:	d0 e0       	ldi	r29, 0x00	; 0
    233a:	0a c0       	rjmp	.+20     	; 0x2350 <img_freearray+0x42>
		free(rowheap);
    233c:	0e 94 9e 1a 	call	0x353c	; 0x353c <free>
    2340:	0a c0       	rjmp	.+20     	; 0x2356 <img_freearray+0x48>
	else {
		uint16_t row;
		for (row = 0; row < rows; ++row) {
			free(rowIndex[row]);
    2342:	f7 01       	movw	r30, r14
    2344:	81 91       	ld	r24, Z+
    2346:	91 91       	ld	r25, Z+
    2348:	7f 01       	movw	r14, r30
    234a:	0e 94 9e 1a 	call	0x353c	; 0x353c <free>

	if (rowheap != NULL)
		free(rowheap);
	else {
		uint16_t row;
		for (row = 0; row < rows; ++row) {
    234e:	21 96       	adiw	r28, 0x01	; 1
    2350:	cc 15       	cp	r28, r12
    2352:	dd 05       	cpc	r29, r13
    2354:	b0 f3       	brcs	.-20     	; 0x2342 <img_freearray+0x34>
			free(rowIndex[row]);
		}
	}
	free(rowIndex);
    2356:	c8 01       	movw	r24, r16
    2358:	0e 94 9e 1a 	call	0x353c	; 0x353c <free>
}
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	1f 91       	pop	r17
    2362:	0f 91       	pop	r16
    2364:	ff 90       	pop	r15
    2366:	ef 90       	pop	r14
    2368:	df 90       	pop	r13
    236a:	cf 90       	pop	r12
    236c:	08 95       	ret

0000236e <convertImages>:
//	printf("res: %d\n", res);
}


void
convertImages(FILE * const gifFile) {
    236e:	2f 92       	push	r2
    2370:	3f 92       	push	r3
    2372:	4f 92       	push	r4
    2374:	5f 92       	push	r5
    2376:	6f 92       	push	r6
    2378:	7f 92       	push	r7
    237a:	8f 92       	push	r8
    237c:	9f 92       	push	r9
    237e:	af 92       	push	r10
    2380:	bf 92       	push	r11
    2382:	cf 92       	push	r12
    2384:	df 92       	push	r13
    2386:	ef 92       	push	r14
    2388:	ff 92       	push	r15
    238a:	0f 93       	push	r16
    238c:	1f 93       	push	r17
    238e:	df 93       	push	r29
    2390:	cf 93       	push	r28
    2392:	cd b7       	in	r28, 0x3d	; 61
    2394:	de b7       	in	r29, 0x3e	; 62
    2396:	c2 55       	subi	r28, 0x52	; 82
    2398:	d0 40       	sbci	r29, 0x00	; 0
    239a:	0f b6       	in	r0, 0x3f	; 63
    239c:	f8 94       	cli
    239e:	de bf       	out	0x3e, r29	; 62
    23a0:	0f be       	out	0x3f, r0	; 63
    23a2:	cd bf       	out	0x3d, r28	; 61
    23a4:	3c 01       	movw	r6, r24
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    23a6:	8e 01       	movw	r16, r28
    23a8:	01 5f       	subi	r16, 0xF1	; 241
    23aa:	1f 4f       	sbci	r17, 0xFF	; 255
    23ac:	c8 01       	movw	r24, r16
    23ae:	66 e0       	ldi	r22, 0x06	; 6
    23b0:	70 e0       	ldi	r23, 0x00	; 0
    23b2:	ae 01       	movw	r20, r28
    23b4:	4f 5f       	subi	r20, 0xFF	; 255
    23b6:	5f 4f       	sbci	r21, 0xFF	; 255
    23b8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
	  -----------------------------------------------------------------------------*/
	uint8_t buf[16];
	char version[4];


	if (!ReadOK(gifFile, buf, 6)) {
    23bc:	89 81       	ldd	r24, Y+1	; 0x01
    23be:	9a 81       	ldd	r25, Y+2	; 0x02
    23c0:	89 2b       	or	r24, r25
    23c2:	19 f4       	brne	.+6      	; 0x23ca <convertImages+0x5c>
//		printf("error reading magic number\n" );
		puts("E23");
    23c4:	8f e7       	ldi	r24, 0x7F	; 127
    23c6:	91 e0       	ldi	r25, 0x01	; 1
    23c8:	0b c0       	rjmp	.+22     	; 0x23e0 <convertImages+0x72>
		exit(1);
	}

	// check file signature //
	if (strncmp((char *)buf, "GIF", 3) != 0) {
    23ca:	c8 01       	movw	r24, r16
    23cc:	63 e8       	ldi	r22, 0x83	; 131
    23ce:	71 e0       	ldi	r23, 0x01	; 1
    23d0:	43 e0       	ldi	r20, 0x03	; 3
    23d2:	50 e0       	ldi	r21, 0x00	; 0
    23d4:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <strncmp>
    23d8:	00 97       	sbiw	r24, 0x00	; 0
    23da:	41 f0       	breq	.+16     	; 0x23ec <convertImages+0x7e>
//		printf("File does not contain a GIF stream.  It does not start with 'GIF'.\n");
		puts("E24");
    23dc:	87 e8       	ldi	r24, 0x87	; 135
    23de:	91 e0       	ldi	r25, 0x01	; 1
    23e0:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
		exit(1);
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_exit>
	}

	// check version //
	strncpy(version, (char *)buf + 3, 3);
    23ec:	8e 01       	movw	r16, r28
    23ee:	0b 5f       	subi	r16, 0xFB	; 251
    23f0:	1f 4f       	sbci	r17, 0xFF	; 255
    23f2:	c8 01       	movw	r24, r16
    23f4:	be 01       	movw	r22, r28
    23f6:	6e 5e       	subi	r22, 0xEE	; 238
    23f8:	7f 4f       	sbci	r23, 0xFF	; 255
    23fa:	43 e0       	ldi	r20, 0x03	; 3
    23fc:	50 e0       	ldi	r21, 0x00	; 0
    23fe:	0e 94 0d 1b 	call	0x361a	; 0x361a <strncpy>
	version[3] = '\0';
    2402:	18 86       	std	Y+8, r1	; 0x08

	if (strcmp(version, "87a") != 0 && strcmp(version, "89a")) {
    2404:	c8 01       	movw	r24, r16
    2406:	6b e8       	ldi	r22, 0x8B	; 139
    2408:	71 e0       	ldi	r23, 0x01	; 1
    240a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <strcmp>
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	51 f0       	breq	.+20     	; 0x2426 <convertImages+0xb8>
    2412:	c8 01       	movw	r24, r16
    2414:	6f e8       	ldi	r22, 0x8F	; 143
    2416:	71 e0       	ldi	r23, 0x01	; 1
    2418:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <strcmp>
    241c:	00 97       	sbiw	r24, 0x00	; 0
    241e:	19 f0       	breq	.+6      	; 0x2426 <convertImages+0xb8>
//		printf("bad version number, not '87a' or '89a'\n" );
		puts("E25");
    2420:	83 e9       	ldi	r24, 0x93	; 147
    2422:	91 e0       	ldi	r25, 0x01	; 1
    2424:	dd cf       	rjmp	.-70     	; 0x23e0 <convertImages+0x72>
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    2426:	ce 01       	movw	r24, r28
    2428:	0f 96       	adiw	r24, 0x0f	; 15
    242a:	67 e0       	ldi	r22, 0x07	; 7
    242c:	70 e0       	ldi	r23, 0x00	; 0
    242e:	ae 01       	movw	r20, r28
    2430:	4f 5f       	subi	r20, 0xFF	; 255
    2432:	5f 4f       	sbci	r21, 0xFF	; 255
    2434:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
	}

//	printf("GIF format version is '%s'\n", version);


	if (!ReadOK(gifFile, buf, 7)) {
    2438:	89 81       	ldd	r24, Y+1	; 0x01
    243a:	9a 81       	ldd	r25, Y+2	; 0x02
    243c:	89 2b       	or	r24, r25
    243e:	19 f4       	brne	.+6      	; 0x2446 <convertImages+0xd8>
//		printf("failed to read screen descriptor\n" );
		puts("E26");
    2440:	87 e9       	ldi	r24, 0x97	; 151
    2442:	91 e0       	ldi	r25, 0x01	; 1
    2444:	cd cf       	rjmp	.-102    	; 0x23e0 <convertImages+0x72>
		exit(1);
	}

	gifScreen->width = LM_to_uint(buf[0], buf[1]);
    2446:	98 89       	ldd	r25, Y+16	; 0x10
    2448:	80 e0       	ldi	r24, 0x00	; 0
    244a:	2f 85       	ldd	r18, Y+15	; 0x0f
    244c:	30 e0       	ldi	r19, 0x00	; 0
    244e:	82 2b       	or	r24, r18
    2450:	93 2b       	or	r25, r19
    2452:	98 a3       	std	Y+32, r25	; 0x20
    2454:	8f 8f       	std	Y+31, r24	; 0x1f
	gifScreen->height = LM_to_uint(buf[2], buf[3]);
    2456:	9a 89       	ldd	r25, Y+18	; 0x12
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	29 89       	ldd	r18, Y+17	; 0x11
    245c:	30 e0       	ldi	r19, 0x00	; 0
    245e:	82 2b       	or	r24, r18
    2460:	93 2b       	or	r25, r19
    2462:	9a a3       	std	Y+34, r25	; 0x22
    2464:	89 a3       	std	Y+33, r24	; 0x21
	gifScreen->colorResolution = (buf[4] & 0x70 >> 4) + 1;
    2466:	1b 89       	ldd	r17, Y+19	; 0x13
    2468:	81 2f       	mov	r24, r17
    246a:	87 70       	andi	r24, 0x07	; 7
    246c:	8f 5f       	subi	r24, 0xFF	; 255
    246e:	8b a3       	std	Y+35, r24	; 0x23
	gifScreen->background = buf[5];
    2470:	8c 89       	ldd	r24, Y+20	; 0x14
    2472:	8c a3       	std	Y+36, r24	; 0x24
	gifScreen->pixelAspectRatio = (buf[6] == 0) ?  1.0 : (buf[6] + 15.0) / 64.0;
    2474:	6d 89       	ldd	r22, Y+21	; 0x15
    2476:	66 23       	and	r22, r22
    2478:	29 f4       	brne	.+10     	; 0x2484 <convertImages+0x116>
    247a:	e0 e0       	ldi	r30, 0x00	; 0
    247c:	70 e0       	ldi	r23, 0x00	; 0
    247e:	80 e8       	ldi	r24, 0x80	; 128
    2480:	6f e3       	ldi	r22, 0x3F	; 63
    2482:	15 c0       	rjmp	.+42     	; 0x24ae <convertImages+0x140>
    2484:	70 e0       	ldi	r23, 0x00	; 0
    2486:	88 27       	eor	r24, r24
    2488:	77 fd       	sbrc	r23, 7
    248a:	80 95       	com	r24
    248c:	98 2f       	mov	r25, r24
    248e:	0e 94 ff 16 	call	0x2dfe	; 0x2dfe <__floatsisf>
    2492:	20 e0       	ldi	r18, 0x00	; 0
    2494:	30 e0       	ldi	r19, 0x00	; 0
    2496:	40 e7       	ldi	r20, 0x70	; 112
    2498:	51 e4       	ldi	r21, 0x41	; 65
    249a:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <__addsf3>
    249e:	20 e0       	ldi	r18, 0x00	; 0
    24a0:	30 e0       	ldi	r19, 0x00	; 0
    24a2:	40 e8       	ldi	r20, 0x80	; 128
    24a4:	5c e3       	ldi	r21, 0x3C	; 60
    24a6:	0e 94 d5 15 	call	0x2baa	; 0x2baa <__mulsf3>
    24aa:	e6 2f       	mov	r30, r22
    24ac:	69 2f       	mov	r22, r25
    24ae:	2e 2f       	mov	r18, r30
    24b0:	37 2f       	mov	r19, r23
    24b2:	48 2f       	mov	r20, r24
    24b4:	56 2f       	mov	r21, r22
    24b6:	c9 01       	movw	r24, r18
    24b8:	da 01       	movw	r26, r20
    24ba:	8d a3       	std	Y+37, r24	; 0x25
    24bc:	9e a3       	std	Y+38, r25	; 0x26
    24be:	af a3       	std	Y+39, r26	; 0x27
    24c0:	b8 a7       	std	Y+40, r27	; 0x28
	gifScreen->globalColorTableSize = 1 << ((buf[4] & 0x07) + 1);
    24c2:	81 2f       	mov	r24, r17
    24c4:	90 e0       	ldi	r25, 0x00	; 0
    24c6:	87 70       	andi	r24, 0x07	; 7
    24c8:	90 70       	andi	r25, 0x00	; 0
    24ca:	01 96       	adiw	r24, 0x01	; 1
    24cc:	41 e0       	ldi	r20, 0x01	; 1
    24ce:	50 e0       	ldi	r21, 0x00	; 0
    24d0:	02 c0       	rjmp	.+4      	; 0x24d6 <convertImages+0x168>
    24d2:	44 0f       	add	r20, r20
    24d4:	55 1f       	adc	r21, r21
    24d6:	8a 95       	dec	r24
    24d8:	e2 f7       	brpl	.-8      	; 0x24d2 <convertImages+0x164>
    24da:	5a a7       	std	Y+42, r21	; 0x2a
    24dc:	49 a7       	std	Y+41, r20	; 0x29
//			gifScreen->width, gifScreen->height, gifScreen->pixelAspectRatio);
//	printf("Colors = %d   Color Resolution = %d\n",
//			gifScreen->globalColorTableSize, gifScreen->colorResolution);

	// read global color table //
	if (BitSet(buf[4], COLORTABLE)) {
    24de:	17 ff       	sbrs	r17, 7
    24e0:	06 c0       	rjmp	.+12     	; 0x24ee <convertImages+0x180>
		readColorTable(gifFile, gifScreen->globalColorTable, gifScreen->globalColorTableSize);
    24e2:	c3 01       	movw	r24, r6
    24e4:	be 01       	movw	r22, r28
    24e6:	65 5d       	subi	r22, 0xD5	; 213
    24e8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ea:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <readColorTable>
	}

	// check aspect ration //
	/* if you need un-square pixel, it comment out */
	if (gifScreen->pixelAspectRatio != 1.0) {
    24ee:	6d a1       	ldd	r22, Y+37	; 0x25
    24f0:	7e a1       	ldd	r23, Y+38	; 0x26
    24f2:	8f a1       	ldd	r24, Y+39	; 0x27
    24f4:	98 a5       	ldd	r25, Y+40	; 0x28
    24f6:	20 e0       	ldi	r18, 0x00	; 0
    24f8:	30 e0       	ldi	r19, 0x00	; 0
    24fa:	40 e8       	ldi	r20, 0x80	; 128
    24fc:	5f e3       	ldi	r21, 0x3F	; 63
    24fe:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <__nesf2>
    2502:	88 23       	and	r24, r24
    2504:	21 f0       	breq	.+8      	; 0x250e <convertImages+0x1a0>
//		printf("warning - input pixels are not square!");
		puts("E27");
    2506:	8b e9       	ldi	r24, 0x9B	; 155
    2508:	91 e0       	ldi	r25, 0x01	; 1
    250a:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
	gifImageDesc gifImageDesc;
	bool eod = false;

	readGifHeader(gifFile, &gifScreen);

	if (gifScreen.width != LMC_WIDTH_COUNT || gifScreen.height != LMC_HEIGHT_COUNT) {
    250e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2510:	98 a1       	ldd	r25, Y+32	; 0x20
    2512:	40 97       	sbiw	r24, 0x10	; 16
    2514:	09 f0       	breq	.+2      	; 0x2518 <convertImages+0x1aa>
    2516:	78 c1       	rjmp	.+752    	; 0x2808 <convertImages+0x49a>
    2518:	89 a1       	ldd	r24, Y+33	; 0x21
    251a:	9a a1       	ldd	r25, Y+34	; 0x22
    251c:	0e 97       	sbiw	r24, 0x0e	; 14
    251e:	09 f0       	breq	.+2      	; 0x2522 <convertImages+0x1b4>
    2520:	73 c1       	rjmp	.+742    	; 0x2808 <convertImages+0x49a>
} gifImageDesc;


static void
initGifCtrl(gifCtrl * const gifCtrl) {
	gifCtrl->disposal = 0;
    2522:	19 86       	std	Y+9, r1	; 0x09
	gifCtrl->userInput = false;
    2524:	1a 86       	std	Y+10, r1	; 0x0a
	gifCtrl->delayTime = 0;
    2526:	1c 86       	std	Y+12, r1	; 0x0c
    2528:	1b 86       	std	Y+11, r1	; 0x0b
	gifCtrl->useTransparent = false;
    252a:	1d 86       	std	Y+13, r1	; 0x0d
	gifCtrl->transparentIndex = 0;
    252c:	1e 86       	std	Y+14, r1	; 0x0e
	gifImageDesc->leftPosition = LM_to_uint(buf[0], buf[1]);
	gifImageDesc->topPosition = LM_to_uint(buf[2], buf[3]);
	gifImageDesc->width = LM_to_uint(buf[4], buf[5]);
	gifImageDesc->height = LM_to_uint(buf[6], buf[7]);
	gifImageDesc->useInterlace = BitSet(buf[8], INTERLACE);
	gifImageDesc->useLocalColorTable = BitSet(buf[8], COLORTABLE);
    252e:	bb 24       	eor	r11, r11
    2530:	b3 94       	inc	r11
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    2532:	ce 01       	movw	r24, r28
    2534:	01 96       	adiw	r24, 0x01	; 1
    2536:	61 e0       	ldi	r22, 0x01	; 1
    2538:	70 e0       	ldi	r23, 0x00	; 0
    253a:	ae 01       	movw	r20, r28
    253c:	4d 5f       	subi	r20, 0xFD	; 253
    253e:	5f 4f       	sbci	r21, 0xFF	; 255
    2540:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>

	// read the image descriptor //
	while (!imageStart && !(*eod)) {
		uint8_t c;

		if (!ReadOK(gifFile, &c, 1)) {
    2544:	8b 81       	ldd	r24, Y+3	; 0x03
    2546:	9c 81       	ldd	r25, Y+4	; 0x04
    2548:	89 2b       	or	r24, r25
    254a:	19 f4       	brne	.+6      	; 0x2552 <convertImages+0x1e4>
//			printf("EOF / read error on image data\n" );
			puts("E28");
    254c:	8f e9       	ldi	r24, 0x9F	; 159
    254e:	91 e0       	ldi	r25, 0x01	; 1
    2550:	47 cf       	rjmp	.-370    	; 0x23e0 <convertImages+0x72>
			exit(1);
		}

		if (c == ';') {  // GIF terminator
    2552:	89 81       	ldd	r24, Y+1	; 0x01
    2554:	8b 33       	cpi	r24, 0x3B	; 59
    2556:	09 f4       	brne	.+2      	; 0x255a <convertImages+0x1ec>
    2558:	57 c1       	rjmp	.+686    	; 0x2808 <convertImages+0x49a>
			*eod = true;
		} else if (c == '!') {  // Extension
    255a:	81 32       	cpi	r24, 0x21	; 33
    255c:	f1 f4       	brne	.+60     	; 0x259a <convertImages+0x22c>
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    255e:	ce 01       	movw	r24, r28
    2560:	01 96       	adiw	r24, 0x01	; 1
    2562:	61 e0       	ldi	r22, 0x01	; 1
    2564:	70 e0       	ldi	r23, 0x00	; 0
    2566:	ae 01       	movw	r20, r28
    2568:	4d 5f       	subi	r20, 0xFD	; 253
    256a:	5f 4f       	sbci	r21, 0xFF	; 255
    256c:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
		}

		if (c == ';') {  // GIF terminator
			*eod = true;
		} else if (c == '!') {  // Extension
			if (!ReadOK(gifFile, &c, 1)) {
    2570:	8b 81       	ldd	r24, Y+3	; 0x03
    2572:	9c 81       	ldd	r25, Y+4	; 0x04
    2574:	89 2b       	or	r24, r25
    2576:	19 f4       	brne	.+6      	; 0x257e <convertImages+0x210>
//				printf("EOF / read error on extension function code\n");
				puts("E29");
    2578:	83 ea       	ldi	r24, 0xA3	; 163
    257a:	91 e0       	ldi	r25, 0x01	; 1
    257c:	31 cf       	rjmp	.-414    	; 0x23e0 <convertImages+0x72>

static void
doExtension(FILE * const gifFile, uint8_t const label, gifCtrl * const gifCtrl) {
//	const char * str;

	switch (label) {
    257e:	89 81       	ldd	r24, Y+1	; 0x01
    2580:	89 3f       	cpi	r24, 0xF9	; 249
    2582:	39 f4       	brne	.+14     	; 0x2592 <convertImages+0x224>
			readThroughEod(gifFile);
			break;

		case GRAPHICCONTROL_EXTENSION:
//			str = "Graphic Control";
			doGraphicControlExtension(gifFile, gifCtrl);
    2584:	c3 01       	movw	r24, r6
    2586:	be 01       	movw	r22, r28
    2588:	67 5f       	subi	r22, 0xF7	; 247
    258a:	7f 4f       	sbci	r23, 0xFF	; 255
    258c:	0e 94 cb 0c 	call	0x1996	; 0x1996 <doGraphicControlExtension>
    2590:	d0 cf       	rjmp	.-96     	; 0x2532 <convertImages+0x1c4>
			{
//				char buf[256];
//				str = buf;
//				sprintf(buf, "UNKNOWN (0x%02x)", label);
//				printf("Ignoring unrecognized extension (type 0x%02x)\n", label);
				readThroughEod(gifFile);
    2592:	c3 01       	movw	r24, r6
    2594:	0e 94 84 0c 	call	0x1908	; 0x1908 <readThroughEod>
    2598:	cc cf       	rjmp	.-104    	; 0x2532 <convertImages+0x1c4>
//				printf("EOF / read error on extension function code\n");
				puts("E29");
				exit(1);
			}
			doExtension(gifFile, c, gifCtrl);
		} else if (c == ',') {
    259a:	8c 32       	cpi	r24, 0x2C	; 44
    259c:	29 f0       	breq	.+10     	; 0x25a8 <convertImages+0x23a>
			imageStart = true;
		} else {
//			printf("bogus character 0x%02x, ignoring\n", c);
			puts("E30");
    259e:	87 ea       	ldi	r24, 0xA7	; 167
    25a0:	91 e0       	ldi	r25, 0x01	; 1
    25a2:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <puts>
    25a6:	c5 cf       	rjmp	.-118    	; 0x2532 <convertImages+0x1c4>
static inline bool
ReadOK(FILE * const file, uint8_t * const buffer, size_t const len) {
	FRESULT res;
	WORD bytesRead;

	res = pf_read((WORD*)buffer, len, &bytesRead);
    25a8:	ce 01       	movw	r24, r28
    25aa:	0f 96       	adiw	r24, 0x0f	; 15
    25ac:	69 e0       	ldi	r22, 0x09	; 9
    25ae:	70 e0       	ldi	r23, 0x00	; 0
    25b0:	ae 01       	movw	r20, r28
    25b2:	4d 5f       	subi	r20, 0xFD	; 253
    25b4:	5f 4f       	sbci	r21, 0xFF	; 255
    25b6:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <pf_read>
	  Read a single GIF image from the current position of file.
	  -----------------------------------------------------------------------------*/
	uint8_t buf[16];
	pixel **pixels;

	if (!ReadOK(gifFile, buf, 9)) {
    25ba:	8b 81       	ldd	r24, Y+3	; 0x03
    25bc:	9c 81       	ldd	r25, Y+4	; 0x04
    25be:	89 2b       	or	r24, r25
    25c0:	19 f4       	brne	.+6      	; 0x25c8 <convertImages+0x25a>
//		printf("couldn't read left/top/width/height\n");
		puts("E31");
    25c2:	8b ea       	ldi	r24, 0xAB	; 171
    25c4:	91 e0       	ldi	r25, 0x01	; 1
    25c6:	0c cf       	rjmp	.-488    	; 0x23e0 <convertImages+0x72>
		exit(1);
	}

	gifImageDesc->leftPosition = LM_to_uint(buf[0], buf[1]);
    25c8:	28 89       	ldd	r18, Y+16	; 0x10
    25ca:	61 96       	adiw	r28, 0x11	; 17
    25cc:	2f af       	std	Y+63, r18	; 0x3f
    25ce:	61 97       	sbiw	r28, 0x11	; 17
    25d0:	60 96       	adiw	r28, 0x10	; 16
    25d2:	1f ae       	std	Y+63, r1	; 0x3f
    25d4:	60 97       	sbiw	r28, 0x10	; 16
    25d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	61 96       	adiw	r28, 0x11	; 17
    25dc:	ee ad       	ldd	r30, Y+62	; 0x3e
    25de:	ff ad       	ldd	r31, Y+63	; 0x3f
    25e0:	61 97       	sbiw	r28, 0x11	; 17
    25e2:	8e 2b       	or	r24, r30
    25e4:	9f 2b       	or	r25, r31
    25e6:	98 af       	std	Y+56, r25	; 0x38
    25e8:	8f ab       	std	Y+55, r24	; 0x37
	gifImageDesc->topPosition = LM_to_uint(buf[2], buf[3]);
    25ea:	fa 89       	ldd	r31, Y+18	; 0x12
    25ec:	63 96       	adiw	r28, 0x13	; 19
    25ee:	ff af       	std	Y+63, r31	; 0x3f
    25f0:	63 97       	sbiw	r28, 0x13	; 19
    25f2:	62 96       	adiw	r28, 0x12	; 18
    25f4:	1f ae       	std	Y+63, r1	; 0x3f
    25f6:	62 97       	sbiw	r28, 0x12	; 18
    25f8:	89 89       	ldd	r24, Y+17	; 0x11
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	63 96       	adiw	r28, 0x13	; 19
    25fe:	2e ad       	ldd	r18, Y+62	; 0x3e
    2600:	3f ad       	ldd	r19, Y+63	; 0x3f
    2602:	63 97       	sbiw	r28, 0x13	; 19
    2604:	82 2b       	or	r24, r18
    2606:	93 2b       	or	r25, r19
    2608:	9a af       	std	Y+58, r25	; 0x3a
    260a:	89 af       	std	Y+57, r24	; 0x39
	gifImageDesc->width = LM_to_uint(buf[4], buf[5]);
    260c:	3c 88       	ldd	r3, Y+20	; 0x14
    260e:	22 24       	eor	r2, r2
    2610:	8b 89       	ldd	r24, Y+19	; 0x13
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	82 29       	or	r24, r2
    2616:	93 29       	or	r25, r3
    2618:	9c af       	std	Y+60, r25	; 0x3c
    261a:	8b af       	std	Y+59, r24	; 0x3b
	gifImageDesc->height = LM_to_uint(buf[6], buf[7]);
    261c:	5e 88       	ldd	r5, Y+22	; 0x16
    261e:	44 24       	eor	r4, r4
    2620:	8d 89       	ldd	r24, Y+21	; 0x15
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	84 29       	or	r24, r4
    2626:	95 29       	or	r25, r5
    2628:	9e af       	std	Y+62, r25	; 0x3e
    262a:	8d af       	std	Y+61, r24	; 0x3d
	gifImageDesc->useInterlace = BitSet(buf[8], INTERLACE);
    262c:	4f 89       	ldd	r20, Y+23	; 0x17
    262e:	24 2f       	mov	r18, r20
    2630:	30 e0       	ldi	r19, 0x00	; 0
    2632:	c9 01       	movw	r24, r18
    2634:	56 e0       	ldi	r21, 0x06	; 6
    2636:	96 95       	lsr	r25
    2638:	87 95       	ror	r24
    263a:	5a 95       	dec	r21
    263c:	e1 f7       	brne	.-8      	; 0x2636 <convertImages+0x2c8>
    263e:	81 70       	andi	r24, 0x01	; 1
    2640:	8f af       	std	Y+63, r24	; 0x3f
	gifImageDesc->useLocalColorTable = BitSet(buf[8], COLORTABLE);
    2642:	44 23       	and	r20, r20
    2644:	44 0f       	add	r20, r20
    2646:	44 0b       	sbc	r20, r20
    2648:	4b 21       	and	r20, r11
    264a:	21 96       	adiw	r28, 0x01	; 1
    264c:	4f af       	std	Y+63, r20	; 0x3f
    264e:	21 97       	sbiw	r28, 0x01	; 1
	gifImageDesc->localColorTableSize = 1 << ((buf[8] & 0x07) + 1);
    2650:	27 70       	andi	r18, 0x07	; 7
    2652:	30 70       	andi	r19, 0x00	; 0
    2654:	2f 5f       	subi	r18, 0xFF	; 255
    2656:	3f 4f       	sbci	r19, 0xFF	; 255
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	02 c0       	rjmp	.+4      	; 0x2662 <convertImages+0x2f4>
    265e:	88 0f       	add	r24, r24
    2660:	99 1f       	adc	r25, r25
    2662:	2a 95       	dec	r18
    2664:	e2 f7       	brpl	.-8      	; 0x265e <convertImages+0x2f0>
    2666:	2f 96       	adiw	r28, 0x0f	; 15
    2668:	9f af       	std	Y+63, r25	; 0x3f
    266a:	8e af       	std	Y+62, r24	; 0x3e
    266c:	2f 97       	sbiw	r28, 0x0f	; 15
//	} else {	
//		printf("  Uses global color table of %u colors\n", gifScreen->globalColorTableSize);
//	}


	pixels = img_allocarray(gifImageDesc->width, gifImageDesc->height);
    266e:	6d ad       	ldd	r22, Y+61	; 0x3d
    2670:	7e ad       	ldd	r23, Y+62	; 0x3e
    2672:	8b ad       	ldd	r24, Y+59	; 0x3b
    2674:	9c ad       	ldd	r25, Y+60	; 0x3c
    2676:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <img_allocarray>
    267a:	4c 01       	movw	r8, r24

	if (!pixels) {
    267c:	00 97       	sbiw	r24, 0x00	; 0
    267e:	19 f4       	brne	.+6      	; 0x2686 <convertImages+0x318>
//		printf("couldn't alloc space for image\n" );
		puts("E32");
    2680:	8f ea       	ldi	r24, 0xAF	; 175
    2682:	91 e0       	ldi	r25, 0x01	; 1
    2684:	ad ce       	rjmp	.-678    	; 0x23e0 <convertImages+0x72>
		exit(1);
	}

	if (gifImageDesc->useLocalColorTable) {
    2686:	21 96       	adiw	r28, 0x01	; 1
    2688:	8f ad       	ldd	r24, Y+63	; 0x3f
    268a:	21 97       	sbiw	r28, 0x01	; 1
    268c:	88 23       	and	r24, r24
    268e:	09 f4       	brne	.+2      	; 0x2692 <convertImages+0x324>
    2690:	61 c0       	rjmp	.+194    	; 0x2754 <convertImages+0x3e6>
		readColorTable(gifFile, gifImageDesc->localColorTable, gifImageDesc->localColorTableSize);
    2692:	2f 96       	adiw	r28, 0x0f	; 15
    2694:	4e ad       	ldd	r20, Y+62	; 0x3e
    2696:	5f ad       	ldd	r21, Y+63	; 0x3f
    2698:	2f 97       	sbiw	r28, 0x0f	; 15
    269a:	c3 01       	movw	r24, r6
    269c:	be 01       	movw	r22, r28
    269e:	6f 5b       	subi	r22, 0xBF	; 191
    26a0:	7f 4f       	sbci	r23, 0xFF	; 255
    26a2:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <readColorTable>

		readImageData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height,
    26a6:	4b ad       	ldd	r20, Y+59	; 0x3b
    26a8:	5c ad       	ldd	r21, Y+60	; 0x3c
    26aa:	2d ad       	ldd	r18, Y+61	; 0x3d
    26ac:	3e ad       	ldd	r19, Y+62	; 0x3e
    26ae:	2f 96       	adiw	r28, 0x0f	; 15
    26b0:	ee ac       	ldd	r14, Y+62	; 0x3e
    26b2:	ff ac       	ldd	r15, Y+63	; 0x3f
    26b4:	2f 97       	sbiw	r28, 0x0f	; 15
    26b6:	c3 01       	movw	r24, r6
    26b8:	b4 01       	movw	r22, r8
    26ba:	8e 01       	movw	r16, r28
    26bc:	0f 5b       	subi	r16, 0xBF	; 191
    26be:	1f 4f       	sbci	r17, 0xFF	; 255
    26c0:	cf ac       	ldd	r12, Y+63	; 0x3f
    26c2:	ae 84       	ldd	r10, Y+14	; 0x0e
    26c4:	0e 94 0c 10 	call	0x2018	; 0x2018 <readImageData>
				gifImageDesc->localColorTable, gifImageDesc->localColorTableSize,
				gifImageDesc->useInterlace, gifCtrl->transparentIndex);

		writeData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height);
    26c8:	cb ac       	ldd	r12, Y+59	; 0x3b
    26ca:	dc ac       	ldd	r13, Y+60	; 0x3c
    26cc:	ed ac       	ldd	r14, Y+61	; 0x3d
    26ce:	fe ac       	ldd	r15, Y+62	; 0x3e
    26d0:	84 01       	movw	r16, r8
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	70 e0       	ldi	r23, 0x00	; 0
    26d6:	32 c0       	rjmp	.+100    	; 0x273c <convertImages+0x3ce>
//			g = pixels[y][x].g;
//			b = pixels[y][x].b;

//			value = (r * 3 + g * 6 + b * 1) / 10;

			if (value > 128 + 64) {
    26d8:	f8 01       	movw	r30, r16
    26da:	80 81       	ld	r24, Z
    26dc:	91 81       	ldd	r25, Z+1	; 0x01
    26de:	84 0f       	add	r24, r20
    26e0:	95 1f       	adc	r25, r21
    26e2:	fc 01       	movw	r30, r24
    26e4:	80 81       	ld	r24, Z
    26e6:	81 3c       	cpi	r24, 0xC1	; 193
    26e8:	70 f0       	brcs	.+28     	; 0x2706 <convertImages+0x398>
//				printf("XX");
				frame[y] |= (0x0001 << x);
    26ea:	2d 91       	ld	r18, X+
    26ec:	3c 91       	ld	r19, X
    26ee:	11 97       	sbiw	r26, 0x01	; 1
    26f0:	81 e0       	ldi	r24, 0x01	; 1
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	04 2e       	mov	r0, r20
    26f6:	02 c0       	rjmp	.+4      	; 0x26fc <convertImages+0x38e>
    26f8:	88 0f       	add	r24, r24
    26fa:	99 1f       	adc	r25, r25
    26fc:	0a 94       	dec	r0
    26fe:	e2 f7       	brpl	.-8      	; 0x26f8 <convertImages+0x38a>
    2700:	82 2b       	or	r24, r18
    2702:	93 2b       	or	r25, r19
    2704:	0f c0       	rjmp	.+30     	; 0x2724 <convertImages+0x3b6>
			} else {
//				printf("--");
				frame[y] &= ~(0x0001 << x);
    2706:	2d 91       	ld	r18, X+
    2708:	3c 91       	ld	r19, X
    270a:	11 97       	sbiw	r26, 0x01	; 1
    270c:	81 e0       	ldi	r24, 0x01	; 1
    270e:	90 e0       	ldi	r25, 0x00	; 0
    2710:	04 2e       	mov	r0, r20
    2712:	02 c0       	rjmp	.+4      	; 0x2718 <convertImages+0x3aa>
    2714:	88 0f       	add	r24, r24
    2716:	99 1f       	adc	r25, r25
    2718:	0a 94       	dec	r0
    271a:	e2 f7       	brpl	.-8      	; 0x2714 <convertImages+0x3a6>
    271c:	80 95       	com	r24
    271e:	90 95       	com	r25
    2720:	82 23       	and	r24, r18
    2722:	93 23       	and	r25, r19
    2724:	11 96       	adiw	r26, 0x01	; 1
    2726:	9c 93       	st	X, r25
    2728:	8e 93       	st	-X, r24
	uint16_t x, y;
//	uint8_t r, g, b, value;
	uint8_t value;

	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x++) {
    272a:	4f 5f       	subi	r20, 0xFF	; 255
    272c:	5f 4f       	sbci	r21, 0xFF	; 255
    272e:	4c 15       	cp	r20, r12
    2730:	5d 05       	cpc	r21, r13
    2732:	90 f2       	brcs	.-92     	; 0x26d8 <convertImages+0x36a>

	uint16_t x, y;
//	uint8_t r, g, b, value;
	uint8_t value;

	for (y = 0; y < height; y++) {
    2734:	6f 5f       	subi	r22, 0xFF	; 255
    2736:	7f 4f       	sbci	r23, 0xFF	; 255
    2738:	0e 5f       	subi	r16, 0xFE	; 254
    273a:	1f 4f       	sbci	r17, 0xFF	; 255
    273c:	6e 15       	cp	r22, r14
    273e:	7f 05       	cpc	r23, r15
    2740:	08 f0       	brcs	.+2      	; 0x2744 <convertImages+0x3d6>
    2742:	5c c0       	rjmp	.+184    	; 0x27fc <convertImages+0x48e>
    2744:	40 e0       	ldi	r20, 0x00	; 0
    2746:	50 e0       	ldi	r21, 0x00	; 0
    2748:	db 01       	movw	r26, r22
    274a:	aa 0f       	add	r26, r26
    274c:	bb 1f       	adc	r27, r27
			if (value > 128 + 64) {
//				printf("XX");
				frame[y] |= (0x0001 << x);
			} else {
//				printf("--");
				frame[y] &= ~(0x0001 << x);
    274e:	a5 5f       	subi	r26, 0xF5	; 245
    2750:	be 4f       	sbci	r27, 0xFE	; 254
    2752:	ed cf       	rjmp	.-38     	; 0x272e <convertImages+0x3c0>
				gifImageDesc->localColorTable, gifImageDesc->localColorTableSize,
				gifImageDesc->useInterlace, gifCtrl->transparentIndex);

		writeData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height);
	} else {
		readImageData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height, 
    2754:	4b ad       	ldd	r20, Y+59	; 0x3b
    2756:	5c ad       	ldd	r21, Y+60	; 0x3c
    2758:	2d ad       	ldd	r18, Y+61	; 0x3d
    275a:	3e ad       	ldd	r19, Y+62	; 0x3e
    275c:	e9 a4       	ldd	r14, Y+41	; 0x29
    275e:	fa a4       	ldd	r15, Y+42	; 0x2a
    2760:	c3 01       	movw	r24, r6
    2762:	b4 01       	movw	r22, r8
    2764:	8e 01       	movw	r16, r28
    2766:	05 5d       	subi	r16, 0xD5	; 213
    2768:	1f 4f       	sbci	r17, 0xFF	; 255
    276a:	cf ac       	ldd	r12, Y+63	; 0x3f
    276c:	ae 84       	ldd	r10, Y+14	; 0x0e
    276e:	0e 94 0c 10 	call	0x2018	; 0x2018 <readImageData>
				gifScreen->globalColorTable, gifScreen->globalColorTableSize,
				gifImageDesc->useInterlace, gifCtrl->transparentIndex);

		writeData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height);
    2772:	cb ac       	ldd	r12, Y+59	; 0x3b
    2774:	dc ac       	ldd	r13, Y+60	; 0x3c
    2776:	ed ac       	ldd	r14, Y+61	; 0x3d
    2778:	fe ac       	ldd	r15, Y+62	; 0x3e
    277a:	84 01       	movw	r16, r8
    277c:	60 e0       	ldi	r22, 0x00	; 0
    277e:	70 e0       	ldi	r23, 0x00	; 0
    2780:	32 c0       	rjmp	.+100    	; 0x27e6 <convertImages+0x478>
//			g = pixels[y][x].g;
//			b = pixels[y][x].b;

//			value = (r * 3 + g * 6 + b * 1) / 10;

			if (value > 128 + 64) {
    2782:	f8 01       	movw	r30, r16
    2784:	80 81       	ld	r24, Z
    2786:	91 81       	ldd	r25, Z+1	; 0x01
    2788:	84 0f       	add	r24, r20
    278a:	95 1f       	adc	r25, r21
    278c:	fc 01       	movw	r30, r24
    278e:	80 81       	ld	r24, Z
    2790:	81 3c       	cpi	r24, 0xC1	; 193
    2792:	70 f0       	brcs	.+28     	; 0x27b0 <convertImages+0x442>
//				printf("XX");
				frame[y] |= (0x0001 << x);
    2794:	2d 91       	ld	r18, X+
    2796:	3c 91       	ld	r19, X
    2798:	11 97       	sbiw	r26, 0x01	; 1
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	04 2e       	mov	r0, r20
    27a0:	02 c0       	rjmp	.+4      	; 0x27a6 <convertImages+0x438>
    27a2:	88 0f       	add	r24, r24
    27a4:	99 1f       	adc	r25, r25
    27a6:	0a 94       	dec	r0
    27a8:	e2 f7       	brpl	.-8      	; 0x27a2 <convertImages+0x434>
    27aa:	82 2b       	or	r24, r18
    27ac:	93 2b       	or	r25, r19
    27ae:	0f c0       	rjmp	.+30     	; 0x27ce <convertImages+0x460>
			} else {
//				printf("--");
				frame[y] &= ~(0x0001 << x);
    27b0:	2d 91       	ld	r18, X+
    27b2:	3c 91       	ld	r19, X
    27b4:	11 97       	sbiw	r26, 0x01	; 1
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	04 2e       	mov	r0, r20
    27bc:	02 c0       	rjmp	.+4      	; 0x27c2 <convertImages+0x454>
    27be:	88 0f       	add	r24, r24
    27c0:	99 1f       	adc	r25, r25
    27c2:	0a 94       	dec	r0
    27c4:	e2 f7       	brpl	.-8      	; 0x27be <convertImages+0x450>
    27c6:	80 95       	com	r24
    27c8:	90 95       	com	r25
    27ca:	82 23       	and	r24, r18
    27cc:	93 23       	and	r25, r19
    27ce:	11 96       	adiw	r26, 0x01	; 1
    27d0:	9c 93       	st	X, r25
    27d2:	8e 93       	st	-X, r24
	uint16_t x, y;
//	uint8_t r, g, b, value;
	uint8_t value;

	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x++) {
    27d4:	4f 5f       	subi	r20, 0xFF	; 255
    27d6:	5f 4f       	sbci	r21, 0xFF	; 255
    27d8:	4c 15       	cp	r20, r12
    27da:	5d 05       	cpc	r21, r13
    27dc:	90 f2       	brcs	.-92     	; 0x2782 <convertImages+0x414>

	uint16_t x, y;
//	uint8_t r, g, b, value;
	uint8_t value;

	for (y = 0; y < height; y++) {
    27de:	6f 5f       	subi	r22, 0xFF	; 255
    27e0:	7f 4f       	sbci	r23, 0xFF	; 255
    27e2:	0e 5f       	subi	r16, 0xFE	; 254
    27e4:	1f 4f       	sbci	r17, 0xFF	; 255
    27e6:	6e 15       	cp	r22, r14
    27e8:	7f 05       	cpc	r23, r15
    27ea:	40 f4       	brcc	.+16     	; 0x27fc <convertImages+0x48e>
    27ec:	40 e0       	ldi	r20, 0x00	; 0
    27ee:	50 e0       	ldi	r21, 0x00	; 0
    27f0:	db 01       	movw	r26, r22
    27f2:	aa 0f       	add	r26, r26
    27f4:	bb 1f       	adc	r27, r27
			if (value > 128 + 64) {
//				printf("XX");
				frame[y] |= (0x0001 << x);
			} else {
//				printf("--");
				frame[y] &= ~(0x0001 << x);
    27f6:	a5 5f       	subi	r26, 0xF5	; 245
    27f8:	be 4f       	sbci	r27, 0xFE	; 254
    27fa:	ee cf       	rjmp	.-36     	; 0x27d8 <convertImages+0x46a>
				gifImageDesc->useInterlace, gifCtrl->transparentIndex);

		writeData(gifFile, pixels, gifImageDesc->width, gifImageDesc->height);
	}

	img_freearray(pixels, gifImageDesc->height);
    27fc:	6d ad       	ldd	r22, Y+61	; 0x3d
    27fe:	7e ad       	ldd	r23, Y+62	; 0x3e
    2800:	c4 01       	movw	r24, r8
    2802:	0e 94 87 11 	call	0x230e	; 0x230e <img_freearray>
    2806:	95 ce       	rjmp	.-726    	; 0x2532 <convertImages+0x1c4>
//			puts("Reading Image Sequence");

			convertImage(gifFile, &gifScreen, &gifCtrl, &gifImageDesc);
		}
	}
}
    2808:	ce 5a       	subi	r28, 0xAE	; 174
    280a:	df 4f       	sbci	r29, 0xFF	; 255
    280c:	0f b6       	in	r0, 0x3f	; 63
    280e:	f8 94       	cli
    2810:	de bf       	out	0x3e, r29	; 62
    2812:	0f be       	out	0x3f, r0	; 63
    2814:	cd bf       	out	0x3d, r28	; 61
    2816:	cf 91       	pop	r28
    2818:	df 91       	pop	r29
    281a:	1f 91       	pop	r17
    281c:	0f 91       	pop	r16
    281e:	ff 90       	pop	r15
    2820:	ef 90       	pop	r14
    2822:	df 90       	pop	r13
    2824:	cf 90       	pop	r12
    2826:	bf 90       	pop	r11
    2828:	af 90       	pop	r10
    282a:	9f 90       	pop	r9
    282c:	8f 90       	pop	r8
    282e:	7f 90       	pop	r7
    2830:	6f 90       	pop	r6
    2832:	5f 90       	pop	r5
    2834:	4f 90       	pop	r4
    2836:	3f 90       	pop	r3
    2838:	2f 90       	pop	r2
    283a:	08 95       	ret

0000283c <gif_open>:

  -----------------------------------------------------------------------------*/
FATFS fs;

void
gif_open(const char * const name) {
    283c:	0f 93       	push	r16
    283e:	1f 93       	push	r17
    2840:	8c 01       	movw	r16, r24
	FRESULT res;

	res = pf_mount(&fs);
    2842:	8e ea       	ldi	r24, 0xAE	; 174
    2844:	93 e0       	ldi	r25, 0x03	; 3
    2846:	0e 94 38 08 	call	0x1070	; 0x1070 <pf_mount>
//	printf("res: %d\n", res);

	res = pf_open(name);
    284a:	c8 01       	movw	r24, r16
    284c:	0e 94 71 06 	call	0xce2	; 0xce2 <pf_open>
//	printf("res: %d\n", res);
}
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	08 95       	ret

00002856 <_fpadd_parts>:
    2856:	a0 e0       	ldi	r26, 0x00	; 0
    2858:	b0 e0       	ldi	r27, 0x00	; 0
    285a:	e1 e3       	ldi	r30, 0x31	; 49
    285c:	f4 e1       	ldi	r31, 0x14	; 20
    285e:	0c 94 ba 19 	jmp	0x3374	; 0x3374 <__prologue_saves__>
    2862:	dc 01       	movw	r26, r24
    2864:	2b 01       	movw	r4, r22
    2866:	fa 01       	movw	r30, r20
    2868:	9c 91       	ld	r25, X
    286a:	92 30       	cpi	r25, 0x02	; 2
    286c:	08 f4       	brcc	.+2      	; 0x2870 <_fpadd_parts+0x1a>
    286e:	39 c1       	rjmp	.+626    	; 0x2ae2 <_fpadd_parts+0x28c>
    2870:	eb 01       	movw	r28, r22
    2872:	88 81       	ld	r24, Y
    2874:	82 30       	cpi	r24, 0x02	; 2
    2876:	08 f4       	brcc	.+2      	; 0x287a <_fpadd_parts+0x24>
    2878:	33 c1       	rjmp	.+614    	; 0x2ae0 <_fpadd_parts+0x28a>
    287a:	94 30       	cpi	r25, 0x04	; 4
    287c:	69 f4       	brne	.+26     	; 0x2898 <_fpadd_parts+0x42>
    287e:	84 30       	cpi	r24, 0x04	; 4
    2880:	09 f0       	breq	.+2      	; 0x2884 <_fpadd_parts+0x2e>
    2882:	2f c1       	rjmp	.+606    	; 0x2ae2 <_fpadd_parts+0x28c>
    2884:	11 96       	adiw	r26, 0x01	; 1
    2886:	9c 91       	ld	r25, X
    2888:	11 97       	sbiw	r26, 0x01	; 1
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	98 17       	cp	r25, r24
    288e:	09 f4       	brne	.+2      	; 0x2892 <_fpadd_parts+0x3c>
    2890:	28 c1       	rjmp	.+592    	; 0x2ae2 <_fpadd_parts+0x28c>
    2892:	a3 eb       	ldi	r26, 0xB3	; 179
    2894:	b1 e0       	ldi	r27, 0x01	; 1
    2896:	25 c1       	rjmp	.+586    	; 0x2ae2 <_fpadd_parts+0x28c>
    2898:	84 30       	cpi	r24, 0x04	; 4
    289a:	09 f4       	brne	.+2      	; 0x289e <_fpadd_parts+0x48>
    289c:	21 c1       	rjmp	.+578    	; 0x2ae0 <_fpadd_parts+0x28a>
    289e:	82 30       	cpi	r24, 0x02	; 2
    28a0:	a9 f4       	brne	.+42     	; 0x28cc <_fpadd_parts+0x76>
    28a2:	92 30       	cpi	r25, 0x02	; 2
    28a4:	09 f0       	breq	.+2      	; 0x28a8 <_fpadd_parts+0x52>
    28a6:	1d c1       	rjmp	.+570    	; 0x2ae2 <_fpadd_parts+0x28c>
    28a8:	9a 01       	movw	r18, r20
    28aa:	ad 01       	movw	r20, r26
    28ac:	88 e0       	ldi	r24, 0x08	; 8
    28ae:	ea 01       	movw	r28, r20
    28b0:	09 90       	ld	r0, Y+
    28b2:	ae 01       	movw	r20, r28
    28b4:	e9 01       	movw	r28, r18
    28b6:	09 92       	st	Y+, r0
    28b8:	9e 01       	movw	r18, r28
    28ba:	81 50       	subi	r24, 0x01	; 1
    28bc:	c1 f7       	brne	.-16     	; 0x28ae <_fpadd_parts+0x58>
    28be:	e2 01       	movw	r28, r4
    28c0:	89 81       	ldd	r24, Y+1	; 0x01
    28c2:	11 96       	adiw	r26, 0x01	; 1
    28c4:	9c 91       	ld	r25, X
    28c6:	89 23       	and	r24, r25
    28c8:	81 83       	std	Z+1, r24	; 0x01
    28ca:	08 c1       	rjmp	.+528    	; 0x2adc <_fpadd_parts+0x286>
    28cc:	92 30       	cpi	r25, 0x02	; 2
    28ce:	09 f4       	brne	.+2      	; 0x28d2 <_fpadd_parts+0x7c>
    28d0:	07 c1       	rjmp	.+526    	; 0x2ae0 <_fpadd_parts+0x28a>
    28d2:	12 96       	adiw	r26, 0x02	; 2
    28d4:	2d 90       	ld	r2, X+
    28d6:	3c 90       	ld	r3, X
    28d8:	13 97       	sbiw	r26, 0x03	; 3
    28da:	eb 01       	movw	r28, r22
    28dc:	8a 81       	ldd	r24, Y+2	; 0x02
    28de:	9b 81       	ldd	r25, Y+3	; 0x03
    28e0:	14 96       	adiw	r26, 0x04	; 4
    28e2:	ad 90       	ld	r10, X+
    28e4:	bd 90       	ld	r11, X+
    28e6:	cd 90       	ld	r12, X+
    28e8:	dc 90       	ld	r13, X
    28ea:	17 97       	sbiw	r26, 0x07	; 7
    28ec:	ec 80       	ldd	r14, Y+4	; 0x04
    28ee:	fd 80       	ldd	r15, Y+5	; 0x05
    28f0:	0e 81       	ldd	r16, Y+6	; 0x06
    28f2:	1f 81       	ldd	r17, Y+7	; 0x07
    28f4:	91 01       	movw	r18, r2
    28f6:	28 1b       	sub	r18, r24
    28f8:	39 0b       	sbc	r19, r25
    28fa:	b9 01       	movw	r22, r18
    28fc:	37 ff       	sbrs	r19, 7
    28fe:	04 c0       	rjmp	.+8      	; 0x2908 <_fpadd_parts+0xb2>
    2900:	66 27       	eor	r22, r22
    2902:	77 27       	eor	r23, r23
    2904:	62 1b       	sub	r22, r18
    2906:	73 0b       	sbc	r23, r19
    2908:	60 32       	cpi	r22, 0x20	; 32
    290a:	71 05       	cpc	r23, r1
    290c:	0c f0       	brlt	.+2      	; 0x2910 <_fpadd_parts+0xba>
    290e:	61 c0       	rjmp	.+194    	; 0x29d2 <_fpadd_parts+0x17c>
    2910:	12 16       	cp	r1, r18
    2912:	13 06       	cpc	r1, r19
    2914:	6c f5       	brge	.+90     	; 0x2970 <_fpadd_parts+0x11a>
    2916:	37 01       	movw	r6, r14
    2918:	48 01       	movw	r8, r16
    291a:	06 2e       	mov	r0, r22
    291c:	04 c0       	rjmp	.+8      	; 0x2926 <_fpadd_parts+0xd0>
    291e:	96 94       	lsr	r9
    2920:	87 94       	ror	r8
    2922:	77 94       	ror	r7
    2924:	67 94       	ror	r6
    2926:	0a 94       	dec	r0
    2928:	d2 f7       	brpl	.-12     	; 0x291e <_fpadd_parts+0xc8>
    292a:	21 e0       	ldi	r18, 0x01	; 1
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	40 e0       	ldi	r20, 0x00	; 0
    2930:	50 e0       	ldi	r21, 0x00	; 0
    2932:	04 c0       	rjmp	.+8      	; 0x293c <_fpadd_parts+0xe6>
    2934:	22 0f       	add	r18, r18
    2936:	33 1f       	adc	r19, r19
    2938:	44 1f       	adc	r20, r20
    293a:	55 1f       	adc	r21, r21
    293c:	6a 95       	dec	r22
    293e:	d2 f7       	brpl	.-12     	; 0x2934 <_fpadd_parts+0xde>
    2940:	21 50       	subi	r18, 0x01	; 1
    2942:	30 40       	sbci	r19, 0x00	; 0
    2944:	40 40       	sbci	r20, 0x00	; 0
    2946:	50 40       	sbci	r21, 0x00	; 0
    2948:	2e 21       	and	r18, r14
    294a:	3f 21       	and	r19, r15
    294c:	40 23       	and	r20, r16
    294e:	51 23       	and	r21, r17
    2950:	21 15       	cp	r18, r1
    2952:	31 05       	cpc	r19, r1
    2954:	41 05       	cpc	r20, r1
    2956:	51 05       	cpc	r21, r1
    2958:	21 f0       	breq	.+8      	; 0x2962 <_fpadd_parts+0x10c>
    295a:	21 e0       	ldi	r18, 0x01	; 1
    295c:	30 e0       	ldi	r19, 0x00	; 0
    295e:	40 e0       	ldi	r20, 0x00	; 0
    2960:	50 e0       	ldi	r21, 0x00	; 0
    2962:	79 01       	movw	r14, r18
    2964:	8a 01       	movw	r16, r20
    2966:	e6 28       	or	r14, r6
    2968:	f7 28       	or	r15, r7
    296a:	08 29       	or	r16, r8
    296c:	19 29       	or	r17, r9
    296e:	3c c0       	rjmp	.+120    	; 0x29e8 <_fpadd_parts+0x192>
    2970:	23 2b       	or	r18, r19
    2972:	d1 f1       	breq	.+116    	; 0x29e8 <_fpadd_parts+0x192>
    2974:	26 0e       	add	r2, r22
    2976:	37 1e       	adc	r3, r23
    2978:	35 01       	movw	r6, r10
    297a:	46 01       	movw	r8, r12
    297c:	06 2e       	mov	r0, r22
    297e:	04 c0       	rjmp	.+8      	; 0x2988 <_fpadd_parts+0x132>
    2980:	96 94       	lsr	r9
    2982:	87 94       	ror	r8
    2984:	77 94       	ror	r7
    2986:	67 94       	ror	r6
    2988:	0a 94       	dec	r0
    298a:	d2 f7       	brpl	.-12     	; 0x2980 <_fpadd_parts+0x12a>
    298c:	21 e0       	ldi	r18, 0x01	; 1
    298e:	30 e0       	ldi	r19, 0x00	; 0
    2990:	40 e0       	ldi	r20, 0x00	; 0
    2992:	50 e0       	ldi	r21, 0x00	; 0
    2994:	04 c0       	rjmp	.+8      	; 0x299e <_fpadd_parts+0x148>
    2996:	22 0f       	add	r18, r18
    2998:	33 1f       	adc	r19, r19
    299a:	44 1f       	adc	r20, r20
    299c:	55 1f       	adc	r21, r21
    299e:	6a 95       	dec	r22
    29a0:	d2 f7       	brpl	.-12     	; 0x2996 <_fpadd_parts+0x140>
    29a2:	21 50       	subi	r18, 0x01	; 1
    29a4:	30 40       	sbci	r19, 0x00	; 0
    29a6:	40 40       	sbci	r20, 0x00	; 0
    29a8:	50 40       	sbci	r21, 0x00	; 0
    29aa:	2a 21       	and	r18, r10
    29ac:	3b 21       	and	r19, r11
    29ae:	4c 21       	and	r20, r12
    29b0:	5d 21       	and	r21, r13
    29b2:	21 15       	cp	r18, r1
    29b4:	31 05       	cpc	r19, r1
    29b6:	41 05       	cpc	r20, r1
    29b8:	51 05       	cpc	r21, r1
    29ba:	21 f0       	breq	.+8      	; 0x29c4 <_fpadd_parts+0x16e>
    29bc:	21 e0       	ldi	r18, 0x01	; 1
    29be:	30 e0       	ldi	r19, 0x00	; 0
    29c0:	40 e0       	ldi	r20, 0x00	; 0
    29c2:	50 e0       	ldi	r21, 0x00	; 0
    29c4:	59 01       	movw	r10, r18
    29c6:	6a 01       	movw	r12, r20
    29c8:	a6 28       	or	r10, r6
    29ca:	b7 28       	or	r11, r7
    29cc:	c8 28       	or	r12, r8
    29ce:	d9 28       	or	r13, r9
    29d0:	0b c0       	rjmp	.+22     	; 0x29e8 <_fpadd_parts+0x192>
    29d2:	82 15       	cp	r24, r2
    29d4:	93 05       	cpc	r25, r3
    29d6:	2c f0       	brlt	.+10     	; 0x29e2 <_fpadd_parts+0x18c>
    29d8:	1c 01       	movw	r2, r24
    29da:	aa 24       	eor	r10, r10
    29dc:	bb 24       	eor	r11, r11
    29de:	65 01       	movw	r12, r10
    29e0:	03 c0       	rjmp	.+6      	; 0x29e8 <_fpadd_parts+0x192>
    29e2:	ee 24       	eor	r14, r14
    29e4:	ff 24       	eor	r15, r15
    29e6:	87 01       	movw	r16, r14
    29e8:	11 96       	adiw	r26, 0x01	; 1
    29ea:	9c 91       	ld	r25, X
    29ec:	d2 01       	movw	r26, r4
    29ee:	11 96       	adiw	r26, 0x01	; 1
    29f0:	8c 91       	ld	r24, X
    29f2:	98 17       	cp	r25, r24
    29f4:	09 f4       	brne	.+2      	; 0x29f8 <_fpadd_parts+0x1a2>
    29f6:	45 c0       	rjmp	.+138    	; 0x2a82 <_fpadd_parts+0x22c>
    29f8:	99 23       	and	r25, r25
    29fa:	39 f0       	breq	.+14     	; 0x2a0a <_fpadd_parts+0x1b4>
    29fc:	a8 01       	movw	r20, r16
    29fe:	97 01       	movw	r18, r14
    2a00:	2a 19       	sub	r18, r10
    2a02:	3b 09       	sbc	r19, r11
    2a04:	4c 09       	sbc	r20, r12
    2a06:	5d 09       	sbc	r21, r13
    2a08:	06 c0       	rjmp	.+12     	; 0x2a16 <_fpadd_parts+0x1c0>
    2a0a:	a6 01       	movw	r20, r12
    2a0c:	95 01       	movw	r18, r10
    2a0e:	2e 19       	sub	r18, r14
    2a10:	3f 09       	sbc	r19, r15
    2a12:	40 0b       	sbc	r20, r16
    2a14:	51 0b       	sbc	r21, r17
    2a16:	57 fd       	sbrc	r21, 7
    2a18:	08 c0       	rjmp	.+16     	; 0x2a2a <_fpadd_parts+0x1d4>
    2a1a:	11 82       	std	Z+1, r1	; 0x01
    2a1c:	33 82       	std	Z+3, r3	; 0x03
    2a1e:	22 82       	std	Z+2, r2	; 0x02
    2a20:	24 83       	std	Z+4, r18	; 0x04
    2a22:	35 83       	std	Z+5, r19	; 0x05
    2a24:	46 83       	std	Z+6, r20	; 0x06
    2a26:	57 83       	std	Z+7, r21	; 0x07
    2a28:	1d c0       	rjmp	.+58     	; 0x2a64 <_fpadd_parts+0x20e>
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	81 83       	std	Z+1, r24	; 0x01
    2a2e:	33 82       	std	Z+3, r3	; 0x03
    2a30:	22 82       	std	Z+2, r2	; 0x02
    2a32:	88 27       	eor	r24, r24
    2a34:	99 27       	eor	r25, r25
    2a36:	dc 01       	movw	r26, r24
    2a38:	82 1b       	sub	r24, r18
    2a3a:	93 0b       	sbc	r25, r19
    2a3c:	a4 0b       	sbc	r26, r20
    2a3e:	b5 0b       	sbc	r27, r21
    2a40:	84 83       	std	Z+4, r24	; 0x04
    2a42:	95 83       	std	Z+5, r25	; 0x05
    2a44:	a6 83       	std	Z+6, r26	; 0x06
    2a46:	b7 83       	std	Z+7, r27	; 0x07
    2a48:	0d c0       	rjmp	.+26     	; 0x2a64 <_fpadd_parts+0x20e>
    2a4a:	22 0f       	add	r18, r18
    2a4c:	33 1f       	adc	r19, r19
    2a4e:	44 1f       	adc	r20, r20
    2a50:	55 1f       	adc	r21, r21
    2a52:	24 83       	std	Z+4, r18	; 0x04
    2a54:	35 83       	std	Z+5, r19	; 0x05
    2a56:	46 83       	std	Z+6, r20	; 0x06
    2a58:	57 83       	std	Z+7, r21	; 0x07
    2a5a:	82 81       	ldd	r24, Z+2	; 0x02
    2a5c:	93 81       	ldd	r25, Z+3	; 0x03
    2a5e:	01 97       	sbiw	r24, 0x01	; 1
    2a60:	93 83       	std	Z+3, r25	; 0x03
    2a62:	82 83       	std	Z+2, r24	; 0x02
    2a64:	24 81       	ldd	r18, Z+4	; 0x04
    2a66:	35 81       	ldd	r19, Z+5	; 0x05
    2a68:	46 81       	ldd	r20, Z+6	; 0x06
    2a6a:	57 81       	ldd	r21, Z+7	; 0x07
    2a6c:	da 01       	movw	r26, r20
    2a6e:	c9 01       	movw	r24, r18
    2a70:	01 97       	sbiw	r24, 0x01	; 1
    2a72:	a1 09       	sbc	r26, r1
    2a74:	b1 09       	sbc	r27, r1
    2a76:	8f 5f       	subi	r24, 0xFF	; 255
    2a78:	9f 4f       	sbci	r25, 0xFF	; 255
    2a7a:	af 4f       	sbci	r26, 0xFF	; 255
    2a7c:	bf 43       	sbci	r27, 0x3F	; 63
    2a7e:	28 f3       	brcs	.-54     	; 0x2a4a <_fpadd_parts+0x1f4>
    2a80:	0b c0       	rjmp	.+22     	; 0x2a98 <_fpadd_parts+0x242>
    2a82:	91 83       	std	Z+1, r25	; 0x01
    2a84:	33 82       	std	Z+3, r3	; 0x03
    2a86:	22 82       	std	Z+2, r2	; 0x02
    2a88:	ea 0c       	add	r14, r10
    2a8a:	fb 1c       	adc	r15, r11
    2a8c:	0c 1d       	adc	r16, r12
    2a8e:	1d 1d       	adc	r17, r13
    2a90:	e4 82       	std	Z+4, r14	; 0x04
    2a92:	f5 82       	std	Z+5, r15	; 0x05
    2a94:	06 83       	std	Z+6, r16	; 0x06
    2a96:	17 83       	std	Z+7, r17	; 0x07
    2a98:	83 e0       	ldi	r24, 0x03	; 3
    2a9a:	80 83       	st	Z, r24
    2a9c:	24 81       	ldd	r18, Z+4	; 0x04
    2a9e:	35 81       	ldd	r19, Z+5	; 0x05
    2aa0:	46 81       	ldd	r20, Z+6	; 0x06
    2aa2:	57 81       	ldd	r21, Z+7	; 0x07
    2aa4:	57 ff       	sbrs	r21, 7
    2aa6:	1a c0       	rjmp	.+52     	; 0x2adc <_fpadd_parts+0x286>
    2aa8:	c9 01       	movw	r24, r18
    2aaa:	aa 27       	eor	r26, r26
    2aac:	97 fd       	sbrc	r25, 7
    2aae:	a0 95       	com	r26
    2ab0:	ba 2f       	mov	r27, r26
    2ab2:	81 70       	andi	r24, 0x01	; 1
    2ab4:	90 70       	andi	r25, 0x00	; 0
    2ab6:	a0 70       	andi	r26, 0x00	; 0
    2ab8:	b0 70       	andi	r27, 0x00	; 0
    2aba:	56 95       	lsr	r21
    2abc:	47 95       	ror	r20
    2abe:	37 95       	ror	r19
    2ac0:	27 95       	ror	r18
    2ac2:	82 2b       	or	r24, r18
    2ac4:	93 2b       	or	r25, r19
    2ac6:	a4 2b       	or	r26, r20
    2ac8:	b5 2b       	or	r27, r21
    2aca:	84 83       	std	Z+4, r24	; 0x04
    2acc:	95 83       	std	Z+5, r25	; 0x05
    2ace:	a6 83       	std	Z+6, r26	; 0x06
    2ad0:	b7 83       	std	Z+7, r27	; 0x07
    2ad2:	82 81       	ldd	r24, Z+2	; 0x02
    2ad4:	93 81       	ldd	r25, Z+3	; 0x03
    2ad6:	01 96       	adiw	r24, 0x01	; 1
    2ad8:	93 83       	std	Z+3, r25	; 0x03
    2ada:	82 83       	std	Z+2, r24	; 0x02
    2adc:	df 01       	movw	r26, r30
    2ade:	01 c0       	rjmp	.+2      	; 0x2ae2 <_fpadd_parts+0x28c>
    2ae0:	d2 01       	movw	r26, r4
    2ae2:	cd 01       	movw	r24, r26
    2ae4:	cd b7       	in	r28, 0x3d	; 61
    2ae6:	de b7       	in	r29, 0x3e	; 62
    2ae8:	e2 e1       	ldi	r30, 0x12	; 18
    2aea:	0c 94 d6 19 	jmp	0x33ac	; 0x33ac <__epilogue_restores__>

00002aee <__subsf3>:
    2aee:	a0 e2       	ldi	r26, 0x20	; 32
    2af0:	b0 e0       	ldi	r27, 0x00	; 0
    2af2:	ed e7       	ldi	r30, 0x7D	; 125
    2af4:	f5 e1       	ldi	r31, 0x15	; 21
    2af6:	0c 94 c6 19 	jmp	0x338c	; 0x338c <__prologue_saves__+0x18>
    2afa:	69 83       	std	Y+1, r22	; 0x01
    2afc:	7a 83       	std	Y+2, r23	; 0x02
    2afe:	8b 83       	std	Y+3, r24	; 0x03
    2b00:	9c 83       	std	Y+4, r25	; 0x04
    2b02:	2d 83       	std	Y+5, r18	; 0x05
    2b04:	3e 83       	std	Y+6, r19	; 0x06
    2b06:	4f 83       	std	Y+7, r20	; 0x07
    2b08:	58 87       	std	Y+8, r21	; 0x08
    2b0a:	e9 e0       	ldi	r30, 0x09	; 9
    2b0c:	ee 2e       	mov	r14, r30
    2b0e:	f1 2c       	mov	r15, r1
    2b10:	ec 0e       	add	r14, r28
    2b12:	fd 1e       	adc	r15, r29
    2b14:	ce 01       	movw	r24, r28
    2b16:	01 96       	adiw	r24, 0x01	; 1
    2b18:	b7 01       	movw	r22, r14
    2b1a:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2b1e:	8e 01       	movw	r16, r28
    2b20:	0f 5e       	subi	r16, 0xEF	; 239
    2b22:	1f 4f       	sbci	r17, 0xFF	; 255
    2b24:	ce 01       	movw	r24, r28
    2b26:	05 96       	adiw	r24, 0x05	; 5
    2b28:	b8 01       	movw	r22, r16
    2b2a:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2b2e:	8a 89       	ldd	r24, Y+18	; 0x12
    2b30:	91 e0       	ldi	r25, 0x01	; 1
    2b32:	89 27       	eor	r24, r25
    2b34:	8a 8b       	std	Y+18, r24	; 0x12
    2b36:	c7 01       	movw	r24, r14
    2b38:	b8 01       	movw	r22, r16
    2b3a:	ae 01       	movw	r20, r28
    2b3c:	47 5e       	subi	r20, 0xE7	; 231
    2b3e:	5f 4f       	sbci	r21, 0xFF	; 255
    2b40:	0e 94 2b 14 	call	0x2856	; 0x2856 <_fpadd_parts>
    2b44:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <__pack_f>
    2b48:	a0 96       	adiw	r28, 0x20	; 32
    2b4a:	e6 e0       	ldi	r30, 0x06	; 6
    2b4c:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__epilogue_restores__+0x18>

00002b50 <__addsf3>:
    2b50:	a0 e2       	ldi	r26, 0x20	; 32
    2b52:	b0 e0       	ldi	r27, 0x00	; 0
    2b54:	ee ea       	ldi	r30, 0xAE	; 174
    2b56:	f5 e1       	ldi	r31, 0x15	; 21
    2b58:	0c 94 c6 19 	jmp	0x338c	; 0x338c <__prologue_saves__+0x18>
    2b5c:	69 83       	std	Y+1, r22	; 0x01
    2b5e:	7a 83       	std	Y+2, r23	; 0x02
    2b60:	8b 83       	std	Y+3, r24	; 0x03
    2b62:	9c 83       	std	Y+4, r25	; 0x04
    2b64:	2d 83       	std	Y+5, r18	; 0x05
    2b66:	3e 83       	std	Y+6, r19	; 0x06
    2b68:	4f 83       	std	Y+7, r20	; 0x07
    2b6a:	58 87       	std	Y+8, r21	; 0x08
    2b6c:	f9 e0       	ldi	r31, 0x09	; 9
    2b6e:	ef 2e       	mov	r14, r31
    2b70:	f1 2c       	mov	r15, r1
    2b72:	ec 0e       	add	r14, r28
    2b74:	fd 1e       	adc	r15, r29
    2b76:	ce 01       	movw	r24, r28
    2b78:	01 96       	adiw	r24, 0x01	; 1
    2b7a:	b7 01       	movw	r22, r14
    2b7c:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2b80:	8e 01       	movw	r16, r28
    2b82:	0f 5e       	subi	r16, 0xEF	; 239
    2b84:	1f 4f       	sbci	r17, 0xFF	; 255
    2b86:	ce 01       	movw	r24, r28
    2b88:	05 96       	adiw	r24, 0x05	; 5
    2b8a:	b8 01       	movw	r22, r16
    2b8c:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2b90:	c7 01       	movw	r24, r14
    2b92:	b8 01       	movw	r22, r16
    2b94:	ae 01       	movw	r20, r28
    2b96:	47 5e       	subi	r20, 0xE7	; 231
    2b98:	5f 4f       	sbci	r21, 0xFF	; 255
    2b9a:	0e 94 2b 14 	call	0x2856	; 0x2856 <_fpadd_parts>
    2b9e:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <__pack_f>
    2ba2:	a0 96       	adiw	r28, 0x20	; 32
    2ba4:	e6 e0       	ldi	r30, 0x06	; 6
    2ba6:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__epilogue_restores__+0x18>

00002baa <__mulsf3>:
    2baa:	a0 e2       	ldi	r26, 0x20	; 32
    2bac:	b0 e0       	ldi	r27, 0x00	; 0
    2bae:	eb ed       	ldi	r30, 0xDB	; 219
    2bb0:	f5 e1       	ldi	r31, 0x15	; 21
    2bb2:	0c 94 ba 19 	jmp	0x3374	; 0x3374 <__prologue_saves__>
    2bb6:	69 83       	std	Y+1, r22	; 0x01
    2bb8:	7a 83       	std	Y+2, r23	; 0x02
    2bba:	8b 83       	std	Y+3, r24	; 0x03
    2bbc:	9c 83       	std	Y+4, r25	; 0x04
    2bbe:	2d 83       	std	Y+5, r18	; 0x05
    2bc0:	3e 83       	std	Y+6, r19	; 0x06
    2bc2:	4f 83       	std	Y+7, r20	; 0x07
    2bc4:	58 87       	std	Y+8, r21	; 0x08
    2bc6:	ce 01       	movw	r24, r28
    2bc8:	01 96       	adiw	r24, 0x01	; 1
    2bca:	be 01       	movw	r22, r28
    2bcc:	67 5f       	subi	r22, 0xF7	; 247
    2bce:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd0:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2bd4:	ce 01       	movw	r24, r28
    2bd6:	05 96       	adiw	r24, 0x05	; 5
    2bd8:	be 01       	movw	r22, r28
    2bda:	6f 5e       	subi	r22, 0xEF	; 239
    2bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2bde:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2be2:	99 85       	ldd	r25, Y+9	; 0x09
    2be4:	92 30       	cpi	r25, 0x02	; 2
    2be6:	88 f0       	brcs	.+34     	; 0x2c0a <__mulsf3+0x60>
    2be8:	89 89       	ldd	r24, Y+17	; 0x11
    2bea:	82 30       	cpi	r24, 0x02	; 2
    2bec:	c8 f0       	brcs	.+50     	; 0x2c20 <__mulsf3+0x76>
    2bee:	94 30       	cpi	r25, 0x04	; 4
    2bf0:	19 f4       	brne	.+6      	; 0x2bf8 <__mulsf3+0x4e>
    2bf2:	82 30       	cpi	r24, 0x02	; 2
    2bf4:	51 f4       	brne	.+20     	; 0x2c0a <__mulsf3+0x60>
    2bf6:	04 c0       	rjmp	.+8      	; 0x2c00 <__mulsf3+0x56>
    2bf8:	84 30       	cpi	r24, 0x04	; 4
    2bfa:	29 f4       	brne	.+10     	; 0x2c06 <__mulsf3+0x5c>
    2bfc:	92 30       	cpi	r25, 0x02	; 2
    2bfe:	81 f4       	brne	.+32     	; 0x2c20 <__mulsf3+0x76>
    2c00:	83 eb       	ldi	r24, 0xB3	; 179
    2c02:	91 e0       	ldi	r25, 0x01	; 1
    2c04:	c6 c0       	rjmp	.+396    	; 0x2d92 <__mulsf3+0x1e8>
    2c06:	92 30       	cpi	r25, 0x02	; 2
    2c08:	49 f4       	brne	.+18     	; 0x2c1c <__mulsf3+0x72>
    2c0a:	20 e0       	ldi	r18, 0x00	; 0
    2c0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c0e:	8a 89       	ldd	r24, Y+18	; 0x12
    2c10:	98 13       	cpse	r25, r24
    2c12:	21 e0       	ldi	r18, 0x01	; 1
    2c14:	2a 87       	std	Y+10, r18	; 0x0a
    2c16:	ce 01       	movw	r24, r28
    2c18:	09 96       	adiw	r24, 0x09	; 9
    2c1a:	bb c0       	rjmp	.+374    	; 0x2d92 <__mulsf3+0x1e8>
    2c1c:	82 30       	cpi	r24, 0x02	; 2
    2c1e:	49 f4       	brne	.+18     	; 0x2c32 <__mulsf3+0x88>
    2c20:	20 e0       	ldi	r18, 0x00	; 0
    2c22:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c24:	8a 89       	ldd	r24, Y+18	; 0x12
    2c26:	98 13       	cpse	r25, r24
    2c28:	21 e0       	ldi	r18, 0x01	; 1
    2c2a:	2a 8b       	std	Y+18, r18	; 0x12
    2c2c:	ce 01       	movw	r24, r28
    2c2e:	41 96       	adiw	r24, 0x11	; 17
    2c30:	b0 c0       	rjmp	.+352    	; 0x2d92 <__mulsf3+0x1e8>
    2c32:	2d 84       	ldd	r2, Y+13	; 0x0d
    2c34:	3e 84       	ldd	r3, Y+14	; 0x0e
    2c36:	4f 84       	ldd	r4, Y+15	; 0x0f
    2c38:	58 88       	ldd	r5, Y+16	; 0x10
    2c3a:	6d 88       	ldd	r6, Y+21	; 0x15
    2c3c:	7e 88       	ldd	r7, Y+22	; 0x16
    2c3e:	8f 88       	ldd	r8, Y+23	; 0x17
    2c40:	98 8c       	ldd	r9, Y+24	; 0x18
    2c42:	ee 24       	eor	r14, r14
    2c44:	ff 24       	eor	r15, r15
    2c46:	87 01       	movw	r16, r14
    2c48:	aa 24       	eor	r10, r10
    2c4a:	bb 24       	eor	r11, r11
    2c4c:	65 01       	movw	r12, r10
    2c4e:	40 e0       	ldi	r20, 0x00	; 0
    2c50:	50 e0       	ldi	r21, 0x00	; 0
    2c52:	60 e0       	ldi	r22, 0x00	; 0
    2c54:	70 e0       	ldi	r23, 0x00	; 0
    2c56:	e0 e0       	ldi	r30, 0x00	; 0
    2c58:	f0 e0       	ldi	r31, 0x00	; 0
    2c5a:	c1 01       	movw	r24, r2
    2c5c:	81 70       	andi	r24, 0x01	; 1
    2c5e:	90 70       	andi	r25, 0x00	; 0
    2c60:	89 2b       	or	r24, r25
    2c62:	e9 f0       	breq	.+58     	; 0x2c9e <__mulsf3+0xf4>
    2c64:	e6 0c       	add	r14, r6
    2c66:	f7 1c       	adc	r15, r7
    2c68:	08 1d       	adc	r16, r8
    2c6a:	19 1d       	adc	r17, r9
    2c6c:	9a 01       	movw	r18, r20
    2c6e:	ab 01       	movw	r20, r22
    2c70:	2a 0d       	add	r18, r10
    2c72:	3b 1d       	adc	r19, r11
    2c74:	4c 1d       	adc	r20, r12
    2c76:	5d 1d       	adc	r21, r13
    2c78:	80 e0       	ldi	r24, 0x00	; 0
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	a0 e0       	ldi	r26, 0x00	; 0
    2c7e:	b0 e0       	ldi	r27, 0x00	; 0
    2c80:	e6 14       	cp	r14, r6
    2c82:	f7 04       	cpc	r15, r7
    2c84:	08 05       	cpc	r16, r8
    2c86:	19 05       	cpc	r17, r9
    2c88:	20 f4       	brcc	.+8      	; 0x2c92 <__mulsf3+0xe8>
    2c8a:	81 e0       	ldi	r24, 0x01	; 1
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	a0 e0       	ldi	r26, 0x00	; 0
    2c90:	b0 e0       	ldi	r27, 0x00	; 0
    2c92:	ba 01       	movw	r22, r20
    2c94:	a9 01       	movw	r20, r18
    2c96:	48 0f       	add	r20, r24
    2c98:	59 1f       	adc	r21, r25
    2c9a:	6a 1f       	adc	r22, r26
    2c9c:	7b 1f       	adc	r23, r27
    2c9e:	aa 0c       	add	r10, r10
    2ca0:	bb 1c       	adc	r11, r11
    2ca2:	cc 1c       	adc	r12, r12
    2ca4:	dd 1c       	adc	r13, r13
    2ca6:	97 fe       	sbrs	r9, 7
    2ca8:	08 c0       	rjmp	.+16     	; 0x2cba <__mulsf3+0x110>
    2caa:	81 e0       	ldi	r24, 0x01	; 1
    2cac:	90 e0       	ldi	r25, 0x00	; 0
    2cae:	a0 e0       	ldi	r26, 0x00	; 0
    2cb0:	b0 e0       	ldi	r27, 0x00	; 0
    2cb2:	a8 2a       	or	r10, r24
    2cb4:	b9 2a       	or	r11, r25
    2cb6:	ca 2a       	or	r12, r26
    2cb8:	db 2a       	or	r13, r27
    2cba:	31 96       	adiw	r30, 0x01	; 1
    2cbc:	e0 32       	cpi	r30, 0x20	; 32
    2cbe:	f1 05       	cpc	r31, r1
    2cc0:	49 f0       	breq	.+18     	; 0x2cd4 <__mulsf3+0x12a>
    2cc2:	66 0c       	add	r6, r6
    2cc4:	77 1c       	adc	r7, r7
    2cc6:	88 1c       	adc	r8, r8
    2cc8:	99 1c       	adc	r9, r9
    2cca:	56 94       	lsr	r5
    2ccc:	47 94       	ror	r4
    2cce:	37 94       	ror	r3
    2cd0:	27 94       	ror	r2
    2cd2:	c3 cf       	rjmp	.-122    	; 0x2c5a <__mulsf3+0xb0>
    2cd4:	fa 85       	ldd	r31, Y+10	; 0x0a
    2cd6:	ea 89       	ldd	r30, Y+18	; 0x12
    2cd8:	2b 89       	ldd	r18, Y+19	; 0x13
    2cda:	3c 89       	ldd	r19, Y+20	; 0x14
    2cdc:	8b 85       	ldd	r24, Y+11	; 0x0b
    2cde:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ce0:	28 0f       	add	r18, r24
    2ce2:	39 1f       	adc	r19, r25
    2ce4:	2e 5f       	subi	r18, 0xFE	; 254
    2ce6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ce8:	17 c0       	rjmp	.+46     	; 0x2d18 <__mulsf3+0x16e>
    2cea:	ca 01       	movw	r24, r20
    2cec:	81 70       	andi	r24, 0x01	; 1
    2cee:	90 70       	andi	r25, 0x00	; 0
    2cf0:	89 2b       	or	r24, r25
    2cf2:	61 f0       	breq	.+24     	; 0x2d0c <__mulsf3+0x162>
    2cf4:	16 95       	lsr	r17
    2cf6:	07 95       	ror	r16
    2cf8:	f7 94       	ror	r15
    2cfa:	e7 94       	ror	r14
    2cfc:	80 e0       	ldi	r24, 0x00	; 0
    2cfe:	90 e0       	ldi	r25, 0x00	; 0
    2d00:	a0 e0       	ldi	r26, 0x00	; 0
    2d02:	b0 e8       	ldi	r27, 0x80	; 128
    2d04:	e8 2a       	or	r14, r24
    2d06:	f9 2a       	or	r15, r25
    2d08:	0a 2b       	or	r16, r26
    2d0a:	1b 2b       	or	r17, r27
    2d0c:	76 95       	lsr	r23
    2d0e:	67 95       	ror	r22
    2d10:	57 95       	ror	r21
    2d12:	47 95       	ror	r20
    2d14:	2f 5f       	subi	r18, 0xFF	; 255
    2d16:	3f 4f       	sbci	r19, 0xFF	; 255
    2d18:	77 fd       	sbrc	r23, 7
    2d1a:	e7 cf       	rjmp	.-50     	; 0x2cea <__mulsf3+0x140>
    2d1c:	0c c0       	rjmp	.+24     	; 0x2d36 <__mulsf3+0x18c>
    2d1e:	44 0f       	add	r20, r20
    2d20:	55 1f       	adc	r21, r21
    2d22:	66 1f       	adc	r22, r22
    2d24:	77 1f       	adc	r23, r23
    2d26:	17 fd       	sbrc	r17, 7
    2d28:	41 60       	ori	r20, 0x01	; 1
    2d2a:	ee 0c       	add	r14, r14
    2d2c:	ff 1c       	adc	r15, r15
    2d2e:	00 1f       	adc	r16, r16
    2d30:	11 1f       	adc	r17, r17
    2d32:	21 50       	subi	r18, 0x01	; 1
    2d34:	30 40       	sbci	r19, 0x00	; 0
    2d36:	40 30       	cpi	r20, 0x00	; 0
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	59 07       	cpc	r21, r25
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	69 07       	cpc	r22, r25
    2d40:	90 e4       	ldi	r25, 0x40	; 64
    2d42:	79 07       	cpc	r23, r25
    2d44:	60 f3       	brcs	.-40     	; 0x2d1e <__mulsf3+0x174>
    2d46:	2b 8f       	std	Y+27, r18	; 0x1b
    2d48:	3c 8f       	std	Y+28, r19	; 0x1c
    2d4a:	db 01       	movw	r26, r22
    2d4c:	ca 01       	movw	r24, r20
    2d4e:	8f 77       	andi	r24, 0x7F	; 127
    2d50:	90 70       	andi	r25, 0x00	; 0
    2d52:	a0 70       	andi	r26, 0x00	; 0
    2d54:	b0 70       	andi	r27, 0x00	; 0
    2d56:	80 34       	cpi	r24, 0x40	; 64
    2d58:	91 05       	cpc	r25, r1
    2d5a:	a1 05       	cpc	r26, r1
    2d5c:	b1 05       	cpc	r27, r1
    2d5e:	61 f4       	brne	.+24     	; 0x2d78 <__mulsf3+0x1ce>
    2d60:	47 fd       	sbrc	r20, 7
    2d62:	0a c0       	rjmp	.+20     	; 0x2d78 <__mulsf3+0x1ce>
    2d64:	e1 14       	cp	r14, r1
    2d66:	f1 04       	cpc	r15, r1
    2d68:	01 05       	cpc	r16, r1
    2d6a:	11 05       	cpc	r17, r1
    2d6c:	29 f0       	breq	.+10     	; 0x2d78 <__mulsf3+0x1ce>
    2d6e:	40 5c       	subi	r20, 0xC0	; 192
    2d70:	5f 4f       	sbci	r21, 0xFF	; 255
    2d72:	6f 4f       	sbci	r22, 0xFF	; 255
    2d74:	7f 4f       	sbci	r23, 0xFF	; 255
    2d76:	40 78       	andi	r20, 0x80	; 128
    2d78:	1a 8e       	std	Y+26, r1	; 0x1a
    2d7a:	fe 17       	cp	r31, r30
    2d7c:	11 f0       	breq	.+4      	; 0x2d82 <__mulsf3+0x1d8>
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	8a 8f       	std	Y+26, r24	; 0x1a
    2d82:	4d 8f       	std	Y+29, r20	; 0x1d
    2d84:	5e 8f       	std	Y+30, r21	; 0x1e
    2d86:	6f 8f       	std	Y+31, r22	; 0x1f
    2d88:	78 a3       	std	Y+32, r23	; 0x20
    2d8a:	83 e0       	ldi	r24, 0x03	; 3
    2d8c:	89 8f       	std	Y+25, r24	; 0x19
    2d8e:	ce 01       	movw	r24, r28
    2d90:	49 96       	adiw	r24, 0x19	; 25
    2d92:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <__pack_f>
    2d96:	a0 96       	adiw	r28, 0x20	; 32
    2d98:	e2 e1       	ldi	r30, 0x12	; 18
    2d9a:	0c 94 d6 19 	jmp	0x33ac	; 0x33ac <__epilogue_restores__>

00002d9e <__nesf2>:
    2d9e:	a8 e1       	ldi	r26, 0x18	; 24
    2da0:	b0 e0       	ldi	r27, 0x00	; 0
    2da2:	e5 ed       	ldi	r30, 0xD5	; 213
    2da4:	f6 e1       	ldi	r31, 0x16	; 22
    2da6:	0c 94 c6 19 	jmp	0x338c	; 0x338c <__prologue_saves__+0x18>
    2daa:	69 83       	std	Y+1, r22	; 0x01
    2dac:	7a 83       	std	Y+2, r23	; 0x02
    2dae:	8b 83       	std	Y+3, r24	; 0x03
    2db0:	9c 83       	std	Y+4, r25	; 0x04
    2db2:	2d 83       	std	Y+5, r18	; 0x05
    2db4:	3e 83       	std	Y+6, r19	; 0x06
    2db6:	4f 83       	std	Y+7, r20	; 0x07
    2db8:	58 87       	std	Y+8, r21	; 0x08
    2dba:	89 e0       	ldi	r24, 0x09	; 9
    2dbc:	e8 2e       	mov	r14, r24
    2dbe:	f1 2c       	mov	r15, r1
    2dc0:	ec 0e       	add	r14, r28
    2dc2:	fd 1e       	adc	r15, r29
    2dc4:	ce 01       	movw	r24, r28
    2dc6:	01 96       	adiw	r24, 0x01	; 1
    2dc8:	b7 01       	movw	r22, r14
    2dca:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2dce:	8e 01       	movw	r16, r28
    2dd0:	0f 5e       	subi	r16, 0xEF	; 239
    2dd2:	1f 4f       	sbci	r17, 0xFF	; 255
    2dd4:	ce 01       	movw	r24, r28
    2dd6:	05 96       	adiw	r24, 0x05	; 5
    2dd8:	b8 01       	movw	r22, r16
    2dda:	0e 94 81 18 	call	0x3102	; 0x3102 <__unpack_f>
    2dde:	89 85       	ldd	r24, Y+9	; 0x09
    2de0:	82 30       	cpi	r24, 0x02	; 2
    2de2:	40 f0       	brcs	.+16     	; 0x2df4 <__nesf2+0x56>
    2de4:	89 89       	ldd	r24, Y+17	; 0x11
    2de6:	82 30       	cpi	r24, 0x02	; 2
    2de8:	28 f0       	brcs	.+10     	; 0x2df4 <__nesf2+0x56>
    2dea:	c7 01       	movw	r24, r14
    2dec:	b8 01       	movw	r22, r16
    2dee:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <__fpcmp_parts_f>
    2df2:	01 c0       	rjmp	.+2      	; 0x2df6 <__nesf2+0x58>
    2df4:	81 e0       	ldi	r24, 0x01	; 1
    2df6:	68 96       	adiw	r28, 0x18	; 24
    2df8:	e6 e0       	ldi	r30, 0x06	; 6
    2dfa:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__epilogue_restores__+0x18>

00002dfe <__floatsisf>:
    2dfe:	a8 e0       	ldi	r26, 0x08	; 8
    2e00:	b0 e0       	ldi	r27, 0x00	; 0
    2e02:	e5 e0       	ldi	r30, 0x05	; 5
    2e04:	f7 e1       	ldi	r31, 0x17	; 23
    2e06:	0c 94 c3 19 	jmp	0x3386	; 0x3386 <__prologue_saves__+0x12>
    2e0a:	9b 01       	movw	r18, r22
    2e0c:	ac 01       	movw	r20, r24
    2e0e:	83 e0       	ldi	r24, 0x03	; 3
    2e10:	89 83       	std	Y+1, r24	; 0x01
    2e12:	da 01       	movw	r26, r20
    2e14:	c9 01       	movw	r24, r18
    2e16:	88 27       	eor	r24, r24
    2e18:	b7 fd       	sbrc	r27, 7
    2e1a:	83 95       	inc	r24
    2e1c:	99 27       	eor	r25, r25
    2e1e:	aa 27       	eor	r26, r26
    2e20:	bb 27       	eor	r27, r27
    2e22:	b8 2e       	mov	r11, r24
    2e24:	21 15       	cp	r18, r1
    2e26:	31 05       	cpc	r19, r1
    2e28:	41 05       	cpc	r20, r1
    2e2a:	51 05       	cpc	r21, r1
    2e2c:	19 f4       	brne	.+6      	; 0x2e34 <__floatsisf+0x36>
    2e2e:	82 e0       	ldi	r24, 0x02	; 2
    2e30:	89 83       	std	Y+1, r24	; 0x01
    2e32:	3a c0       	rjmp	.+116    	; 0x2ea8 <__floatsisf+0xaa>
    2e34:	88 23       	and	r24, r24
    2e36:	a9 f0       	breq	.+42     	; 0x2e62 <__floatsisf+0x64>
    2e38:	20 30       	cpi	r18, 0x00	; 0
    2e3a:	80 e0       	ldi	r24, 0x00	; 0
    2e3c:	38 07       	cpc	r19, r24
    2e3e:	80 e0       	ldi	r24, 0x00	; 0
    2e40:	48 07       	cpc	r20, r24
    2e42:	80 e8       	ldi	r24, 0x80	; 128
    2e44:	58 07       	cpc	r21, r24
    2e46:	29 f4       	brne	.+10     	; 0x2e52 <__floatsisf+0x54>
    2e48:	60 e0       	ldi	r22, 0x00	; 0
    2e4a:	70 e0       	ldi	r23, 0x00	; 0
    2e4c:	80 e0       	ldi	r24, 0x00	; 0
    2e4e:	9f ec       	ldi	r25, 0xCF	; 207
    2e50:	30 c0       	rjmp	.+96     	; 0x2eb2 <__floatsisf+0xb4>
    2e52:	ee 24       	eor	r14, r14
    2e54:	ff 24       	eor	r15, r15
    2e56:	87 01       	movw	r16, r14
    2e58:	e2 1a       	sub	r14, r18
    2e5a:	f3 0a       	sbc	r15, r19
    2e5c:	04 0b       	sbc	r16, r20
    2e5e:	15 0b       	sbc	r17, r21
    2e60:	02 c0       	rjmp	.+4      	; 0x2e66 <__floatsisf+0x68>
    2e62:	79 01       	movw	r14, r18
    2e64:	8a 01       	movw	r16, r20
    2e66:	8e e1       	ldi	r24, 0x1E	; 30
    2e68:	c8 2e       	mov	r12, r24
    2e6a:	d1 2c       	mov	r13, r1
    2e6c:	dc 82       	std	Y+4, r13	; 0x04
    2e6e:	cb 82       	std	Y+3, r12	; 0x03
    2e70:	ed 82       	std	Y+5, r14	; 0x05
    2e72:	fe 82       	std	Y+6, r15	; 0x06
    2e74:	0f 83       	std	Y+7, r16	; 0x07
    2e76:	18 87       	std	Y+8, r17	; 0x08
    2e78:	c8 01       	movw	r24, r16
    2e7a:	b7 01       	movw	r22, r14
    2e7c:	0e 94 5d 17 	call	0x2eba	; 0x2eba <__clzsi2>
    2e80:	01 97       	sbiw	r24, 0x01	; 1
    2e82:	18 16       	cp	r1, r24
    2e84:	19 06       	cpc	r1, r25
    2e86:	84 f4       	brge	.+32     	; 0x2ea8 <__floatsisf+0xaa>
    2e88:	08 2e       	mov	r0, r24
    2e8a:	04 c0       	rjmp	.+8      	; 0x2e94 <__floatsisf+0x96>
    2e8c:	ee 0c       	add	r14, r14
    2e8e:	ff 1c       	adc	r15, r15
    2e90:	00 1f       	adc	r16, r16
    2e92:	11 1f       	adc	r17, r17
    2e94:	0a 94       	dec	r0
    2e96:	d2 f7       	brpl	.-12     	; 0x2e8c <__floatsisf+0x8e>
    2e98:	ed 82       	std	Y+5, r14	; 0x05
    2e9a:	fe 82       	std	Y+6, r15	; 0x06
    2e9c:	0f 83       	std	Y+7, r16	; 0x07
    2e9e:	18 87       	std	Y+8, r17	; 0x08
    2ea0:	c8 1a       	sub	r12, r24
    2ea2:	d9 0a       	sbc	r13, r25
    2ea4:	dc 82       	std	Y+4, r13	; 0x04
    2ea6:	cb 82       	std	Y+3, r12	; 0x03
    2ea8:	ba 82       	std	Y+2, r11	; 0x02
    2eaa:	ce 01       	movw	r24, r28
    2eac:	01 96       	adiw	r24, 0x01	; 1
    2eae:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <__pack_f>
    2eb2:	28 96       	adiw	r28, 0x08	; 8
    2eb4:	e9 e0       	ldi	r30, 0x09	; 9
    2eb6:	0c 94 df 19 	jmp	0x33be	; 0x33be <__epilogue_restores__+0x12>

00002eba <__clzsi2>:
    2eba:	ef 92       	push	r14
    2ebc:	ff 92       	push	r15
    2ebe:	0f 93       	push	r16
    2ec0:	1f 93       	push	r17
    2ec2:	7b 01       	movw	r14, r22
    2ec4:	8c 01       	movw	r16, r24
    2ec6:	80 e0       	ldi	r24, 0x00	; 0
    2ec8:	e8 16       	cp	r14, r24
    2eca:	80 e0       	ldi	r24, 0x00	; 0
    2ecc:	f8 06       	cpc	r15, r24
    2ece:	81 e0       	ldi	r24, 0x01	; 1
    2ed0:	08 07       	cpc	r16, r24
    2ed2:	80 e0       	ldi	r24, 0x00	; 0
    2ed4:	18 07       	cpc	r17, r24
    2ed6:	88 f4       	brcc	.+34     	; 0x2efa <__clzsi2+0x40>
    2ed8:	8f ef       	ldi	r24, 0xFF	; 255
    2eda:	e8 16       	cp	r14, r24
    2edc:	f1 04       	cpc	r15, r1
    2ede:	01 05       	cpc	r16, r1
    2ee0:	11 05       	cpc	r17, r1
    2ee2:	31 f0       	breq	.+12     	; 0x2ef0 <__clzsi2+0x36>
    2ee4:	28 f0       	brcs	.+10     	; 0x2ef0 <__clzsi2+0x36>
    2ee6:	88 e0       	ldi	r24, 0x08	; 8
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
    2eea:	a0 e0       	ldi	r26, 0x00	; 0
    2eec:	b0 e0       	ldi	r27, 0x00	; 0
    2eee:	17 c0       	rjmp	.+46     	; 0x2f1e <__clzsi2+0x64>
    2ef0:	80 e0       	ldi	r24, 0x00	; 0
    2ef2:	90 e0       	ldi	r25, 0x00	; 0
    2ef4:	a0 e0       	ldi	r26, 0x00	; 0
    2ef6:	b0 e0       	ldi	r27, 0x00	; 0
    2ef8:	12 c0       	rjmp	.+36     	; 0x2f1e <__clzsi2+0x64>
    2efa:	80 e0       	ldi	r24, 0x00	; 0
    2efc:	e8 16       	cp	r14, r24
    2efe:	80 e0       	ldi	r24, 0x00	; 0
    2f00:	f8 06       	cpc	r15, r24
    2f02:	80 e0       	ldi	r24, 0x00	; 0
    2f04:	08 07       	cpc	r16, r24
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	18 07       	cpc	r17, r24
    2f0a:	28 f0       	brcs	.+10     	; 0x2f16 <__clzsi2+0x5c>
    2f0c:	88 e1       	ldi	r24, 0x18	; 24
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	a0 e0       	ldi	r26, 0x00	; 0
    2f12:	b0 e0       	ldi	r27, 0x00	; 0
    2f14:	04 c0       	rjmp	.+8      	; 0x2f1e <__clzsi2+0x64>
    2f16:	80 e1       	ldi	r24, 0x10	; 16
    2f18:	90 e0       	ldi	r25, 0x00	; 0
    2f1a:	a0 e0       	ldi	r26, 0x00	; 0
    2f1c:	b0 e0       	ldi	r27, 0x00	; 0
    2f1e:	20 e2       	ldi	r18, 0x20	; 32
    2f20:	30 e0       	ldi	r19, 0x00	; 0
    2f22:	40 e0       	ldi	r20, 0x00	; 0
    2f24:	50 e0       	ldi	r21, 0x00	; 0
    2f26:	28 1b       	sub	r18, r24
    2f28:	39 0b       	sbc	r19, r25
    2f2a:	4a 0b       	sbc	r20, r26
    2f2c:	5b 0b       	sbc	r21, r27
    2f2e:	04 c0       	rjmp	.+8      	; 0x2f38 <__clzsi2+0x7e>
    2f30:	16 95       	lsr	r17
    2f32:	07 95       	ror	r16
    2f34:	f7 94       	ror	r15
    2f36:	e7 94       	ror	r14
    2f38:	8a 95       	dec	r24
    2f3a:	d2 f7       	brpl	.-12     	; 0x2f30 <__clzsi2+0x76>
    2f3c:	f7 01       	movw	r30, r14
    2f3e:	e5 54       	subi	r30, 0x45	; 69
    2f40:	fe 4f       	sbci	r31, 0xFE	; 254
    2f42:	80 81       	ld	r24, Z
    2f44:	28 1b       	sub	r18, r24
    2f46:	31 09       	sbc	r19, r1
    2f48:	41 09       	sbc	r20, r1
    2f4a:	51 09       	sbc	r21, r1
    2f4c:	c9 01       	movw	r24, r18
    2f4e:	1f 91       	pop	r17
    2f50:	0f 91       	pop	r16
    2f52:	ff 90       	pop	r15
    2f54:	ef 90       	pop	r14
    2f56:	08 95       	ret

00002f58 <__pack_f>:
    2f58:	df 92       	push	r13
    2f5a:	ef 92       	push	r14
    2f5c:	ff 92       	push	r15
    2f5e:	0f 93       	push	r16
    2f60:	1f 93       	push	r17
    2f62:	fc 01       	movw	r30, r24
    2f64:	e4 80       	ldd	r14, Z+4	; 0x04
    2f66:	f5 80       	ldd	r15, Z+5	; 0x05
    2f68:	06 81       	ldd	r16, Z+6	; 0x06
    2f6a:	17 81       	ldd	r17, Z+7	; 0x07
    2f6c:	d1 80       	ldd	r13, Z+1	; 0x01
    2f6e:	80 81       	ld	r24, Z
    2f70:	82 30       	cpi	r24, 0x02	; 2
    2f72:	48 f4       	brcc	.+18     	; 0x2f86 <__pack_f+0x2e>
    2f74:	80 e0       	ldi	r24, 0x00	; 0
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	a0 e1       	ldi	r26, 0x10	; 16
    2f7a:	b0 e0       	ldi	r27, 0x00	; 0
    2f7c:	e8 2a       	or	r14, r24
    2f7e:	f9 2a       	or	r15, r25
    2f80:	0a 2b       	or	r16, r26
    2f82:	1b 2b       	or	r17, r27
    2f84:	a5 c0       	rjmp	.+330    	; 0x30d0 <__pack_f+0x178>
    2f86:	84 30       	cpi	r24, 0x04	; 4
    2f88:	09 f4       	brne	.+2      	; 0x2f8c <__pack_f+0x34>
    2f8a:	9f c0       	rjmp	.+318    	; 0x30ca <__pack_f+0x172>
    2f8c:	82 30       	cpi	r24, 0x02	; 2
    2f8e:	21 f4       	brne	.+8      	; 0x2f98 <__pack_f+0x40>
    2f90:	ee 24       	eor	r14, r14
    2f92:	ff 24       	eor	r15, r15
    2f94:	87 01       	movw	r16, r14
    2f96:	05 c0       	rjmp	.+10     	; 0x2fa2 <__pack_f+0x4a>
    2f98:	e1 14       	cp	r14, r1
    2f9a:	f1 04       	cpc	r15, r1
    2f9c:	01 05       	cpc	r16, r1
    2f9e:	11 05       	cpc	r17, r1
    2fa0:	19 f4       	brne	.+6      	; 0x2fa8 <__pack_f+0x50>
    2fa2:	e0 e0       	ldi	r30, 0x00	; 0
    2fa4:	f0 e0       	ldi	r31, 0x00	; 0
    2fa6:	96 c0       	rjmp	.+300    	; 0x30d4 <__pack_f+0x17c>
    2fa8:	62 81       	ldd	r22, Z+2	; 0x02
    2faa:	73 81       	ldd	r23, Z+3	; 0x03
    2fac:	9f ef       	ldi	r25, 0xFF	; 255
    2fae:	62 38       	cpi	r22, 0x82	; 130
    2fb0:	79 07       	cpc	r23, r25
    2fb2:	0c f0       	brlt	.+2      	; 0x2fb6 <__pack_f+0x5e>
    2fb4:	5b c0       	rjmp	.+182    	; 0x306c <__pack_f+0x114>
    2fb6:	22 e8       	ldi	r18, 0x82	; 130
    2fb8:	3f ef       	ldi	r19, 0xFF	; 255
    2fba:	26 1b       	sub	r18, r22
    2fbc:	37 0b       	sbc	r19, r23
    2fbe:	2a 31       	cpi	r18, 0x1A	; 26
    2fc0:	31 05       	cpc	r19, r1
    2fc2:	2c f0       	brlt	.+10     	; 0x2fce <__pack_f+0x76>
    2fc4:	20 e0       	ldi	r18, 0x00	; 0
    2fc6:	30 e0       	ldi	r19, 0x00	; 0
    2fc8:	40 e0       	ldi	r20, 0x00	; 0
    2fca:	50 e0       	ldi	r21, 0x00	; 0
    2fcc:	2a c0       	rjmp	.+84     	; 0x3022 <__pack_f+0xca>
    2fce:	b8 01       	movw	r22, r16
    2fd0:	a7 01       	movw	r20, r14
    2fd2:	02 2e       	mov	r0, r18
    2fd4:	04 c0       	rjmp	.+8      	; 0x2fde <__pack_f+0x86>
    2fd6:	76 95       	lsr	r23
    2fd8:	67 95       	ror	r22
    2fda:	57 95       	ror	r21
    2fdc:	47 95       	ror	r20
    2fde:	0a 94       	dec	r0
    2fe0:	d2 f7       	brpl	.-12     	; 0x2fd6 <__pack_f+0x7e>
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	a0 e0       	ldi	r26, 0x00	; 0
    2fe8:	b0 e0       	ldi	r27, 0x00	; 0
    2fea:	04 c0       	rjmp	.+8      	; 0x2ff4 <__pack_f+0x9c>
    2fec:	88 0f       	add	r24, r24
    2fee:	99 1f       	adc	r25, r25
    2ff0:	aa 1f       	adc	r26, r26
    2ff2:	bb 1f       	adc	r27, r27
    2ff4:	2a 95       	dec	r18
    2ff6:	d2 f7       	brpl	.-12     	; 0x2fec <__pack_f+0x94>
    2ff8:	01 97       	sbiw	r24, 0x01	; 1
    2ffa:	a1 09       	sbc	r26, r1
    2ffc:	b1 09       	sbc	r27, r1
    2ffe:	8e 21       	and	r24, r14
    3000:	9f 21       	and	r25, r15
    3002:	a0 23       	and	r26, r16
    3004:	b1 23       	and	r27, r17
    3006:	00 97       	sbiw	r24, 0x00	; 0
    3008:	a1 05       	cpc	r26, r1
    300a:	b1 05       	cpc	r27, r1
    300c:	21 f0       	breq	.+8      	; 0x3016 <__pack_f+0xbe>
    300e:	81 e0       	ldi	r24, 0x01	; 1
    3010:	90 e0       	ldi	r25, 0x00	; 0
    3012:	a0 e0       	ldi	r26, 0x00	; 0
    3014:	b0 e0       	ldi	r27, 0x00	; 0
    3016:	9a 01       	movw	r18, r20
    3018:	ab 01       	movw	r20, r22
    301a:	28 2b       	or	r18, r24
    301c:	39 2b       	or	r19, r25
    301e:	4a 2b       	or	r20, r26
    3020:	5b 2b       	or	r21, r27
    3022:	da 01       	movw	r26, r20
    3024:	c9 01       	movw	r24, r18
    3026:	8f 77       	andi	r24, 0x7F	; 127
    3028:	90 70       	andi	r25, 0x00	; 0
    302a:	a0 70       	andi	r26, 0x00	; 0
    302c:	b0 70       	andi	r27, 0x00	; 0
    302e:	80 34       	cpi	r24, 0x40	; 64
    3030:	91 05       	cpc	r25, r1
    3032:	a1 05       	cpc	r26, r1
    3034:	b1 05       	cpc	r27, r1
    3036:	39 f4       	brne	.+14     	; 0x3046 <__pack_f+0xee>
    3038:	27 ff       	sbrs	r18, 7
    303a:	09 c0       	rjmp	.+18     	; 0x304e <__pack_f+0xf6>
    303c:	20 5c       	subi	r18, 0xC0	; 192
    303e:	3f 4f       	sbci	r19, 0xFF	; 255
    3040:	4f 4f       	sbci	r20, 0xFF	; 255
    3042:	5f 4f       	sbci	r21, 0xFF	; 255
    3044:	04 c0       	rjmp	.+8      	; 0x304e <__pack_f+0xf6>
    3046:	21 5c       	subi	r18, 0xC1	; 193
    3048:	3f 4f       	sbci	r19, 0xFF	; 255
    304a:	4f 4f       	sbci	r20, 0xFF	; 255
    304c:	5f 4f       	sbci	r21, 0xFF	; 255
    304e:	e0 e0       	ldi	r30, 0x00	; 0
    3050:	f0 e0       	ldi	r31, 0x00	; 0
    3052:	20 30       	cpi	r18, 0x00	; 0
    3054:	a0 e0       	ldi	r26, 0x00	; 0
    3056:	3a 07       	cpc	r19, r26
    3058:	a0 e0       	ldi	r26, 0x00	; 0
    305a:	4a 07       	cpc	r20, r26
    305c:	a0 e4       	ldi	r26, 0x40	; 64
    305e:	5a 07       	cpc	r21, r26
    3060:	10 f0       	brcs	.+4      	; 0x3066 <__pack_f+0x10e>
    3062:	e1 e0       	ldi	r30, 0x01	; 1
    3064:	f0 e0       	ldi	r31, 0x00	; 0
    3066:	79 01       	movw	r14, r18
    3068:	8a 01       	movw	r16, r20
    306a:	27 c0       	rjmp	.+78     	; 0x30ba <__pack_f+0x162>
    306c:	60 38       	cpi	r22, 0x80	; 128
    306e:	71 05       	cpc	r23, r1
    3070:	64 f5       	brge	.+88     	; 0x30ca <__pack_f+0x172>
    3072:	fb 01       	movw	r30, r22
    3074:	e1 58       	subi	r30, 0x81	; 129
    3076:	ff 4f       	sbci	r31, 0xFF	; 255
    3078:	d8 01       	movw	r26, r16
    307a:	c7 01       	movw	r24, r14
    307c:	8f 77       	andi	r24, 0x7F	; 127
    307e:	90 70       	andi	r25, 0x00	; 0
    3080:	a0 70       	andi	r26, 0x00	; 0
    3082:	b0 70       	andi	r27, 0x00	; 0
    3084:	80 34       	cpi	r24, 0x40	; 64
    3086:	91 05       	cpc	r25, r1
    3088:	a1 05       	cpc	r26, r1
    308a:	b1 05       	cpc	r27, r1
    308c:	39 f4       	brne	.+14     	; 0x309c <__pack_f+0x144>
    308e:	e7 fe       	sbrs	r14, 7
    3090:	0d c0       	rjmp	.+26     	; 0x30ac <__pack_f+0x154>
    3092:	80 e4       	ldi	r24, 0x40	; 64
    3094:	90 e0       	ldi	r25, 0x00	; 0
    3096:	a0 e0       	ldi	r26, 0x00	; 0
    3098:	b0 e0       	ldi	r27, 0x00	; 0
    309a:	04 c0       	rjmp	.+8      	; 0x30a4 <__pack_f+0x14c>
    309c:	8f e3       	ldi	r24, 0x3F	; 63
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	a0 e0       	ldi	r26, 0x00	; 0
    30a2:	b0 e0       	ldi	r27, 0x00	; 0
    30a4:	e8 0e       	add	r14, r24
    30a6:	f9 1e       	adc	r15, r25
    30a8:	0a 1f       	adc	r16, r26
    30aa:	1b 1f       	adc	r17, r27
    30ac:	17 ff       	sbrs	r17, 7
    30ae:	05 c0       	rjmp	.+10     	; 0x30ba <__pack_f+0x162>
    30b0:	16 95       	lsr	r17
    30b2:	07 95       	ror	r16
    30b4:	f7 94       	ror	r15
    30b6:	e7 94       	ror	r14
    30b8:	31 96       	adiw	r30, 0x01	; 1
    30ba:	87 e0       	ldi	r24, 0x07	; 7
    30bc:	16 95       	lsr	r17
    30be:	07 95       	ror	r16
    30c0:	f7 94       	ror	r15
    30c2:	e7 94       	ror	r14
    30c4:	8a 95       	dec	r24
    30c6:	d1 f7       	brne	.-12     	; 0x30bc <__pack_f+0x164>
    30c8:	05 c0       	rjmp	.+10     	; 0x30d4 <__pack_f+0x17c>
    30ca:	ee 24       	eor	r14, r14
    30cc:	ff 24       	eor	r15, r15
    30ce:	87 01       	movw	r16, r14
    30d0:	ef ef       	ldi	r30, 0xFF	; 255
    30d2:	f0 e0       	ldi	r31, 0x00	; 0
    30d4:	6e 2f       	mov	r22, r30
    30d6:	67 95       	ror	r22
    30d8:	66 27       	eor	r22, r22
    30da:	67 95       	ror	r22
    30dc:	90 2f       	mov	r25, r16
    30de:	9f 77       	andi	r25, 0x7F	; 127
    30e0:	d7 94       	ror	r13
    30e2:	dd 24       	eor	r13, r13
    30e4:	d7 94       	ror	r13
    30e6:	8e 2f       	mov	r24, r30
    30e8:	86 95       	lsr	r24
    30ea:	49 2f       	mov	r20, r25
    30ec:	46 2b       	or	r20, r22
    30ee:	58 2f       	mov	r21, r24
    30f0:	5d 29       	or	r21, r13
    30f2:	b7 01       	movw	r22, r14
    30f4:	ca 01       	movw	r24, r20
    30f6:	1f 91       	pop	r17
    30f8:	0f 91       	pop	r16
    30fa:	ff 90       	pop	r15
    30fc:	ef 90       	pop	r14
    30fe:	df 90       	pop	r13
    3100:	08 95       	ret

00003102 <__unpack_f>:
    3102:	fc 01       	movw	r30, r24
    3104:	db 01       	movw	r26, r22
    3106:	40 81       	ld	r20, Z
    3108:	51 81       	ldd	r21, Z+1	; 0x01
    310a:	22 81       	ldd	r18, Z+2	; 0x02
    310c:	62 2f       	mov	r22, r18
    310e:	6f 77       	andi	r22, 0x7F	; 127
    3110:	70 e0       	ldi	r23, 0x00	; 0
    3112:	22 1f       	adc	r18, r18
    3114:	22 27       	eor	r18, r18
    3116:	22 1f       	adc	r18, r18
    3118:	93 81       	ldd	r25, Z+3	; 0x03
    311a:	89 2f       	mov	r24, r25
    311c:	88 0f       	add	r24, r24
    311e:	82 2b       	or	r24, r18
    3120:	28 2f       	mov	r18, r24
    3122:	30 e0       	ldi	r19, 0x00	; 0
    3124:	99 1f       	adc	r25, r25
    3126:	99 27       	eor	r25, r25
    3128:	99 1f       	adc	r25, r25
    312a:	11 96       	adiw	r26, 0x01	; 1
    312c:	9c 93       	st	X, r25
    312e:	11 97       	sbiw	r26, 0x01	; 1
    3130:	21 15       	cp	r18, r1
    3132:	31 05       	cpc	r19, r1
    3134:	a9 f5       	brne	.+106    	; 0x31a0 <__unpack_f+0x9e>
    3136:	41 15       	cp	r20, r1
    3138:	51 05       	cpc	r21, r1
    313a:	61 05       	cpc	r22, r1
    313c:	71 05       	cpc	r23, r1
    313e:	11 f4       	brne	.+4      	; 0x3144 <__unpack_f+0x42>
    3140:	82 e0       	ldi	r24, 0x02	; 2
    3142:	37 c0       	rjmp	.+110    	; 0x31b2 <__unpack_f+0xb0>
    3144:	82 e8       	ldi	r24, 0x82	; 130
    3146:	9f ef       	ldi	r25, 0xFF	; 255
    3148:	13 96       	adiw	r26, 0x03	; 3
    314a:	9c 93       	st	X, r25
    314c:	8e 93       	st	-X, r24
    314e:	12 97       	sbiw	r26, 0x02	; 2
    3150:	9a 01       	movw	r18, r20
    3152:	ab 01       	movw	r20, r22
    3154:	67 e0       	ldi	r22, 0x07	; 7
    3156:	22 0f       	add	r18, r18
    3158:	33 1f       	adc	r19, r19
    315a:	44 1f       	adc	r20, r20
    315c:	55 1f       	adc	r21, r21
    315e:	6a 95       	dec	r22
    3160:	d1 f7       	brne	.-12     	; 0x3156 <__unpack_f+0x54>
    3162:	83 e0       	ldi	r24, 0x03	; 3
    3164:	8c 93       	st	X, r24
    3166:	0d c0       	rjmp	.+26     	; 0x3182 <__unpack_f+0x80>
    3168:	22 0f       	add	r18, r18
    316a:	33 1f       	adc	r19, r19
    316c:	44 1f       	adc	r20, r20
    316e:	55 1f       	adc	r21, r21
    3170:	12 96       	adiw	r26, 0x02	; 2
    3172:	8d 91       	ld	r24, X+
    3174:	9c 91       	ld	r25, X
    3176:	13 97       	sbiw	r26, 0x03	; 3
    3178:	01 97       	sbiw	r24, 0x01	; 1
    317a:	13 96       	adiw	r26, 0x03	; 3
    317c:	9c 93       	st	X, r25
    317e:	8e 93       	st	-X, r24
    3180:	12 97       	sbiw	r26, 0x02	; 2
    3182:	20 30       	cpi	r18, 0x00	; 0
    3184:	80 e0       	ldi	r24, 0x00	; 0
    3186:	38 07       	cpc	r19, r24
    3188:	80 e0       	ldi	r24, 0x00	; 0
    318a:	48 07       	cpc	r20, r24
    318c:	80 e4       	ldi	r24, 0x40	; 64
    318e:	58 07       	cpc	r21, r24
    3190:	58 f3       	brcs	.-42     	; 0x3168 <__unpack_f+0x66>
    3192:	14 96       	adiw	r26, 0x04	; 4
    3194:	2d 93       	st	X+, r18
    3196:	3d 93       	st	X+, r19
    3198:	4d 93       	st	X+, r20
    319a:	5c 93       	st	X, r21
    319c:	17 97       	sbiw	r26, 0x07	; 7
    319e:	08 95       	ret
    31a0:	2f 3f       	cpi	r18, 0xFF	; 255
    31a2:	31 05       	cpc	r19, r1
    31a4:	79 f4       	brne	.+30     	; 0x31c4 <__unpack_f+0xc2>
    31a6:	41 15       	cp	r20, r1
    31a8:	51 05       	cpc	r21, r1
    31aa:	61 05       	cpc	r22, r1
    31ac:	71 05       	cpc	r23, r1
    31ae:	19 f4       	brne	.+6      	; 0x31b6 <__unpack_f+0xb4>
    31b0:	84 e0       	ldi	r24, 0x04	; 4
    31b2:	8c 93       	st	X, r24
    31b4:	08 95       	ret
    31b6:	64 ff       	sbrs	r22, 4
    31b8:	03 c0       	rjmp	.+6      	; 0x31c0 <__unpack_f+0xbe>
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	8c 93       	st	X, r24
    31be:	12 c0       	rjmp	.+36     	; 0x31e4 <__unpack_f+0xe2>
    31c0:	1c 92       	st	X, r1
    31c2:	10 c0       	rjmp	.+32     	; 0x31e4 <__unpack_f+0xe2>
    31c4:	2f 57       	subi	r18, 0x7F	; 127
    31c6:	30 40       	sbci	r19, 0x00	; 0
    31c8:	13 96       	adiw	r26, 0x03	; 3
    31ca:	3c 93       	st	X, r19
    31cc:	2e 93       	st	-X, r18
    31ce:	12 97       	sbiw	r26, 0x02	; 2
    31d0:	83 e0       	ldi	r24, 0x03	; 3
    31d2:	8c 93       	st	X, r24
    31d4:	87 e0       	ldi	r24, 0x07	; 7
    31d6:	44 0f       	add	r20, r20
    31d8:	55 1f       	adc	r21, r21
    31da:	66 1f       	adc	r22, r22
    31dc:	77 1f       	adc	r23, r23
    31de:	8a 95       	dec	r24
    31e0:	d1 f7       	brne	.-12     	; 0x31d6 <__unpack_f+0xd4>
    31e2:	70 64       	ori	r23, 0x40	; 64
    31e4:	14 96       	adiw	r26, 0x04	; 4
    31e6:	4d 93       	st	X+, r20
    31e8:	5d 93       	st	X+, r21
    31ea:	6d 93       	st	X+, r22
    31ec:	7c 93       	st	X, r23
    31ee:	17 97       	sbiw	r26, 0x07	; 7
    31f0:	08 95       	ret

000031f2 <__fpcmp_parts_f>:
    31f2:	1f 93       	push	r17
    31f4:	dc 01       	movw	r26, r24
    31f6:	fb 01       	movw	r30, r22
    31f8:	9c 91       	ld	r25, X
    31fa:	92 30       	cpi	r25, 0x02	; 2
    31fc:	08 f4       	brcc	.+2      	; 0x3200 <__fpcmp_parts_f+0xe>
    31fe:	47 c0       	rjmp	.+142    	; 0x328e <__fpcmp_parts_f+0x9c>
    3200:	80 81       	ld	r24, Z
    3202:	82 30       	cpi	r24, 0x02	; 2
    3204:	08 f4       	brcc	.+2      	; 0x3208 <__fpcmp_parts_f+0x16>
    3206:	43 c0       	rjmp	.+134    	; 0x328e <__fpcmp_parts_f+0x9c>
    3208:	94 30       	cpi	r25, 0x04	; 4
    320a:	51 f4       	brne	.+20     	; 0x3220 <__fpcmp_parts_f+0x2e>
    320c:	11 96       	adiw	r26, 0x01	; 1
    320e:	1c 91       	ld	r17, X
    3210:	84 30       	cpi	r24, 0x04	; 4
    3212:	99 f5       	brne	.+102    	; 0x327a <__fpcmp_parts_f+0x88>
    3214:	81 81       	ldd	r24, Z+1	; 0x01
    3216:	68 2f       	mov	r22, r24
    3218:	70 e0       	ldi	r23, 0x00	; 0
    321a:	61 1b       	sub	r22, r17
    321c:	71 09       	sbc	r23, r1
    321e:	3f c0       	rjmp	.+126    	; 0x329e <__fpcmp_parts_f+0xac>
    3220:	84 30       	cpi	r24, 0x04	; 4
    3222:	21 f0       	breq	.+8      	; 0x322c <__fpcmp_parts_f+0x3a>
    3224:	92 30       	cpi	r25, 0x02	; 2
    3226:	31 f4       	brne	.+12     	; 0x3234 <__fpcmp_parts_f+0x42>
    3228:	82 30       	cpi	r24, 0x02	; 2
    322a:	b9 f1       	breq	.+110    	; 0x329a <__fpcmp_parts_f+0xa8>
    322c:	81 81       	ldd	r24, Z+1	; 0x01
    322e:	88 23       	and	r24, r24
    3230:	89 f1       	breq	.+98     	; 0x3294 <__fpcmp_parts_f+0xa2>
    3232:	2d c0       	rjmp	.+90     	; 0x328e <__fpcmp_parts_f+0x9c>
    3234:	11 96       	adiw	r26, 0x01	; 1
    3236:	1c 91       	ld	r17, X
    3238:	11 97       	sbiw	r26, 0x01	; 1
    323a:	82 30       	cpi	r24, 0x02	; 2
    323c:	f1 f0       	breq	.+60     	; 0x327a <__fpcmp_parts_f+0x88>
    323e:	81 81       	ldd	r24, Z+1	; 0x01
    3240:	18 17       	cp	r17, r24
    3242:	d9 f4       	brne	.+54     	; 0x327a <__fpcmp_parts_f+0x88>
    3244:	12 96       	adiw	r26, 0x02	; 2
    3246:	2d 91       	ld	r18, X+
    3248:	3c 91       	ld	r19, X
    324a:	13 97       	sbiw	r26, 0x03	; 3
    324c:	82 81       	ldd	r24, Z+2	; 0x02
    324e:	93 81       	ldd	r25, Z+3	; 0x03
    3250:	82 17       	cp	r24, r18
    3252:	93 07       	cpc	r25, r19
    3254:	94 f0       	brlt	.+36     	; 0x327a <__fpcmp_parts_f+0x88>
    3256:	28 17       	cp	r18, r24
    3258:	39 07       	cpc	r19, r25
    325a:	bc f0       	brlt	.+46     	; 0x328a <__fpcmp_parts_f+0x98>
    325c:	14 96       	adiw	r26, 0x04	; 4
    325e:	8d 91       	ld	r24, X+
    3260:	9d 91       	ld	r25, X+
    3262:	0d 90       	ld	r0, X+
    3264:	bc 91       	ld	r27, X
    3266:	a0 2d       	mov	r26, r0
    3268:	24 81       	ldd	r18, Z+4	; 0x04
    326a:	35 81       	ldd	r19, Z+5	; 0x05
    326c:	46 81       	ldd	r20, Z+6	; 0x06
    326e:	57 81       	ldd	r21, Z+7	; 0x07
    3270:	28 17       	cp	r18, r24
    3272:	39 07       	cpc	r19, r25
    3274:	4a 07       	cpc	r20, r26
    3276:	5b 07       	cpc	r21, r27
    3278:	18 f4       	brcc	.+6      	; 0x3280 <__fpcmp_parts_f+0x8e>
    327a:	11 23       	and	r17, r17
    327c:	41 f0       	breq	.+16     	; 0x328e <__fpcmp_parts_f+0x9c>
    327e:	0a c0       	rjmp	.+20     	; 0x3294 <__fpcmp_parts_f+0xa2>
    3280:	82 17       	cp	r24, r18
    3282:	93 07       	cpc	r25, r19
    3284:	a4 07       	cpc	r26, r20
    3286:	b5 07       	cpc	r27, r21
    3288:	40 f4       	brcc	.+16     	; 0x329a <__fpcmp_parts_f+0xa8>
    328a:	11 23       	and	r17, r17
    328c:	19 f0       	breq	.+6      	; 0x3294 <__fpcmp_parts_f+0xa2>
    328e:	61 e0       	ldi	r22, 0x01	; 1
    3290:	70 e0       	ldi	r23, 0x00	; 0
    3292:	05 c0       	rjmp	.+10     	; 0x329e <__fpcmp_parts_f+0xac>
    3294:	6f ef       	ldi	r22, 0xFF	; 255
    3296:	7f ef       	ldi	r23, 0xFF	; 255
    3298:	02 c0       	rjmp	.+4      	; 0x329e <__fpcmp_parts_f+0xac>
    329a:	60 e0       	ldi	r22, 0x00	; 0
    329c:	70 e0       	ldi	r23, 0x00	; 0
    329e:	cb 01       	movw	r24, r22
    32a0:	1f 91       	pop	r17
    32a2:	08 95       	ret

000032a4 <__mulsi3>:
    32a4:	62 9f       	mul	r22, r18
    32a6:	d0 01       	movw	r26, r0
    32a8:	73 9f       	mul	r23, r19
    32aa:	f0 01       	movw	r30, r0
    32ac:	82 9f       	mul	r24, r18
    32ae:	e0 0d       	add	r30, r0
    32b0:	f1 1d       	adc	r31, r1
    32b2:	64 9f       	mul	r22, r20
    32b4:	e0 0d       	add	r30, r0
    32b6:	f1 1d       	adc	r31, r1
    32b8:	92 9f       	mul	r25, r18
    32ba:	f0 0d       	add	r31, r0
    32bc:	83 9f       	mul	r24, r19
    32be:	f0 0d       	add	r31, r0
    32c0:	74 9f       	mul	r23, r20
    32c2:	f0 0d       	add	r31, r0
    32c4:	65 9f       	mul	r22, r21
    32c6:	f0 0d       	add	r31, r0
    32c8:	99 27       	eor	r25, r25
    32ca:	72 9f       	mul	r23, r18
    32cc:	b0 0d       	add	r27, r0
    32ce:	e1 1d       	adc	r30, r1
    32d0:	f9 1f       	adc	r31, r25
    32d2:	63 9f       	mul	r22, r19
    32d4:	b0 0d       	add	r27, r0
    32d6:	e1 1d       	adc	r30, r1
    32d8:	f9 1f       	adc	r31, r25
    32da:	bd 01       	movw	r22, r26
    32dc:	cf 01       	movw	r24, r30
    32de:	11 24       	eor	r1, r1
    32e0:	08 95       	ret

000032e2 <__udivmodhi4>:
    32e2:	aa 1b       	sub	r26, r26
    32e4:	bb 1b       	sub	r27, r27
    32e6:	51 e1       	ldi	r21, 0x11	; 17
    32e8:	07 c0       	rjmp	.+14     	; 0x32f8 <__udivmodhi4_ep>

000032ea <__udivmodhi4_loop>:
    32ea:	aa 1f       	adc	r26, r26
    32ec:	bb 1f       	adc	r27, r27
    32ee:	a6 17       	cp	r26, r22
    32f0:	b7 07       	cpc	r27, r23
    32f2:	10 f0       	brcs	.+4      	; 0x32f8 <__udivmodhi4_ep>
    32f4:	a6 1b       	sub	r26, r22
    32f6:	b7 0b       	sbc	r27, r23

000032f8 <__udivmodhi4_ep>:
    32f8:	88 1f       	adc	r24, r24
    32fa:	99 1f       	adc	r25, r25
    32fc:	5a 95       	dec	r21
    32fe:	a9 f7       	brne	.-22     	; 0x32ea <__udivmodhi4_loop>
    3300:	80 95       	com	r24
    3302:	90 95       	com	r25
    3304:	bc 01       	movw	r22, r24
    3306:	cd 01       	movw	r24, r26
    3308:	08 95       	ret

0000330a <__divmodhi4>:
    330a:	97 fb       	bst	r25, 7
    330c:	09 2e       	mov	r0, r25
    330e:	07 26       	eor	r0, r23
    3310:	0a d0       	rcall	.+20     	; 0x3326 <__divmodhi4_neg1>
    3312:	77 fd       	sbrc	r23, 7
    3314:	04 d0       	rcall	.+8      	; 0x331e <__divmodhi4_neg2>
    3316:	e5 df       	rcall	.-54     	; 0x32e2 <__udivmodhi4>
    3318:	06 d0       	rcall	.+12     	; 0x3326 <__divmodhi4_neg1>
    331a:	00 20       	and	r0, r0
    331c:	1a f4       	brpl	.+6      	; 0x3324 <__divmodhi4_exit>

0000331e <__divmodhi4_neg2>:
    331e:	70 95       	com	r23
    3320:	61 95       	neg	r22
    3322:	7f 4f       	sbci	r23, 0xFF	; 255

00003324 <__divmodhi4_exit>:
    3324:	08 95       	ret

00003326 <__divmodhi4_neg1>:
    3326:	f6 f7       	brtc	.-4      	; 0x3324 <__divmodhi4_exit>
    3328:	90 95       	com	r25
    332a:	81 95       	neg	r24
    332c:	9f 4f       	sbci	r25, 0xFF	; 255
    332e:	08 95       	ret

00003330 <__udivmodsi4>:
    3330:	a1 e2       	ldi	r26, 0x21	; 33
    3332:	1a 2e       	mov	r1, r26
    3334:	aa 1b       	sub	r26, r26
    3336:	bb 1b       	sub	r27, r27
    3338:	fd 01       	movw	r30, r26
    333a:	0d c0       	rjmp	.+26     	; 0x3356 <__udivmodsi4_ep>

0000333c <__udivmodsi4_loop>:
    333c:	aa 1f       	adc	r26, r26
    333e:	bb 1f       	adc	r27, r27
    3340:	ee 1f       	adc	r30, r30
    3342:	ff 1f       	adc	r31, r31
    3344:	a2 17       	cp	r26, r18
    3346:	b3 07       	cpc	r27, r19
    3348:	e4 07       	cpc	r30, r20
    334a:	f5 07       	cpc	r31, r21
    334c:	20 f0       	brcs	.+8      	; 0x3356 <__udivmodsi4_ep>
    334e:	a2 1b       	sub	r26, r18
    3350:	b3 0b       	sbc	r27, r19
    3352:	e4 0b       	sbc	r30, r20
    3354:	f5 0b       	sbc	r31, r21

00003356 <__udivmodsi4_ep>:
    3356:	66 1f       	adc	r22, r22
    3358:	77 1f       	adc	r23, r23
    335a:	88 1f       	adc	r24, r24
    335c:	99 1f       	adc	r25, r25
    335e:	1a 94       	dec	r1
    3360:	69 f7       	brne	.-38     	; 0x333c <__udivmodsi4_loop>
    3362:	60 95       	com	r22
    3364:	70 95       	com	r23
    3366:	80 95       	com	r24
    3368:	90 95       	com	r25
    336a:	9b 01       	movw	r18, r22
    336c:	ac 01       	movw	r20, r24
    336e:	bd 01       	movw	r22, r26
    3370:	cf 01       	movw	r24, r30
    3372:	08 95       	ret

00003374 <__prologue_saves__>:
    3374:	2f 92       	push	r2
    3376:	3f 92       	push	r3
    3378:	4f 92       	push	r4
    337a:	5f 92       	push	r5
    337c:	6f 92       	push	r6
    337e:	7f 92       	push	r7
    3380:	8f 92       	push	r8
    3382:	9f 92       	push	r9
    3384:	af 92       	push	r10
    3386:	bf 92       	push	r11
    3388:	cf 92       	push	r12
    338a:	df 92       	push	r13
    338c:	ef 92       	push	r14
    338e:	ff 92       	push	r15
    3390:	0f 93       	push	r16
    3392:	1f 93       	push	r17
    3394:	cf 93       	push	r28
    3396:	df 93       	push	r29
    3398:	cd b7       	in	r28, 0x3d	; 61
    339a:	de b7       	in	r29, 0x3e	; 62
    339c:	ca 1b       	sub	r28, r26
    339e:	db 0b       	sbc	r29, r27
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	de bf       	out	0x3e, r29	; 62
    33a6:	0f be       	out	0x3f, r0	; 63
    33a8:	cd bf       	out	0x3d, r28	; 61
    33aa:	09 94       	ijmp

000033ac <__epilogue_restores__>:
    33ac:	2a 88       	ldd	r2, Y+18	; 0x12
    33ae:	39 88       	ldd	r3, Y+17	; 0x11
    33b0:	48 88       	ldd	r4, Y+16	; 0x10
    33b2:	5f 84       	ldd	r5, Y+15	; 0x0f
    33b4:	6e 84       	ldd	r6, Y+14	; 0x0e
    33b6:	7d 84       	ldd	r7, Y+13	; 0x0d
    33b8:	8c 84       	ldd	r8, Y+12	; 0x0c
    33ba:	9b 84       	ldd	r9, Y+11	; 0x0b
    33bc:	aa 84       	ldd	r10, Y+10	; 0x0a
    33be:	b9 84       	ldd	r11, Y+9	; 0x09
    33c0:	c8 84       	ldd	r12, Y+8	; 0x08
    33c2:	df 80       	ldd	r13, Y+7	; 0x07
    33c4:	ee 80       	ldd	r14, Y+6	; 0x06
    33c6:	fd 80       	ldd	r15, Y+5	; 0x05
    33c8:	0c 81       	ldd	r16, Y+4	; 0x04
    33ca:	1b 81       	ldd	r17, Y+3	; 0x03
    33cc:	aa 81       	ldd	r26, Y+2	; 0x02
    33ce:	b9 81       	ldd	r27, Y+1	; 0x01
    33d0:	ce 0f       	add	r28, r30
    33d2:	d1 1d       	adc	r29, r1
    33d4:	0f b6       	in	r0, 0x3f	; 63
    33d6:	f8 94       	cli
    33d8:	de bf       	out	0x3e, r29	; 62
    33da:	0f be       	out	0x3f, r0	; 63
    33dc:	cd bf       	out	0x3d, r28	; 61
    33de:	ed 01       	movw	r28, r26
    33e0:	08 95       	ret

000033e2 <malloc>:
    33e2:	cf 93       	push	r28
    33e4:	df 93       	push	r29
    33e6:	bc 01       	movw	r22, r24
    33e8:	82 30       	cpi	r24, 0x02	; 2
    33ea:	91 05       	cpc	r25, r1
    33ec:	10 f4       	brcc	.+4      	; 0x33f2 <malloc+0x10>
    33ee:	62 e0       	ldi	r22, 0x02	; 2
    33f0:	70 e0       	ldi	r23, 0x00	; 0
    33f2:	a0 91 dc 03 	lds	r26, 0x03DC
    33f6:	b0 91 dd 03 	lds	r27, 0x03DD
    33fa:	ed 01       	movw	r28, r26
    33fc:	e0 e0       	ldi	r30, 0x00	; 0
    33fe:	f0 e0       	ldi	r31, 0x00	; 0
    3400:	40 e0       	ldi	r20, 0x00	; 0
    3402:	50 e0       	ldi	r21, 0x00	; 0
    3404:	21 c0       	rjmp	.+66     	; 0x3448 <malloc+0x66>
    3406:	88 81       	ld	r24, Y
    3408:	99 81       	ldd	r25, Y+1	; 0x01
    340a:	86 17       	cp	r24, r22
    340c:	97 07       	cpc	r25, r23
    340e:	69 f4       	brne	.+26     	; 0x342a <malloc+0x48>
    3410:	8a 81       	ldd	r24, Y+2	; 0x02
    3412:	9b 81       	ldd	r25, Y+3	; 0x03
    3414:	30 97       	sbiw	r30, 0x00	; 0
    3416:	19 f0       	breq	.+6      	; 0x341e <malloc+0x3c>
    3418:	93 83       	std	Z+3, r25	; 0x03
    341a:	82 83       	std	Z+2, r24	; 0x02
    341c:	04 c0       	rjmp	.+8      	; 0x3426 <malloc+0x44>
    341e:	90 93 dd 03 	sts	0x03DD, r25
    3422:	80 93 dc 03 	sts	0x03DC, r24
    3426:	fe 01       	movw	r30, r28
    3428:	34 c0       	rjmp	.+104    	; 0x3492 <malloc+0xb0>
    342a:	68 17       	cp	r22, r24
    342c:	79 07       	cpc	r23, r25
    342e:	38 f4       	brcc	.+14     	; 0x343e <malloc+0x5c>
    3430:	41 15       	cp	r20, r1
    3432:	51 05       	cpc	r21, r1
    3434:	19 f0       	breq	.+6      	; 0x343c <malloc+0x5a>
    3436:	84 17       	cp	r24, r20
    3438:	95 07       	cpc	r25, r21
    343a:	08 f4       	brcc	.+2      	; 0x343e <malloc+0x5c>
    343c:	ac 01       	movw	r20, r24
    343e:	fe 01       	movw	r30, r28
    3440:	8a 81       	ldd	r24, Y+2	; 0x02
    3442:	9b 81       	ldd	r25, Y+3	; 0x03
    3444:	9c 01       	movw	r18, r24
    3446:	e9 01       	movw	r28, r18
    3448:	20 97       	sbiw	r28, 0x00	; 0
    344a:	e9 f6       	brne	.-70     	; 0x3406 <malloc+0x24>
    344c:	41 15       	cp	r20, r1
    344e:	51 05       	cpc	r21, r1
    3450:	a9 f1       	breq	.+106    	; 0x34bc <malloc+0xda>
    3452:	ca 01       	movw	r24, r20
    3454:	86 1b       	sub	r24, r22
    3456:	97 0b       	sbc	r25, r23
    3458:	04 97       	sbiw	r24, 0x04	; 4
    345a:	08 f4       	brcc	.+2      	; 0x345e <malloc+0x7c>
    345c:	ba 01       	movw	r22, r20
    345e:	e0 e0       	ldi	r30, 0x00	; 0
    3460:	f0 e0       	ldi	r31, 0x00	; 0
    3462:	2a c0       	rjmp	.+84     	; 0x34b8 <malloc+0xd6>
    3464:	8d 91       	ld	r24, X+
    3466:	9c 91       	ld	r25, X
    3468:	11 97       	sbiw	r26, 0x01	; 1
    346a:	84 17       	cp	r24, r20
    346c:	95 07       	cpc	r25, r21
    346e:	f9 f4       	brne	.+62     	; 0x34ae <malloc+0xcc>
    3470:	64 17       	cp	r22, r20
    3472:	75 07       	cpc	r23, r21
    3474:	81 f4       	brne	.+32     	; 0x3496 <malloc+0xb4>
    3476:	12 96       	adiw	r26, 0x02	; 2
    3478:	8d 91       	ld	r24, X+
    347a:	9c 91       	ld	r25, X
    347c:	13 97       	sbiw	r26, 0x03	; 3
    347e:	30 97       	sbiw	r30, 0x00	; 0
    3480:	19 f0       	breq	.+6      	; 0x3488 <malloc+0xa6>
    3482:	93 83       	std	Z+3, r25	; 0x03
    3484:	82 83       	std	Z+2, r24	; 0x02
    3486:	04 c0       	rjmp	.+8      	; 0x3490 <malloc+0xae>
    3488:	90 93 dd 03 	sts	0x03DD, r25
    348c:	80 93 dc 03 	sts	0x03DC, r24
    3490:	fd 01       	movw	r30, r26
    3492:	32 96       	adiw	r30, 0x02	; 2
    3494:	4f c0       	rjmp	.+158    	; 0x3534 <malloc+0x152>
    3496:	ca 01       	movw	r24, r20
    3498:	86 1b       	sub	r24, r22
    349a:	97 0b       	sbc	r25, r23
    349c:	fd 01       	movw	r30, r26
    349e:	e8 0f       	add	r30, r24
    34a0:	f9 1f       	adc	r31, r25
    34a2:	61 93       	st	Z+, r22
    34a4:	71 93       	st	Z+, r23
    34a6:	02 97       	sbiw	r24, 0x02	; 2
    34a8:	8d 93       	st	X+, r24
    34aa:	9c 93       	st	X, r25
    34ac:	43 c0       	rjmp	.+134    	; 0x3534 <malloc+0x152>
    34ae:	fd 01       	movw	r30, r26
    34b0:	82 81       	ldd	r24, Z+2	; 0x02
    34b2:	93 81       	ldd	r25, Z+3	; 0x03
    34b4:	9c 01       	movw	r18, r24
    34b6:	d9 01       	movw	r26, r18
    34b8:	10 97       	sbiw	r26, 0x00	; 0
    34ba:	a1 f6       	brne	.-88     	; 0x3464 <malloc+0x82>
    34bc:	80 91 da 03 	lds	r24, 0x03DA
    34c0:	90 91 db 03 	lds	r25, 0x03DB
    34c4:	89 2b       	or	r24, r25
    34c6:	41 f4       	brne	.+16     	; 0x34d8 <malloc+0xf6>
    34c8:	80 91 bd 02 	lds	r24, 0x02BD
    34cc:	90 91 be 02 	lds	r25, 0x02BE
    34d0:	90 93 db 03 	sts	0x03DB, r25
    34d4:	80 93 da 03 	sts	0x03DA, r24
    34d8:	40 91 bf 02 	lds	r20, 0x02BF
    34dc:	50 91 c0 02 	lds	r21, 0x02C0
    34e0:	41 15       	cp	r20, r1
    34e2:	51 05       	cpc	r21, r1
    34e4:	41 f4       	brne	.+16     	; 0x34f6 <malloc+0x114>
    34e6:	4d b7       	in	r20, 0x3d	; 61
    34e8:	5e b7       	in	r21, 0x3e	; 62
    34ea:	80 91 bb 02 	lds	r24, 0x02BB
    34ee:	90 91 bc 02 	lds	r25, 0x02BC
    34f2:	48 1b       	sub	r20, r24
    34f4:	59 0b       	sbc	r21, r25
    34f6:	20 91 da 03 	lds	r18, 0x03DA
    34fa:	30 91 db 03 	lds	r19, 0x03DB
    34fe:	24 17       	cp	r18, r20
    3500:	35 07       	cpc	r19, r21
    3502:	b0 f4       	brcc	.+44     	; 0x3530 <malloc+0x14e>
    3504:	ca 01       	movw	r24, r20
    3506:	82 1b       	sub	r24, r18
    3508:	93 0b       	sbc	r25, r19
    350a:	86 17       	cp	r24, r22
    350c:	97 07       	cpc	r25, r23
    350e:	80 f0       	brcs	.+32     	; 0x3530 <malloc+0x14e>
    3510:	ab 01       	movw	r20, r22
    3512:	4e 5f       	subi	r20, 0xFE	; 254
    3514:	5f 4f       	sbci	r21, 0xFF	; 255
    3516:	84 17       	cp	r24, r20
    3518:	95 07       	cpc	r25, r21
    351a:	50 f0       	brcs	.+20     	; 0x3530 <malloc+0x14e>
    351c:	42 0f       	add	r20, r18
    351e:	53 1f       	adc	r21, r19
    3520:	50 93 db 03 	sts	0x03DB, r21
    3524:	40 93 da 03 	sts	0x03DA, r20
    3528:	f9 01       	movw	r30, r18
    352a:	61 93       	st	Z+, r22
    352c:	71 93       	st	Z+, r23
    352e:	02 c0       	rjmp	.+4      	; 0x3534 <malloc+0x152>
    3530:	e0 e0       	ldi	r30, 0x00	; 0
    3532:	f0 e0       	ldi	r31, 0x00	; 0
    3534:	cf 01       	movw	r24, r30
    3536:	df 91       	pop	r29
    3538:	cf 91       	pop	r28
    353a:	08 95       	ret

0000353c <free>:
    353c:	cf 93       	push	r28
    353e:	df 93       	push	r29
    3540:	00 97       	sbiw	r24, 0x00	; 0
    3542:	09 f4       	brne	.+2      	; 0x3546 <free+0xa>
    3544:	50 c0       	rjmp	.+160    	; 0x35e6 <free+0xaa>
    3546:	ec 01       	movw	r28, r24
    3548:	22 97       	sbiw	r28, 0x02	; 2
    354a:	1b 82       	std	Y+3, r1	; 0x03
    354c:	1a 82       	std	Y+2, r1	; 0x02
    354e:	a0 91 dc 03 	lds	r26, 0x03DC
    3552:	b0 91 dd 03 	lds	r27, 0x03DD
    3556:	10 97       	sbiw	r26, 0x00	; 0
    3558:	09 f1       	breq	.+66     	; 0x359c <free+0x60>
    355a:	40 e0       	ldi	r20, 0x00	; 0
    355c:	50 e0       	ldi	r21, 0x00	; 0
    355e:	ac 17       	cp	r26, r28
    3560:	bd 07       	cpc	r27, r29
    3562:	08 f1       	brcs	.+66     	; 0x35a6 <free+0x6a>
    3564:	bb 83       	std	Y+3, r27	; 0x03
    3566:	aa 83       	std	Y+2, r26	; 0x02
    3568:	fe 01       	movw	r30, r28
    356a:	21 91       	ld	r18, Z+
    356c:	31 91       	ld	r19, Z+
    356e:	e2 0f       	add	r30, r18
    3570:	f3 1f       	adc	r31, r19
    3572:	ae 17       	cp	r26, r30
    3574:	bf 07       	cpc	r27, r31
    3576:	79 f4       	brne	.+30     	; 0x3596 <free+0x5a>
    3578:	8d 91       	ld	r24, X+
    357a:	9c 91       	ld	r25, X
    357c:	11 97       	sbiw	r26, 0x01	; 1
    357e:	28 0f       	add	r18, r24
    3580:	39 1f       	adc	r19, r25
    3582:	2e 5f       	subi	r18, 0xFE	; 254
    3584:	3f 4f       	sbci	r19, 0xFF	; 255
    3586:	39 83       	std	Y+1, r19	; 0x01
    3588:	28 83       	st	Y, r18
    358a:	12 96       	adiw	r26, 0x02	; 2
    358c:	8d 91       	ld	r24, X+
    358e:	9c 91       	ld	r25, X
    3590:	13 97       	sbiw	r26, 0x03	; 3
    3592:	9b 83       	std	Y+3, r25	; 0x03
    3594:	8a 83       	std	Y+2, r24	; 0x02
    3596:	41 15       	cp	r20, r1
    3598:	51 05       	cpc	r21, r1
    359a:	71 f4       	brne	.+28     	; 0x35b8 <free+0x7c>
    359c:	d0 93 dd 03 	sts	0x03DD, r29
    35a0:	c0 93 dc 03 	sts	0x03DC, r28
    35a4:	20 c0       	rjmp	.+64     	; 0x35e6 <free+0xaa>
    35a6:	12 96       	adiw	r26, 0x02	; 2
    35a8:	8d 91       	ld	r24, X+
    35aa:	9c 91       	ld	r25, X
    35ac:	13 97       	sbiw	r26, 0x03	; 3
    35ae:	ad 01       	movw	r20, r26
    35b0:	00 97       	sbiw	r24, 0x00	; 0
    35b2:	11 f0       	breq	.+4      	; 0x35b8 <free+0x7c>
    35b4:	dc 01       	movw	r26, r24
    35b6:	d3 cf       	rjmp	.-90     	; 0x355e <free+0x22>
    35b8:	fa 01       	movw	r30, r20
    35ba:	d3 83       	std	Z+3, r29	; 0x03
    35bc:	c2 83       	std	Z+2, r28	; 0x02
    35be:	21 91       	ld	r18, Z+
    35c0:	31 91       	ld	r19, Z+
    35c2:	e2 0f       	add	r30, r18
    35c4:	f3 1f       	adc	r31, r19
    35c6:	ce 17       	cp	r28, r30
    35c8:	df 07       	cpc	r29, r31
    35ca:	69 f4       	brne	.+26     	; 0x35e6 <free+0xaa>
    35cc:	88 81       	ld	r24, Y
    35ce:	99 81       	ldd	r25, Y+1	; 0x01
    35d0:	28 0f       	add	r18, r24
    35d2:	39 1f       	adc	r19, r25
    35d4:	2e 5f       	subi	r18, 0xFE	; 254
    35d6:	3f 4f       	sbci	r19, 0xFF	; 255
    35d8:	fa 01       	movw	r30, r20
    35da:	31 83       	std	Z+1, r19	; 0x01
    35dc:	20 83       	st	Z, r18
    35de:	8a 81       	ldd	r24, Y+2	; 0x02
    35e0:	9b 81       	ldd	r25, Y+3	; 0x03
    35e2:	93 83       	std	Z+3, r25	; 0x03
    35e4:	82 83       	std	Z+2, r24	; 0x02
    35e6:	df 91       	pop	r29
    35e8:	cf 91       	pop	r28
    35ea:	08 95       	ret

000035ec <strcmp>:
    35ec:	fb 01       	movw	r30, r22
    35ee:	dc 01       	movw	r26, r24
    35f0:	8d 91       	ld	r24, X+
    35f2:	01 90       	ld	r0, Z+
    35f4:	80 19       	sub	r24, r0
    35f6:	01 10       	cpse	r0, r1
    35f8:	d9 f3       	breq	.-10     	; 0x35f0 <strcmp+0x4>
    35fa:	99 0b       	sbc	r25, r25
    35fc:	08 95       	ret

000035fe <strncmp>:
    35fe:	fb 01       	movw	r30, r22
    3600:	dc 01       	movw	r26, r24
    3602:	41 50       	subi	r20, 0x01	; 1
    3604:	50 40       	sbci	r21, 0x00	; 0
    3606:	30 f0       	brcs	.+12     	; 0x3614 <strncmp+0x16>
    3608:	8d 91       	ld	r24, X+
    360a:	01 90       	ld	r0, Z+
    360c:	80 19       	sub	r24, r0
    360e:	19 f4       	brne	.+6      	; 0x3616 <strncmp+0x18>
    3610:	00 20       	and	r0, r0
    3612:	b9 f7       	brne	.-18     	; 0x3602 <strncmp+0x4>
    3614:	88 1b       	sub	r24, r24
    3616:	99 0b       	sbc	r25, r25
    3618:	08 95       	ret

0000361a <strncpy>:
    361a:	fb 01       	movw	r30, r22
    361c:	dc 01       	movw	r26, r24
    361e:	41 50       	subi	r20, 0x01	; 1
    3620:	50 40       	sbci	r21, 0x00	; 0
    3622:	48 f0       	brcs	.+18     	; 0x3636 <strncpy+0x1c>
    3624:	01 90       	ld	r0, Z+
    3626:	0d 92       	st	X+, r0
    3628:	00 20       	and	r0, r0
    362a:	c9 f7       	brne	.-14     	; 0x361e <strncpy+0x4>
    362c:	01 c0       	rjmp	.+2      	; 0x3630 <strncpy+0x16>
    362e:	1d 92       	st	X+, r1
    3630:	41 50       	subi	r20, 0x01	; 1
    3632:	50 40       	sbci	r21, 0x00	; 0
    3634:	e0 f7       	brcc	.-8      	; 0x362e <strncpy+0x14>
    3636:	08 95       	ret

00003638 <fdevopen>:
    3638:	0f 93       	push	r16
    363a:	1f 93       	push	r17
    363c:	cf 93       	push	r28
    363e:	df 93       	push	r29
    3640:	8c 01       	movw	r16, r24
    3642:	eb 01       	movw	r28, r22
    3644:	00 97       	sbiw	r24, 0x00	; 0
    3646:	31 f4       	brne	.+12     	; 0x3654 <fdevopen+0x1c>
    3648:	61 15       	cp	r22, r1
    364a:	71 05       	cpc	r23, r1
    364c:	19 f4       	brne	.+6      	; 0x3654 <fdevopen+0x1c>
    364e:	20 e0       	ldi	r18, 0x00	; 0
    3650:	30 e0       	ldi	r19, 0x00	; 0
    3652:	38 c0       	rjmp	.+112    	; 0x36c4 <fdevopen+0x8c>
    3654:	81 e0       	ldi	r24, 0x01	; 1
    3656:	90 e0       	ldi	r25, 0x00	; 0
    3658:	6e e0       	ldi	r22, 0x0E	; 14
    365a:	70 e0       	ldi	r23, 0x00	; 0
    365c:	0e 94 a5 1b 	call	0x374a	; 0x374a <calloc>
    3660:	fc 01       	movw	r30, r24
    3662:	9c 01       	movw	r18, r24
    3664:	00 97       	sbiw	r24, 0x00	; 0
    3666:	71 f1       	breq	.+92     	; 0x36c4 <fdevopen+0x8c>
    3668:	80 e8       	ldi	r24, 0x80	; 128
    366a:	83 83       	std	Z+3, r24	; 0x03
    366c:	20 97       	sbiw	r28, 0x00	; 0
    366e:	71 f0       	breq	.+28     	; 0x368c <fdevopen+0x54>
    3670:	d3 87       	std	Z+11, r29	; 0x0b
    3672:	c2 87       	std	Z+10, r28	; 0x0a
    3674:	81 e8       	ldi	r24, 0x81	; 129
    3676:	83 83       	std	Z+3, r24	; 0x03
    3678:	80 91 de 03 	lds	r24, 0x03DE
    367c:	90 91 df 03 	lds	r25, 0x03DF
    3680:	89 2b       	or	r24, r25
    3682:	21 f4       	brne	.+8      	; 0x368c <fdevopen+0x54>
    3684:	f0 93 df 03 	sts	0x03DF, r31
    3688:	e0 93 de 03 	sts	0x03DE, r30
    368c:	01 15       	cp	r16, r1
    368e:	11 05       	cpc	r17, r1
    3690:	c9 f0       	breq	.+50     	; 0x36c4 <fdevopen+0x8c>
    3692:	11 87       	std	Z+9, r17	; 0x09
    3694:	00 87       	std	Z+8, r16	; 0x08
    3696:	83 81       	ldd	r24, Z+3	; 0x03
    3698:	82 60       	ori	r24, 0x02	; 2
    369a:	83 83       	std	Z+3, r24	; 0x03
    369c:	80 91 e0 03 	lds	r24, 0x03E0
    36a0:	90 91 e1 03 	lds	r25, 0x03E1
    36a4:	89 2b       	or	r24, r25
    36a6:	71 f4       	brne	.+28     	; 0x36c4 <fdevopen+0x8c>
    36a8:	f0 93 e1 03 	sts	0x03E1, r31
    36ac:	e0 93 e0 03 	sts	0x03E0, r30
    36b0:	80 91 e2 03 	lds	r24, 0x03E2
    36b4:	90 91 e3 03 	lds	r25, 0x03E3
    36b8:	89 2b       	or	r24, r25
    36ba:	21 f4       	brne	.+8      	; 0x36c4 <fdevopen+0x8c>
    36bc:	f0 93 e3 03 	sts	0x03E3, r31
    36c0:	e0 93 e2 03 	sts	0x03E2, r30
    36c4:	c9 01       	movw	r24, r18
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	1f 91       	pop	r17
    36cc:	0f 91       	pop	r16
    36ce:	08 95       	ret

000036d0 <puts>:
    36d0:	0f 93       	push	r16
    36d2:	1f 93       	push	r17
    36d4:	cf 93       	push	r28
    36d6:	df 93       	push	r29
    36d8:	8c 01       	movw	r16, r24
    36da:	e0 91 e0 03 	lds	r30, 0x03E0
    36de:	f0 91 e1 03 	lds	r31, 0x03E1
    36e2:	83 81       	ldd	r24, Z+3	; 0x03
    36e4:	81 ff       	sbrs	r24, 1
    36e6:	21 c0       	rjmp	.+66     	; 0x372a <puts+0x5a>
    36e8:	c0 e0       	ldi	r28, 0x00	; 0
    36ea:	d0 e0       	ldi	r29, 0x00	; 0
    36ec:	0d c0       	rjmp	.+26     	; 0x3708 <puts+0x38>
    36ee:	e0 91 e0 03 	lds	r30, 0x03E0
    36f2:	f0 91 e1 03 	lds	r31, 0x03E1
    36f6:	20 85       	ldd	r18, Z+8	; 0x08
    36f8:	31 85       	ldd	r19, Z+9	; 0x09
    36fa:	bf 01       	movw	r22, r30
    36fc:	f9 01       	movw	r30, r18
    36fe:	09 95       	icall
    3700:	89 2b       	or	r24, r25
    3702:	11 f0       	breq	.+4      	; 0x3708 <puts+0x38>
    3704:	cf ef       	ldi	r28, 0xFF	; 255
    3706:	df ef       	ldi	r29, 0xFF	; 255
    3708:	f8 01       	movw	r30, r16
    370a:	81 91       	ld	r24, Z+
    370c:	8f 01       	movw	r16, r30
    370e:	88 23       	and	r24, r24
    3710:	71 f7       	brne	.-36     	; 0x36ee <puts+0x1e>
    3712:	e0 91 e0 03 	lds	r30, 0x03E0
    3716:	f0 91 e1 03 	lds	r31, 0x03E1
    371a:	20 85       	ldd	r18, Z+8	; 0x08
    371c:	31 85       	ldd	r19, Z+9	; 0x09
    371e:	8a e0       	ldi	r24, 0x0A	; 10
    3720:	bf 01       	movw	r22, r30
    3722:	f9 01       	movw	r30, r18
    3724:	09 95       	icall
    3726:	89 2b       	or	r24, r25
    3728:	11 f0       	breq	.+4      	; 0x372e <puts+0x5e>
    372a:	cf ef       	ldi	r28, 0xFF	; 255
    372c:	df ef       	ldi	r29, 0xFF	; 255
    372e:	ce 01       	movw	r24, r28
    3730:	df 91       	pop	r29
    3732:	cf 91       	pop	r28
    3734:	1f 91       	pop	r17
    3736:	0f 91       	pop	r16
    3738:	08 95       	ret

0000373a <__eerd_byte_m328p>:
    373a:	f9 99       	sbic	0x1f, 1	; 31
    373c:	fe cf       	rjmp	.-4      	; 0x373a <__eerd_byte_m328p>
    373e:	92 bd       	out	0x22, r25	; 34
    3740:	81 bd       	out	0x21, r24	; 33
    3742:	f8 9a       	sbi	0x1f, 0	; 31
    3744:	99 27       	eor	r25, r25
    3746:	80 b5       	in	r24, 0x20	; 32
    3748:	08 95       	ret

0000374a <calloc>:
    374a:	0f 93       	push	r16
    374c:	1f 93       	push	r17
    374e:	cf 93       	push	r28
    3750:	df 93       	push	r29
    3752:	68 9f       	mul	r22, r24
    3754:	80 01       	movw	r16, r0
    3756:	69 9f       	mul	r22, r25
    3758:	10 0d       	add	r17, r0
    375a:	78 9f       	mul	r23, r24
    375c:	10 0d       	add	r17, r0
    375e:	11 24       	eor	r1, r1
    3760:	c8 01       	movw	r24, r16
    3762:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <malloc>
    3766:	ec 01       	movw	r28, r24
    3768:	00 97       	sbiw	r24, 0x00	; 0
    376a:	29 f0       	breq	.+10     	; 0x3776 <calloc+0x2c>
    376c:	60 e0       	ldi	r22, 0x00	; 0
    376e:	70 e0       	ldi	r23, 0x00	; 0
    3770:	a8 01       	movw	r20, r16
    3772:	0e 94 c1 1b 	call	0x3782	; 0x3782 <memset>
    3776:	ce 01       	movw	r24, r28
    3778:	df 91       	pop	r29
    377a:	cf 91       	pop	r28
    377c:	1f 91       	pop	r17
    377e:	0f 91       	pop	r16
    3780:	08 95       	ret

00003782 <memset>:
    3782:	dc 01       	movw	r26, r24
    3784:	01 c0       	rjmp	.+2      	; 0x3788 <memset+0x6>
    3786:	6d 93       	st	X+, r22
    3788:	41 50       	subi	r20, 0x01	; 1
    378a:	50 40       	sbci	r21, 0x00	; 0
    378c:	e0 f7       	brcc	.-8      	; 0x3786 <memset+0x4>
    378e:	08 95       	ret

00003790 <_exit>:
    3790:	f8 94       	cli

00003792 <__stop_program>:
    3792:	ff cf       	rjmp	.-2      	; 0x3792 <__stop_program>
